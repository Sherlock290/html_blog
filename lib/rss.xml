<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[MyNoteTest]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>MyNoteTest</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 03 Dec 2024 06:43:44 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 03 Dec 2024 06:43:26 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[嵌套的CMake]]></title><description><![CDATA[ 
 <br><br><br>
<br>对于大型项目，使用嵌套的CMakeLists.txt文件可以简化构建配置，提高项目的可维护性。
<br><br>
<br>每个源码目录可以有自己的CMakeLists.txt文件。
<br>根CMakeLists.txt作为项目的入口，定义全局变量和子目录。
<br>使用add_subdirectory命令建立父子节点关系。
<br><br>
<br>根目录CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(test)
set(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)
set(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)
set(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)
set(CALC_LIB calc)
set(SORT_LIB sort)
set(APP_NAME_1 test1)
set(APP_NAME_2 test2)
add_subdirectory(calc)
add_subdirectory(sort)
add_subdirectory(test1)
add_subdirectory(test2)


<br><br>
<br>嵌套CMakeLists.txt是管理大型项目的有效方式，通过合理组织项目结构，可以提高构建效率和可读性。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\嵌套的CMake.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/嵌套的CMake.md</guid><pubDate>Sun, 27 Oct 2024 03:46:59 GMT</pubDate></item><item><title><![CDATA[使用pyocd进行调试仿真]]></title><description><![CDATA[ 
 <br><br>
<br>安装 Python：确保 Python 3.7 或更高版本已经安装。
<br>安装 pyOCD：通过 pip 安装 pyOCD：
python -m pip install -U pyocd -i httpsmirrors.aliyun.com/pypi/simple


<br>安装 libusb（如果需要）：
pip3 install libusb -i httpsmirrors.aliyun.com/pypi/simple


<br><br>
<br>环境变量：将 Python 脚本目录（例如 D:\Python3\Scripts）添加到系统环境变量中。
<br>添加芯片支持：

<br>以国民技术 N32G430 为例，将 Nationstech.N32G430_DFP.1.0.0.pack 解压。
<br>将 Nationstech.N32G430_DFP.pdsc 复制到 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager。
<br>在 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager 里新建 Nationstech/N32G430_DFP 文件夹。
<br>将 Nationstech.N32G430_DFP.1.0.0.pack 重命名为 1.0.0 并复制到新建的文件夹内。
<br>运行以下命令添加芯片包：
pack-manager add-packs Nationstech.N32G430_DFP.pdsc




<br>如果出现下列错误, 需要根据错误提示修改pdsc文件<br>PS D:\MyWorkSpace\Keil_Pro\Nations.N32G430_Library.1.0.0\Nations.N32G430_Library.1.0.0\Nations.N32G430_DFP.1.0.0&gt; pack-manager add-packs Nationstech.N32G430_DFP.pdsc
02:53:06 [ERROR] when trying to parse component: child element "description" not found in "component" element
02:53:06 [ERROR] when trying to parse component: child element "description" not found in "component" element
02:53:06 [ERROR] when trying to parse component: child element "description" not found in "component" element
02:53:06 [ERROR] when trying to parse component: child element "description" not found in "component" element
PS D:\MyWorkSpace\Keil_Pro\Nations.N32G430_Library.1.0.0\Nations.N32G430_Library.1.0.0\Nations.N32G430_DFP.1.0.0&gt;
<br><br>
<br>更新芯片索引：
pyocd pack update


<br>查看已安装的芯片pack
pyocd pack show


<br>3. **查看支持的芯片**：
   ```bash
   pyocd list targets
<br>
<br>编译和烧录：

<br>将烧录脚本复制到 .vscode 文件夹下。
<br>示例任务配置（tasks.json）：
{
  "label": "download",
  "type": "shell",
  "command": "pyocd",
  "args": ["flash", "erase", "chip", "target", "py32f003x4", "build/bin/VP100_B.hex"],
  "group": "build"
}




<br><br>
<br>
安装 Cortex Debug 插件：在 VSCode 中安装。

<br>
配置调试：

<br>在 .vscode/launch.json 中添加调试配置：
{
  "cwd": "${workspaceFolder}",
  "executable": "./build/bin/VP100_B.elf",
  "name": "Debug with PyOCD",
  "request": "launch",
  "type": "cortex-debug",
  "runToEntryPoint": "main",
  "showDevDebugOutput": "both",
  "servertype": "pyocd",
  "targetId": "py32f003x4",
  "serverArgs": ["frequency", "1000000"],
  "interface": "swd",
  "armToolchainPath": "D:/win-cross-compiler/bin",
  "gdbPath": "D:/win-cross-compiler/bin/arm-none-eabi-gdb.exe"
}




<br>
设置快捷键：

<br>在 keybindings.json 中添加自定义绑定：
{
  "key": "f6",
  "command": "workbench.action.tasks.runTask",
  "args": "build",
  "when": "editorTextFocus"
},
{
  "key": "f7",
  "command": "workbench.action.tasks.runTask",
  "args": "download",
  "when": "editorTextFocus"
}




<br>通过这些步骤，你可以配置和使用 pyOCD 进行微控制器的编程和调试。确保根据你的实际开发环境和目标微控制器调整相应的路径和配置。]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\使用pyocd进行调试仿真.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/使用pyocd进行调试仿真.md</guid><pubDate>Tue, 03 Dec 2024 02:54:00 GMT</pubDate></item><item><title><![CDATA[CMake的使用]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake支持多种命令，可以编写CMakeLists.txt文件来配置项目构建。
<br><br>
<br>支持大写、小写、混合大小写的命令。
<br>注释：使用#进行行注释，使用#[[ ]]进行块注释。
<br><br>
<br>行注释示例：
# 这是一个 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.0.0)


<br>块注释示例：
#[[ 这是一个 CMakeLists.txt 文件。
这是一个 CMakeLists.txt 文件
这是一个 CMakeLists.txt 文件]]
cmake_minimum_required(VERSION 3.0.0)


<br><br>
<br>CMake的灵活性和强大的配置功能使其成为项目构建过程中不可或缺的工具。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake的使用.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake的使用.md</guid><pubDate>Sun, 27 Oct 2024 03:46:58 GMT</pubDate></item><item><title><![CDATA[CMake概述]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake是一个跨平台的项目构建工具，可以自动生成Makefile和工程文件。
<br><br>
<br>与Makefile、nmake、GNU make、qmake等构建工具相比，CMake解决了平台依赖和编写工作量大的问题。
<br>CMake允许开发者指定整个工程的编译流程，并自动生成本地化的Makefile。
<br>CMake的优点包括跨平台、管理大型项目、简化编译构建过程、可扩展性。
<br><br>
<br>构建流程图示：

<br>使用makefile构建项目的过程（蓝色虚线）
<br>使用cmake构建项目的过程（红色实线）


<br><br>
<br>CMake通过简化编译构建过程，成为跨平台项目构建的重要工具。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake概述.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake概述.md</guid><pubDate>Sun, 01 Dec 2024 16:23:07 GMT</pubDate></item><item><title><![CDATA[CMake构建项目]]></title><description><![CDATA[ 
 <br><br><br>
<br>通过CMake构建项目时，可以生成库文件和可执行文件，并指定它们的输出路径。
<br><br>
<br>使用add_library生成静态库或动态库。
<br>使用add_executable生成可执行文件。
<br>使用set(EXECUTABLE_OUTPUT_PATH)和set(LIBRARY_OUTPUT_PATH)指定输出路径。
<br>使用link_directories和target_link_libraries链接库文件。
<br><br>
<br>calc目录CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALCLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${CALC_LIB} STATIC ${SRC})


<br>sort目录CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(SORTLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${SORT_LIB} SHARED ${SRC})


<br>test1目录CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALCTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
link_directories(${LIB_PATH})
link_libraries(${CALC_LIB})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
add_executable(${APP_NAME_1} ${SRC})


<br>test2目录CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(SORTTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
link_directories(${LIB_PATH})
add_executable(${APP_NAME_2} ${SRC})
target_link_libraries(${APP_NAME_2} ${SORT_LIB})


<br><br>
<br>通过CMake可以灵活地控制项目构建过程，包括库文件和可执行文件的生成与链接。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake构建项目.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake构建项目.md</guid><pubDate>Sun, 27 Oct 2024 03:46:58 GMT</pubDate></item><item><title><![CDATA[CMake流程控制]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake中的流程控制允许开发者在构建脚本中进行条件判断和循环操作。
<br><br>
<br>条件判断：通过if、elseif、else和endif实现，支持基本表达式、逻辑运算符和比较运算符。
<br>基本表达式：包括常量、变量和字符串，根据具体值判断真假。
<br>逻辑判断：使用NOT、AND、OR进行逻辑运算。
<br>比较操作：包括数值比较（LESS、GREATER等）和字符串比较（STRLESS、STRGREATER等）。
<br>文件操作：判断文件或目录存在（EXISTS）、是否为目录（IS_DIRECTORY）、是否为软连接（IS_SYMLINK）等。
<br>循环：foreach和while循环用于遍历列表、执行重复任务。
<br><br>
<br>条件判断：
if(&lt;expression&gt;)
  # 执行命令
endif()


<br>文件操作：
if(EXISTS ${FILE_PATH})
  # 执行命令
endif()


<br>foreach循环：
foreach(item IN LISTS ITEM_LIST)
  # 执行命令
endforeach()


<br>while循环：
while(&lt;condition&gt;)
  # 执行命令
endwhile()


<br><br>
<br>CMake的流程控制功能为构建脚本提供了强大的逻辑处理能力，使得构建过程更加灵活和可控。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake流程控制.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake流程控制.md</guid><pubDate>Sun, 27 Oct 2024 03:46:58 GMT</pubDate></item><item><title><![CDATA[CMake命令执行和项目构建]]></title><description><![CDATA[ 
 <br><br><br>
<br>使用cmake命令生成Makefile，然后通过make命令构建项目。
<br><br>
<br>在项目根目录下执行cmake .命令生成Makefile。
<br>执行make命令根据Makefile构建项目。
<br>可将生成的构建文件放在单独的build目录中，以保持源码目录的整洁。
<br><br>
<br>执行CMake命令：
cmake .


<br>执行Make命令：
make


<br><br>
<br>CMake和Make的结合使用，为C++项目提供了一种高效且灵活的构建方式。
<br>以上是根据您提供的文章内容制作的卡片笔记，每个卡片都包含了文章的关键信息和示例，以便于记忆和复习。如果您有更多的内容需要转换，请随时提供。]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake命令执行和项目构建.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake命令执行和项目构建.md</guid><pubDate>Sun, 27 Oct 2024 03:46:51 GMT</pubDate></item><item><title><![CDATA[CMake条件判断]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake允许在CMakeLists.txt中使用条件判断。
<br><br>
<br>条件判断支持多个elseif块，必须成对使用if和endif。
<br>基本表达式可以是常量、变量或字符串，具体值决定了True或False。
<br>逻辑判断包括取反（NOT）、逻辑与（AND）、逻辑或（OR）。
<br>比较操作包括数值比较和字符串比较，支持多种比较符号。
<br>文件操作包括判断文件或目录是否存在、是否为目录、是否为软连接、是否为绝对路径。
<br><br>
<br>条件判断语法：
if(&lt;condition&gt;)
  &lt;commands&gt;
elseif(&lt;condition&gt;)
  &lt;commands&gt;
else()
  &lt;commands&gt;
endif()


<br>基本表达式和逻辑判断：
if(1 OR NOT "some string" STREQUAL "")


<br>比较操作：
if(VAR LESS 10)
if(STRVAR STRGREATER "example")


<br>文件操作：
if(EXISTS path-to-file)


<br><br>
<br>通过丰富的条件判断表达式，CMake能够灵活地处理各种构建场景。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake条件判断.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake条件判断.md</guid><pubDate>Sun, 27 Oct 2024 03:46:58 GMT</pubDate></item><item><title><![CDATA[CMake循环]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake支持foreach和while两种循环结构。
<br><br>
<br>foreach可以遍历列表、范围或进行Zipped列表遍历。
<br>while循环基于条件判断，直到条件为False才结束循环。
<br><br>
<br>foreach循环示例：
foreach(item RANGE 0 10)
  message(STATUS "当前遍历的值为: ${item}")
endforeach()


<br>while循环示例：
set(COUNT 5)
while(COUNT GREATER 0)
  message(STATUS "COUNT=${COUNT}")
  math(EXPR COUNT "${COUNT} - 1")
endwhile()


<br><br>
<br>CMake的循环结构使得构建脚本能够执行重复任务，增强了脚本的自动化能力。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake循环.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake循环.md</guid><pubDate>Sun, 27 Oct 2024 03:47:00 GMT</pubDate></item><item><title><![CDATA[CMake中的宏定义]]></title><description><![CDATA[ 
 <br><br><br>
<br>宏定义在程序测试中用于控制代码段是否生效，增加代码的灵活性。
<br><br>
<br>代码中的宏定义：通过预处理器指令#define定义宏，使用#ifdef、#ifndef进行条件编译。
<br>命令行宏定义：在gcc/g++命令中使用-D参数定义宏，如gcc test.c -DDEBUG -o app。
<br>CMake中的宏定义：使用add_definitions(-D宏名称)在CMake中定义宏。
<br><br>
<br>代码中的宏定义：
#define NUMBER 3
#ifdef DEBUG
printf("我是一个程序猿, 我不会爬树...\n");
#endif


<br>命令行宏定义：
$ gcc test.c -DDEBUG -o app


<br>CMake中的宏定义：
add_definitions(-DDEBUG)
add_executable(app ./test.c)


<br><br>
<br>PROJECT_SOURCE_DIR：工程的根目录。
<br>PROJECT_BINARY_DIR：执行cmake命令的目录。
<br>CMAKE_CURRENT_SOURCE_DIR：当前处理的CMakeLists.txt所在的路径。
<br>CMAKE_CURRENT_BINARY_DIR：target 编译目录。
<br>EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置。
<br>LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置。
<br>PROJECT_NAME：返回通过PROJECT指令定义的项目名称。
<br>CMAKE_BINARY_DIR：项目实际构建路径。
<br><br>
<br>使用预定义宏的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(TEST)
message(STATUS "Project Source Directory: ${PROJECT_SOURCE_DIR}")
message(STATUS "Project Binary Directory: ${PROJECT_BINARY_DIR}")
message(STATUS "Current Source Directory: ${CMAKE_CURRENT_SOURCE_DIR}")
message(STATUS "Executable Output Path: ${EXECUTABLE_OUTPUT_PATH}")
message(STATUS "Library Output Path: ${LIBRARY_OUTPUT_PATH}")
message(STATUS "Project Name: ${PROJECT_NAME}")
message(STATUS "CMake Binary Directory: ${CMAKE_BINARY_DIR}")


<br><br>
<br>宏定义是C/C++编程中常用的技术手段，CMake通过add_definitions命令提供了在构建过程中定义宏的能力，同时CMake还预定义了一系列有用的宏，方便项目构建管理。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的宏定义.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的宏定义.md</guid><pubDate>Sun, 27 Oct 2024 03:46:56 GMT</pubDate></item><item><title><![CDATA[CMake中的库文件链接]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake提供了命令来链接静态库和动态库。
<br><br><br>
<br>使用link_libraries命令链接静态库：
link_libraries(calc)


<br><br>
<br>使用target_link_libraries命令链接动态库：
target_link_libraries(app pthread)


<br><br>
<br>
链接静态库的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALC)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
include_directories(${PROJECT_SOURCE_DIR}/include)
link_directories(${PROJECT_SOURCE_DIR}/lib)
link_libraries(calc)
add_executable(app ${SRC_LIST})


<br>
链接动态库的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
include_directories(${PROJECT_SOURCE_DIR}/include)
add_executable(app ${SRC_LIST})
target_link_libraries(app pthread calc)


<br><br>
<br>CMake的链接命令使得库的使用变得简单，支持静态和动态库的灵活管理。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件链接.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件链接.md</guid><pubDate>Sun, 27 Oct 2024 03:46:53 GMT</pubDate></item><item><title><![CDATA[CMake中的库文件输出路径设置]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake允许用户自定义库文件的输出路径。
<br><br><br>
<br>使用EXECUTABLE_OUTPUT_PATH设置动态库生成路径：
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


<br><br>
<br>使用LIBRARY_OUTPUT_PATH设置静态库和动态库的生成路径：
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


<br><br>
<br>设置输出路径的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
add_library(calc STATIC ${SRC_LIST})


<br><br>
<br>通过设置输出路径，可以有效管理生成的库文件，保持项目结构的整洁。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件输出路径设置.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件输出路径设置.md</guid><pubDate>Sun, 27 Oct 2024 03:46:46 GMT</pubDate></item><item><title><![CDATA[CMake中的库文件制作]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake支持生成静态库和动态库，方便代码复用和模块化。
<br><br><br>
<br>使用命令：
add_library(库名称 STATIC 源文件1 [源文件2] ...)


<br>在Linux中，静态库文件名格式为lib&lt;库名&gt;.a。
<br><br>
<br>使用命令：
add_library(库名称 SHARED 源文件1 [源文件2] ...)


<br>在Linux中，动态库文件名格式为lib&lt;库名&gt;.so。
<br><br>
<br>创建静态库的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc STATIC ${SRC_LIST})


<br>创建动态库的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc SHARED ${SRC_LIST})


<br><br>
<br>CMake提供了简单的命令来创建和管理静态库与动态库，增强了项目的模块化。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件制作.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件制作.md</guid><pubDate>Sun, 27 Oct 2024 03:46:53 GMT</pubDate></item><item><title><![CDATA[CMake中的日志和变量操作]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMake支持输出日志信息和对变量进行操作。
<br><br><br>
<br>使用message命令输出不同级别的日志：
message(STATUS "source path: ${PROJECT_SOURCE_DIR}")
message(WARNING "Warning message")
message(FATAL_ERROR "Fatal error message")


<br><br>
<br>追加字符串：
set(VAR1 "Hello")
set(VAR1 "${VAR1} World")


<br>移除列表中的元素：
list(REMOVE_ITEM SRC_LIST ${PROJECT_SOURCE_DIR}/main.cpp)


<br><br>
<br>日志和变量操作的CMakeLists.txt：
cmake_minimum_required(VERSION 3.0)
project(TEST)
set(TEMP "hello,world")
file(GLOB SRC_LIST ${PROJECT_SOURCE_DIR}/*.cpp)
message(STATUS "Current source files: ${SRC_LIST}")
list(REMOVE_ITEM SRC_LIST ${PROJECT_SOURCE_DIR}/main.cpp)


<br><br>
<br>CMake的日志和变量操作功能增强了项目构建过程中的可视化和灵活性。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的日志和变量操作.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的日志和变量操作.md</guid><pubDate>Sun, 27 Oct 2024 03:46:51 GMT</pubDate></item><item><title><![CDATA[CMakeLists.txt 文件编写示例]]></title><description><![CDATA[ 
 <br><br><br>
<br>CMakeLists.txt文件用于定义项目的构建规则和配置。
<br><br>
<br>cmake_minimum_required：指定CMake的最低版本要求。
<br>project：定义项目名称和版本。
<br>add_executable：将源文件编译成可执行文件。
<br>include_directories：指定头文件搜索路径。
<br>aux_source_directory和file：搜索并包含源文件和头文件。
<br><br>
<br>定义项目和构建可执行文件：
cmake_minimum_required(VERSION 3.0)
project(CALC)
add_executable(app add.c div.c main.c mult.c sub.c)


<br>搜索源文件和头文件：
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)


<br><br>
<br>CMakeLists.txt是CMake项目的核心，通过定义构建规则和配置，使得项目构建变得简单高效。
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\CMakeLists.txt 文件编写示例.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMakeLists.txt 文件编写示例.md</guid><pubDate>Sun, 27 Oct 2024 03:14:26 GMT</pubDate></item><item><title><![CDATA[pyocd的简单使用]]></title><description><![CDATA[ 
 <br>安装和使用 pyOCD 的步骤如下：<br><br>
<br>
确保 Python 环境：首先，你需要确保你的计算机上安装了 Python 3.7 或更高版本。

<br>
使用 pip 安装：在命令行（终端）中，运行以下命令来安装 pyOCD：
pip install -U pyocd


<br>阿里云国内镜像源<br>   pip install -U pyocd -i https://mirrors.aliyun.com/pypi/simple
<br>
<br>安装 libusb：在某些系统上，你可能还需要安装 libusb，可以通过 pip 安装：
pip install -U libusb 


<br>阿里云国内镜像源<br>   pip install -U libusb -i https://mirrors.aliyun.com/pypi/simple
<br>
<br>解决权限问题：在 Linux 或 macOS 上，你可能需要设置 udev 规则来允许用户空间访问调试探针。pyOCD 会提供示例 udev 规则文件。
<br><br>
<br>
查看帮助信息：安装完成后，你可以通过运行以下命令来查看 pyOCD 的帮助信息和子命令：
pyocd --help


<br>
列出连接的设备：要查看连接到计算机的调试器和目标设备，可以使用以下命令：
pyocd list


<br>
擦除操作：使用以下命令对目标设备进行擦除操作：
pyocd erase --chip --target &lt;target_name&gt;

其中 &lt;target_name&gt; 是你的目标微控制器名称。

<br>
烧录固件：将固件烧录到目标设备，可以使用以下命令：
pyocd flash --target &lt;target_name&gt; &lt;firmware_file&gt;

其中 &lt;firmware_file&gt; 是你的固件文件路径。

<br>
复位设备：对目标设备进行复位，可以使用以下命令：
pyocd reset --target &lt;target_name&gt;


<br>
使用 GDB 调试：pyOCD 支持与 GDB 配合使用进行调试。首先启动 GDB 服务器：
pyocd gdbserver --target &lt;target_name&gt;

然后，在另一个终端窗口中，使用 GDB 连接到 pyOCD 的 GDB 服务器：
gdb &lt;your_gdb_script&gt;
target remote :3333


<br>
使用 Python API：如果你需要更复杂的操作，可以使用 pyOCD 的 Python API 来编写脚本。以下是一个简单的示例，展示如何连接到目标并设置断点：
from pyocd.core.helpers import connect
from pyocd.debug.context import TargetContext

def main():
    session, target = connect()
    ctx = TargetContext(target)
    addr = 0x08000000
    ctx.write_breakpoint(addr)
    target.resume()

if __name__ == "__main__":
    main()


<br>确保在编写脚本时，你已经根据目标微控制器的实际情况调整了目标名称和地址。<br><br>
<br>权限问题：如果在安装或运行时遇到权限问题，请尝试使用 --user 选项安装，或者在 Linux 上使用 sudo（不推荐，除非必要）。
<br>调试接口：确保你的微控制器或调试器兼容 pyOCD 支持的接口，如 JTAG、SWD 等。
<br>固件格式：确保你烧录的固件格式正确，如 ELF、BIN 或 HEX。
<br>通过这些步骤，你应该能够成功安装并开始使用 pyOCD 进行微控制器的调试和编程。如果遇到具体问题，可以查看 pyOCD 的官方文档或在社区寻求帮助。]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\pyocd的简单使用.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/pyocd的简单使用.md</guid><pubDate>Sun, 27 Oct 2024 03:46:56 GMT</pubDate></item><item><title><![CDATA[pyocd配置芯片支持包]]></title><description><![CDATA[ 
 <br><br>Kimi: pyOCD 是一个开源的 Python 软件包，它支持多种硬件调试器进行 Arm Cortex-M 微控制器的编程和调试。它内置支持多达 70 种流行的 MCU，并且可以通过使用 CMSIS-Pack 来支持市场上的所有 Cortex-M 芯片。要查看 pyOCD 支持的芯片列表，可以使用以下命令：<br>
<br>pyocd list --targets：列出所有支持的目标（芯片）类型。
<br>pyocd list --probes：列出当前电脑上连接的 pyOCD 所支持的调试工具。
<br>此外，pyOCD 还支持通过 CMSIS-Pack 来添加对新芯片的支持。如果某个芯片不在内置支持列表中，可以通过安装相应的 CMSIS-Pack 来添加支持。安装 Pack 的命令如下：<br>
<br>pyocd pack -u：更新本地的 Pack 索引。
<br>pyocd pack -i &lt;part_number&gt;：安装指定芯片型号的 Pack。
<br>例如，如果需要添加对 MM32F5277E9PV 芯片的支持，可以首先尝试通过 pyocd pack -f mm32f5277e9pv 来查找是否有可用的 Pack。如果没有，可能需要手动下载相应的 Pack 文件，并将其放置在正确的目录下，或者更新本地的 index.json 文件来包含该芯片的信息。<br>需要注意的是，CMSIS-Packs 可能存在错误或信息不完整，如果在使用过程中遇到问题，可以向 pyOCD 的 GitHub 网站报告问题，同时也应向 Pack 供应商报告以便修复。<br>以上信息综合了多个来源，包括官方文档和用户的实际使用经验。如果你有特定的芯片型号需要支持，可以尝试上述方法来查看或添加支持。 <br><br>Kimi: 要手动安装已下载的 CMSIS-Pack 文件到 pyOCD，可以按照以下步骤进行：<br>
<br>
找到 CMSIS-Pack 存放路径：默认情况下，pyOCD 的 Pack 文件存放在以下路径：
C:\Users\&lt;你的用户名&gt;\AppData\Local\cmsis-pack-manager\cmsis-pack-manager\


<br>
创建文件夹：在上述路径下，创建一个新的文件夹，命名为对应的厂商名（例如 Keil 或 GigaDevice），然后在该文件夹内再创建一个子文件夹，命名为具体的设备系列（例如 STM32F4xx_DFP）。

<br>
放置 Pack 文件：将下载的 .pack 文件放入刚创建的设备系列文件夹中，并确保将其重命名为标准格式（例如 2.16.0.pack），以便 pyOCD 能够识别。

<br>
更新 Pack 索引：在命令行中运行以下命令来更新 Pack 索引：
pyocd pack -u


<br>
确认安装：使用以下命令查看已安装的 Pack：
pyocd pack -s


<br>如果你想要安装特定的 Pack，可以使用：<br>pyocd pack -i &lt;part_number&gt;
<br>这将自动下载并安装对应的 Pack 文件，但如果网络不佳，手动安装会更可靠。<br>通过以上步骤，你应该能够成功安装手动下载的 Pack 文件，并使 pyOCD 支持相应的芯片。 <br><br>
<br>以国民技术 N32G430 为例，将 Nationstech.N32G430_DFP.1.0.0.pack 解压。
<br>将 Nationstech.N32G430_DFP.pdsc 复制到 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager。
<br>在 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager 里新建 Nationstech/N32G430_DFP 文件夹。
<br>将 Nationstech.N32G430_DFP.1.0.0.pack 重命名为 1.0.0.pack 并复制到新建的文件夹内。
<br>运行以下命令添加芯片包：
<br>pack-manager add-packs Nations.N32G430_DFP.pdsc
<br>
<br>安装芯片包：
<br>pyocd pack -i N32G430
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\D\pyocd配置芯片支持包.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/D/pyocd配置芯片支持包.md</guid><pubDate>Sun, 27 Oct 2024 03:46:53 GMT</pubDate></item><item><title><![CDATA[工具集VSCode+CMake+Ninja+ arm-gcc+OpenOCD/PyOCD+clangd+git]]></title><description><![CDATA[ 
 <br><br><br>
<a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" href="1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署.html" class="internal-link" target="_self" rel="noopener nofollow">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署</a>9
<br>vscode 是微软发布的一款代码编辑器，注意仅仅是代码编辑器。但是，依托其丰富的插件市场，在安装必要的插件后可以实现特定开发领域 IDE 的功能。比如，替代 IAR 或 Keil 作为<a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&amp;zhida_source=entity&amp;is_preview=1" target="_blank">嵌入式开发</a>环境。<br>相对于 IAR 和 Keil，vscode 具有启动速度快、现代化的界面风格、强大的代码编辑功能、商业免费等优点。借助必要的插件可以实现编译、调试等功能，相对于传统的 IDE ，vscode 的调试功能略显薄弱，但是绝对是够用的。笔者已经在一些比较复杂的项目中使用 vscode 作为主力开发环境了，完全了可以胜任日常的开发工作。<br>接下来，你可以按照如下步骤安装 vscode 及必要的插件。<br>
<br>打开链接： <a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://code.visualstudio.com/" target="_blank">Visual Studio Code - Code Editing. Redefined</a>，下载 vscode 并安装；
<br>安装完成后，打开 vscode 安装插件
<br>
<br>clangd 用于代码提示；
<br><img alt="https://pic1.zhimg.com/80/v2-5466be73242fdb3f046886d3888accda_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp" referrerpolicy="no-referrer"><br><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/VSCode - 使用Clangd搭建C++开发环境" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/VSCode - 使用Clangd搭建C++开发环境" href="1_Projects\嵌入式软件开发-交叉编译-2p\VSCode - 使用Clangd搭建C++开发环境.html" class="internal-link" target="_self" rel="noopener nofollow">VSCode - 使用Clangd搭建C++开发环境</a><br>
<br>Cortex-Debug 这个插件提供了调试功能，支持寄存器查看、内存查看、断点调试、变量观察等功能。
<br><img alt="https://pic1.zhimg.com/80/v2-b653c734688acaaa368f25d4cb26815a_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b653c734688acaaa368f25d4cb26815a_720w.webp" referrerpolicy="no-referrer"><br>
<br>Embedded Tools 这是微软官方提供的调试插件，功能和 Cortex Debug相似；在实际使用的时候和 Cortex-Debug 二选一便可；
<br><img alt="https://pic4.zhimg.com/80/v2-b1572bf5f85ba8fa90cc0b0e379e84df_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b1572bf5f85ba8fa90cc0b0e379e84df_720w.webp" referrerpolicy="no-referrer"><br><br><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" href="1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署.html" class="internal-link" target="_self" rel="noopener nofollow">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署</a>9<br>你可以通过如下命令获取到除 vscode 以外的所有工具，前提是你已经安装了 Git 工具。<br>git clone https://gitee.com/sherlock290/arm_development_toolchains.git
<br>仓库内容如下, 需要将对应工具的路径加入环境变量<br><img alt="IMG-F2E79A8D1C52F307273E83179CCCDF63-20241202101935503" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F2E79A8D1C52F307273E83179CCCDF63-20241202101935503.png" referrerpolicy="no-referrer"><br>双击或通过命令行运行add_to_path.bat添加环境变量, 添加后需要自行重启系统<br>环境变量的配置方式与验证方法 <a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署" href="1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署.html" class="internal-link" target="_self" rel="noopener nofollow">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署</a>9<br><br>arm-none-eabi-gcc<br>arm-none-eabi-gcc -v
<br>MinGW<br>make -v
gcc -v
<br>Ninja<br>ninja --version
<br>cmake<br>cmake --version
<br>openocd<br>openocd --version
<br><br>PyOCD可以安装pack文件<br><br><br>
<br>安装 Python：确保 Python 3.7 或更高版本已经安装。
<br>安装 pyOCD：通过 pip 安装 pyOCD：
python -m pip install -U pyocd -i httpsmirrors.aliyun.com/pypi/simple


<br>安装 libusb（如果需要）：
pip3 install libusb -i httpsmirrors.aliyun.com/pypi/simple


<br><br>
<br>环境变量：将 Python 脚本目录（例如 D:\Python3\Scripts）添加到系统环境变量中。
<br>添加芯片支持：

<br>以国民技术 N32G430 为例，将 Nationstech.N32G430_DFP.1.0.0.pack 解压。
<br>将 Nationstech.N32G430_DFP.pdsc 复制到 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager。
<br>在 C:\Users\xxx\AppData\Local\cmsis-pack-manager\cmsis-pack-manager 里新建 Nationstech/N32G430_DFP 文件夹。
<br>将 Nationstech.N32G430_DFP.1.0.0.pack 重命名为 1.0.0 并复制到新建的文件夹内。
<br>运行以下命令添加芯片包：

pack-manager add-packs Nations.N32G430_DFP.pdsc


<br>确认安装：使用以下命令查看已安装的 Pack：

pyocd pack -s


]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\E\嵌入式交叉编译环境搭建.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/E/嵌入式交叉编译环境搭建.md</guid><pubDate>Mon, 02 Dec 2024 05:45:22 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[查看 GCC 预定义宏方法]]></title><description><![CDATA[ 
 <br><br><br># 方法1：创建临时文件（推荐）
echo $null &gt; temp.c
arm-none-eabi-gcc -dM -E temp.c | findstr UINT32

# 方法2：使用 nul（注意使用小写）
arm-none-eabi-gcc -dM -E nul | findstr UINT32

# 查看所有预定义宏
arm-none-eabi-gcc -dM -E temp.c | more

# 搜索特定宏（例如：查找所有包含 INT 的宏）
arm-none-eabi-gcc -dM -E temp.c | findstr INT
<br><br>:: 方法1：使用 NUL（在 CMD 中大小写都可以）
arm-none-eabi-gcc -dM -E NUL | findstr UINT32

:: 方法2：使用重定向
arm-none-eabi-gcc -dM -E - &lt; NUL | findstr UINT32

:: 查看所有预定义宏
arm-none-eabi-gcc -dM -E NUL | more

:: 搜索特定宏
arm-none-eabi-gcc -dM -E NUL | findstr INT
<br><br>
<br>PowerShell 中建议使用临时文件方法，更加可靠
<br>PowerShell 中使用 nul 时需要小写
<br>CMD 中 NUL 大小写都可以
<br>使用完临时文件后可以删除：rm temp.c
<br>findstr 是 Windows 下的搜索命令，类似 Linux 中的 grep
<br><br># 创建临时文件
echo $null &gt; temp.c

# 搜索 32 位相关的类型定义
arm-none-eabi-gcc -dM -E temp.c | findstr "INT32|UINT32"

# 搜索所有位宽的整型定义
arm-none-eabi-gcc -dM -E temp.c | findstr "INT[0-9]"

# 搜索编译器版本信息
arm-none-eabi-gcc -dM -E temp.c | findstr "VERSION"

# 使用完后删除临时文件
rm temp.c
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\查看 GCC 预定义宏方法.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/查看 GCC 预定义宏方法.md</guid><pubDate>Sun, 01 Dec 2024 02:08:17 GMT</pubDate></item><item><title><![CDATA[尝试自己编写n32g430的openocd配置文件]]></title><description><![CDATA[ 
 <br>我们可以基于STM32F4的配置文件来创建N32G430的配置文件。N32G430也是基于Cortex-M4内核，很多配置可以参考。<br>让我创建一个更完整的配置文件：<br># N32G430系列配置文件

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

# 设置芯片名称
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME n32g430
}

set _ENDIAN little

# RAM工作区配置 - N32G430C8L6 有32KB SRAM
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x8000
}

# CPU TAP ID
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # Cortex-M4 TAP ID
      set _CPUTAPID 0x4ba00477
   } {
      # SWD模式下的ID
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# Flash配置 - N32G430C8L6有64KB Flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f2x 0x08000000 0x10000 0 0 $_TARGETNAME

# 调试器速度配置
adapter speed 2000

# 复位配置
adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
   cortex_m reset_config sysresetreq
}

# 调试配置
$_TARGETNAME configure -event examine-end {
   # 启用低功耗模式下的调试
   mmw 0xE0042004 0x00000007 0

   # 暂停时停止看门狗
   mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event reset-init {
   # 配置系统时钟
   adapter speed 4000
}

$_TARGETNAME configure -event reset-start {
   adapter speed 2000
}

<br>这个配置文件的主要特点：<br>
<br>
基本配置:

<br>使用Cortex-M4的标准配置
<br>支持JTAG和SWD两种调试模式
<br>默认使用SWD模式（更常用）


<br>
内存配置:

<br>Flash起始地址：0x08000000
<br>Flash大小：64KB (0x10000)
<br>SRAM工作区：32KB (0x8000)


<br>
调试特性:

<br>支持低功耗模式下的调试
<br>支持在调试时停止看门狗
<br>自动配置适当的调试速度


<br>使用方法：<br>
<br>将此文件保存为n32g430.cfg
<br>放在OpenOCD的scripts/target目录下
<br>启动命令：
<br>openocd -f interface/cmsis-dap.cfg -f target/n32g430.cfg
<br>如果使用其他调试器：<br>
<br>J-Link: 使用interface/jlink.cfg
<br>ST-Link: 使用interface/stlink.cfg
<br>调试提示：<br>
<br>如果连接不稳定，可以尝试降低adapter speed的值
<br>确保电源供应稳定
<br>如果使用SWD模式，确保SWDIO和SWCLK连接正确
<br>这个配置文件应该能满足基本的调试需求。如果遇到特定问题，我们可以进一步调整相关参数。<br><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/OpenOCD添加第三方设备支持HT32F52352 Cortex-M0" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/OpenOCD添加第三方设备支持HT32F52352 Cortex-M0" href="1_Projects\嵌入式软件开发-交叉编译-2p\OpenOCD添加第三方设备支持HT32F52352 Cortex-M0.html" class="internal-link" target="_self" rel="noopener nofollow">OpenOCD添加第三方设备支持HT32F52352 Cortex-M0</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\尝试自己编写n32g430的openocd配置文件.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/尝试自己编写n32g430的openocd配置文件.md</guid><pubDate>Sun, 01 Dec 2024 15:06:58 GMT</pubDate></item><item><title><![CDATA[东宇写的环境搭建步骤]]></title><description><![CDATA[ 
 <br><a data-href="3_Resources/Attachments/嵌入式软件开发-交叉编译-2p/IMG-05828CE31D56A599E835562D33A3FEEE-20241201193842799.pdf" href="3_Resources\Attachments\嵌入式软件开发-交叉编译-2p\IMG-05828CE31D56A599E835562D33A3FEEE-20241201193842799.pdf" class="internal-link" target="_self" rel="noopener nofollow">3_Resources/Attachments/嵌入式软件开发-交叉编译-2p/IMG-05828CE31D56A599E835562D33A3FEEE-20241201193842799.pdf</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\东宇写的环境搭建步骤.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/东宇写的环境搭建步骤.md</guid><pubDate>Sun, 01 Dec 2024 11:38:43 GMT</pubDate></item><item><title><![CDATA[嵌入式软件开发-交叉编译-2p]]></title><description><![CDATA[ 
 File*CreatedModifiedtags<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>1<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（上）.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（上）.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\CMake 保姆级教程（上）.html" class="internal-link" target="_self" rel="noopener nofollow">CMake 保姆级教程（上）</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-12-01" data-href="2024-12-01" href="2024-12-01" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-12-01 19:38:42</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>2<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（下）.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（下）.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\CMake 保姆级教程（下）.html" class="internal-link" target="_self" rel="noopener nofollow">CMake 保姆级教程（下）</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-12-01" data-href="2024-12-01" href="2024-12-01" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-12-01 19:38:42</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>3<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMakeLists.txt 文件编写示例.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMakeLists.txt 文件编写示例.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMakeLists.txt 文件编写示例.html" class="internal-link" target="_self" rel="noopener nofollow">CMakeLists.txt 文件编写示例</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:14:26</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:14:26</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>4<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的宏定义.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的宏定义.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的宏定义.html" class="internal-link" target="_self" rel="noopener nofollow">CMake中的宏定义</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:56</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:56</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>5<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件制作.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件制作.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件制作.html" class="internal-link" target="_self" rel="noopener nofollow">CMake中的库文件制作</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>6<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件链接.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件链接.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件链接.html" class="internal-link" target="_self" rel="noopener nofollow">CMake中的库文件链接</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:53</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>7<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件输出路径设置.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件输出路径设置.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件输出路径设置.html" class="internal-link" target="_self" rel="noopener nofollow">CMake中的库文件输出路径设置</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:46</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:46</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>8<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的日志和变量操作.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的日志和变量操作.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的日志和变量操作.html" class="internal-link" target="_self" rel="noopener nofollow">CMake中的日志和变量操作</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:51</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:51</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>9<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake命令执行和项目构建.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake命令执行和项目构建.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake命令执行和项目构建.html" class="internal-link" target="_self" rel="noopener nofollow">CMake命令执行和项目构建</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:51</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:51</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>10<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake条件判断.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake条件判断.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake条件判断.html" class="internal-link" target="_self" rel="noopener nofollow">CMake条件判断</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>11<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake循环.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake循环.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake循环.html" class="internal-link" target="_self" rel="noopener nofollow">CMake循环</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:47:00</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:47:00</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>12<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake构建项目.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake构建项目.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake构建项目.html" class="internal-link" target="_self" rel="noopener nofollow">CMake构建项目</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>13<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake概述.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake概述.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake概述.html" class="internal-link" target="_self" rel="noopener nofollow">CMake概述</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-12-02" data-href="2024-12-02" href="2024-12-02" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-12-02 00:23:07</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-12-02" data-href="2024-12-02" href="2024-12-02" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-12-02 00:23:07</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>14<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake流程控制.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake流程控制.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake流程控制.html" class="internal-link" target="_self" rel="noopener nofollow">CMake流程控制</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>15<a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake的使用.md" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake的使用.md" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake的使用.html" class="internal-link" target="_self" rel="noopener nofollow">CMake的使用</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a><a data-tooltip-position="top" aria-label="2024-10-27" data-href="2024-10-27" href="2024-10-27" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">2024-10-27 11:46:58</a><a class="internal-link database-plugin__embed-link" href="1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html" aria-label="嵌入式软件开发-交叉编译-2p" target="_self"></a>CMake+123]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\嵌入式软件开发-交叉编译-2p.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/嵌入式软件开发-交叉编译-2p.md</guid><pubDate>Tue, 03 Dec 2024 06:43:29 GMT</pubDate></item><item><title><![CDATA[手把手教你配置，VSCode+EIDE开发STM32]]></title><description><![CDATA[ 
 <br><br>Visual Studio Code&nbsp;是一款免费的<a data-tooltip-position="top" aria-label="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/16273015?fromModule=lemma_inlink" rel="noopener nofollow" class="external-link" title="源代码编辑器" href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/16273015?fromModule=lemma_inlink" target="_blank">源代码编辑器</a>，并且可用于<a data-tooltip-position="top" aria-label="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink" rel="noopener nofollow" class="external-link" title="Windows" href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink" target="_blank">Windows</a>，<a data-tooltip-position="top" aria-label="https://baike.baidu.com/item/macOS/8654551?fromModule=lemma_inlink" rel="noopener nofollow" class="external-link" title="macOS" href="https://baike.baidu.com/item/macOS/8654551?fromModule=lemma_inlink" target="_blank">macOS</a>和<a data-tooltip-position="top" aria-label="https://baike.baidu.com/item/Linux/27050?fromModule=lemma_inlink" rel="noopener nofollow" class="external-link" title="Linux" href="https://baike.baidu.com/item/Linux/27050?fromModule=lemma_inlink" target="_blank">Linux</a>。它可以 几乎所有的编程语言的开发，比如C、C++、C#、Python、Java、HTML、VHDL、Verilog HDL等等。<br><img alt="x8f6e" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/x8f6e.png" referrerpolicy="no-referrer"><br>与&nbsp;Keil MDK&nbsp;对比，强大之处在于语法高亮，代码补全，括号匹配、一键生成代码模板、可定制的热键绑定等。<br>EIDE简介<br>关于EIDE插件，这里不做过多介绍，我们只需学会如何使用它。<br><img alt="yh47y" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/yh47y.png" referrerpolicy="no-referrer"><br><br><img alt="s11av" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/s11av.png" referrerpolicy="no-referrer"><br><img alt="4bnem" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/4bnem.png" referrerpolicy="no-referrer"><br>其中安装EIDE时，VSCode右下角可能会跳出一个窗口显示正在安装Microsoft.NET Runtime...我们等待其安装完成即可。<br><img alt="c33ct" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/c33ct.png" referrerpolicy="no-referrer"><br>然后回到VSCode<br><img alt="e75vs" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/e75vs.png" referrerpolicy="no-referrer"><br>然后回到EIDE插件，点击安装实用工具<br><img alt="67vx9" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/67vx9.png" referrerpolicy="no-referrer"><br>这里打勾的都要安装，总共4个<br><img alt="teri7" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/teri7.png" referrerpolicy="no-referrer"><br><img alt="2gh1g" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/2gh1g.png" referrerpolicy="no-referrer"><br><img alt="djsb7" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/djsb7.png" referrerpolicy="no-referrer"><br><img alt="609g9" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/609g9.png" referrerpolicy="no-referrer"><br>然后我们就可以导入项目或者新建工程。<br><br><img alt="kd7ec" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/kd7ec.png" referrerpolicy="no-referrer"><br><img alt="pllsg" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/pllsg.png" referrerpolicy="no-referrer"><br><img alt="j0c0y" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/j0c0y.png" referrerpolicy="no-referrer"><br><img alt="mt514" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/mt514.png" referrerpolicy="no-referrer"><br><img alt="mkd89" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/mkd89.png" referrerpolicy="no-referrer"><br><img alt="io0fu" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/io0fu.png" referrerpolicy="no-referrer"><br><img alt="at1hk" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/at1hk.png" referrerpolicy="no-referrer"><br><img alt="4sgf4" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/4sgf4.png" referrerpolicy="no-referrer"><br>然后我们就可以开始愉快地写代码啦！<br><br>右键项目生成调试器配置模板, 使用OpenOcd进行调试<br><img alt="Pasted image 20241129171611" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/Pasted%2520image%252020241129171611.png" referrerpolicy="no-referrer"><br>具体调试方法可以参考 <a data-tooltip-position="top" aria-label="1_Projects/嵌入式软件开发-交叉编译-2p/VSCode-GDB-J-Link-单片机程序调试实践" data-href="1_Projects/嵌入式软件开发-交叉编译-2p/VSCode-GDB-J-Link-单片机程序调试实践" href="1_Projects\嵌入式软件开发-交叉编译-2p\VSCode-GDB-J-Link-单片机程序调试实践.html" class="internal-link" target="_self" rel="noopener nofollow">VSCode-GDB-J-Link-单片机程序调试实践</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\手把手教你配置，VSCode+EIDE开发STM32.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/手把手教你配置，VSCode+EIDE开发STM32.md</guid><pubDate>Sun, 01 Dec 2024 11:38:42 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/x8f6e.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/x8f6e.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[用VS Code开发STM32——增加SEGGER RTT日志输出支持]]></title><description><![CDATA[ 
 <br>之前的教程都是使用OpenOCD作为GDB Server，好处是支持各种不同的调试器。但如果你仅使用Jink，不用其他的调试器，那么显然用Jlink自己的GDB Server是更加合适的。<br>SEGGER为jlink提供了各种工具，例如J-Scope，RTT(Real Time Transfer)等。今天的内容就是把RTT Client嵌入到VS Code中。<br>最终效果：只插一个Jlink，使用SWD接口，无需占用串口，无需SWO引脚，实现日志printf输出（带颜色）如下：<br><img alt="v2-9b0b999a77d7258a9472f08ae70788a5_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-9b0b999a77d7258a9472f08ae70788a5_1440w.jpg" referrerpolicy="no-referrer"><br><br>虽然利用断点、调用堆栈和变量窗口能很方便地进行调试，但是在一些情况下，是不允许打断点的，例如无人机、蓝牙/WiFi协议栈等。一旦程序暂停，就会造成连接断开、坠机等事故。因此，日志的输出也是很重要的调试手段，它不仅能够输出数据、还能够给我们提供程序跳转的信息。<br><br>
<br>串口输出
<br>在刚开始学习STM32时，有些教程会教你把fputc函数映射到串口输出上，这样就可以使用printf函数从串口输出日志了。但是这样要占用一个串口资源、而且映射的串口发送函数是阻塞的，如果波特率太低或者发送数据太多，就会导致你的程序卡顿。<br>
<br>半主机
<br>另一种日志输出方案是半主机（Semihosting），它是ARM调试的一种机制，利用软件中断，让嵌入式设备在调试时使用调试主机（PC）的显示器和键盘进行标准输入和输出。这样的好处是省一个串口，坏处是速度太慢，大概10ms才能出一个字符......<br>
<br>SWO
<br>Cortex-M3/M4内核的调试组件中有一个专用的模块——仪器化跟踪单元（ITM），它的作用就是输出调试信息。利用JTAG的SWO引脚可以进行输出，速度比较快。缺点是要占用一个SWO引脚，现在很多买的调试器都是SWD接口，只有SWDIO和SWCLK引脚了，带SWO的要么贵、要么太大看着笨重。<br>
<br>SEGGER RTT
<br>SEGGER RTT (Real-Time Transfer)结合了以上所有方法的优点：无需额外引脚、无需占用外设、只需要SWD引脚就可以输出日志，并且速度快，不影响应用程序的实时性。<br>想想只用插一个Jlink就可以同时断点调试+输出日志，还是很爽的。<br><br>为了使用RTT，我们需要先安装jlink驱动全家桶，这里给出网址：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//www.segger.com/downloads/jlink/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//www.segger.com/downloads/jlink/" target="_blank">https://www.segger.com/downloads/jlink/</a><br><img alt="v2-cfb52719a770cf5ada12ab6ff835de51_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-cfb52719a770cf5ada12ab6ff835de51_1440w.jpg" referrerpolicy="no-referrer"><br>找到这个jlink大礼包，点击Click for downloads，选择你的平台（windows,linux,osx）。下载完后安装即可。<br>【注】如果你看了第一篇文章：<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/61519415" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/61519415" target="_blank">《用VS Code开发STM32（一）——软件安装》</a>，安装了Zadig并且修改了jlink驱动，建议直接在设备管理器里面卸载这个修改过的驱动，然后再安装jlink大礼包。<br>安装完毕后你的电脑里会多出一堆工具：<br><img alt="v2-3fe374e3f63d9c7e43c2edcf450358f8_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-3fe374e3f63d9c7e43c2edcf450358f8_1440w.jpg" referrerpolicy="no-referrer"><br>然后，把这些工具的路径加入到“Path”环境变量中：<br>
如果使用stlink，那么环境变量也不用配置，只需要复制RTT源码即可
<br><img alt="v2-ecb872381234ca8957a0b2c697a3d211_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-ecb872381234ca8957a0b2c697a3d211_1440w.jpg" referrerpolicy="no-referrer"><br>Path环境变量<br><br>在C:\Program Files (x86)\SEGGER\JLink\Samples\RTT路径中，有一个Jlink RTT例程源码压缩包，我们把它复制到桌面再解压。<br>然后把压缩包里的整个RTT文件夹复制到你的STM32工程中：<br><img alt="v2-069f57e6912c0a8705fc5af46c690313_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-069f57e6912c0a8705fc5af46c690313_1440w.jpg" referrerpolicy="no-referrer"><br>压缩包里的RTT文件夹<br><img alt="v2-1bcf17c79f823c0cd7f026e289b2614e_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-1bcf17c79f823c0cd7f026e289b2614e_1440w.jpg" referrerpolicy="no-referrer"><br>修改后的STM32工程<br>这里，User目录下的log.h是我自己写的，目的是方便日志输出，内容如下：<br>/*
 * Author: Jayant Tang
 * Email: jayant97@foxmail.com
 */

#ifndef _LOG_H_
#define _LOH_H_
#include "SEGGER_RTT.h"

#define LOG_DEBUG 1

#if LOG_DEBUG


#define LOG_PROTO(type,color,format,...)            \
        SEGGER_RTT_printf(0,"  %s%s"format"\r\n%s", \
                          color,                    \
                          type,                     \
                          ##__VA_ARGS__,            \
                          RTT_CTRL_RESET)

/* 清屏*/
#define LOG_CLEAR() SEGGER_RTT_WriteString(0, "  "RTT_CTRL_CLEAR)

/* 无颜色日志输出 */
#define LOG(format,...) LOG_PROTO("","",format,##__VA_ARGS__)

/* 有颜色格式日志输出 */
#define LOGI(format,...) LOG_PROTO("I: ", RTT_CTRL_TEXT_BRIGHT_GREEN , format, ##__VA_ARGS__)
#define LOGW(format,...) LOG_PROTO("W: ", RTT_CTRL_TEXT_BRIGHT_YELLOW, format, ##__VA_ARGS__)
#define LOGE(format,...) LOG_PROTO("E: ", RTT_CTRL_TEXT_BRIGHT_RED   , format, ##__VA_ARGS__)

#else
#define LOG_CLEAR()
#define LOG
#define LOGI
#define LOGW
#define LOGE

#endif

#endif // !_LOG_H_
<br><br>
<br>在main.c&nbsp;的main函数while(1)循环附近，添加相关测试代码：
<br><img alt="v2-c808f1e4f995e15817e9aaab06899124_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-c808f1e4f995e15817e9aaab06899124_1440w.jpg" referrerpolicy="no-referrer"><br>
<br>修改Makefile，添加头文件路径和源文件：
<br><img alt="v2-12a1f7afba5e13a22e97aece22f6cd4c_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-12a1f7afba5e13a22e97aece22f6cd4c_1440w.jpg" referrerpolicy="no-referrer"><br>头文件包含路径，以-I开头，路径和&amp;quot;&amp;amp;quot;之间至少要有一个空格<br><img alt="v2-d2ab83861cfb4e38e04d6439254adceb_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-d2ab83861cfb4e38e04d6439254adceb_1440w.jpg" referrerpolicy="no-referrer"><br>源文件路径，路径和&amp;quot;&amp;amp;quot;之间至少要有一个空格<br>
<br>修改c_cpp_properties.json&nbsp;:
<br><img alt="v2-b0d3b2789945910a0e1c47742d86efe5_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b0d3b2789945910a0e1c47742d86efe5_1440w.jpg" referrerpolicy="no-referrer"><br><br>之前的教程是openOCD的，这里改回Jlink GDB Server：<br>{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        
        {
            "name": "Cortex Debug",
            "cwd": "${workspaceRoot}",
            "executable": "${workspaceRoot}/build/${workspaceFolderBasename}.elf",
            "request":"launch",
            "type":"cortex-debug",
            "device":"STM32F407VE",        //使用J-link GDB Server时必须有；其他GBD Server时可选（有可能帮助自动选择SVD文件）。支持的设备见 https://www.segger.com/downloads/supported-devices.php
            "svdFile": "./STM32F407.svd",  //svd文件，有这个文件才能查看寄存器的值，每个单片机都不同。可以在以下地址找到 https://github.com/posborne/cmsis-svd
            "servertype": "jlink",         //使用的GDB Server
            "configFiles": [                  
              //  "${workspaceRoot}/openocd.cfg"
            ],
            "preLaunchTask": "build"
        }
    ]
}
<br>【注】如果你使用了RTOS，需要加一个"rtos"属性，例如"rtos":"FreeRTOS"<br><br><img alt="v2-11f79a04a61438c2350347c732ec5ada_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-11f79a04a61438c2350347c732ec5ada_1440w.jpg" referrerpolicy="no-referrer"><br>保存后，插好jlink，按下Ctrl+P，输入task[空格]rtt，即可启动RTT Client。<br><img alt="v2-a39527985c1c8ae564d70296a9f10b33_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-a39527985c1c8ae564d70296a9f10b33_1440w.jpg" referrerpolicy="no-referrer"><br>【注】你也可以给rtt任务绑定一个快捷键，具体方法这里不赘述了。<br><br>按F5进入调试模式，然后运行。终端中出现了带颜色的log日志：<br><img alt="v2-9b0b999a77d7258a9472f08ae70788a5_1440w" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/gajwx97xgt5.jpg" referrerpolicy="no-referrer"><br>log.h中的宏：<br>LOGI是输出information，绿色；<br>LOGE是输出error，红色；<br>LOGW是输出warning，黄色；<br>LOG没有颜色；<br>所有LOG函数都自带回车，不用加\r\n。<br>【注】：带颜色的日志是用了linux终端颜色代码，你直接从开始菜单打开RTT Client这个程序是看不到颜色，而只能看到颜色代码的。但是因为RTT Client在git bash这个linux shell终端中运行，所以就有颜色啦。<br>RTT Viewer是更高级的查看器，可以从开始菜单打开，自动支持颜色。<br>祝你调试顺利！好用的话别忘了点赞哦！<br><br>系列文章：<br>
<br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/61519415" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/61519415" target="_blank">用VS Code开发STM32（一）——软件安装</a>
<br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/61538230" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/61538230" target="_blank">用VSCode开发STM32（二）——编译</a>
<br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/61541590" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/61541590" target="_blank">用VS Code开发STM32（三）——调试</a>
<br>发布于 2020-07-26 14:08]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\用VS Code开发STM32——增加SEGGER RTT日志输出支持.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/用VS Code开发STM32——增加SEGGER RTT日志输出支持.md</guid><pubDate>Sun, 01 Dec 2024 11:44:09 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-9b0b999a77d7258a9472f08ae70788a5_1440w.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-9b0b999a77d7258a9472f08ae70788a5_1440w.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CMake 保姆级教程（上）]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://subingwen.cn/cmake/CMake-primer/" rel="noopener nofollow" class="external-link" href="https://subingwen.cn/cmake/CMake-primer/" target="_blank">CMake 保姆级教程（上） | 爱编程的大丙 (subingwen.cn)</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake概述" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake概述.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake概述</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake的使用" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake的使用.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake的使用</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMakeLists.txt 文件编写示例" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMakeLists.txt 文件编写示例.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMakeLists.txt 文件编写示例</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake命令执行和项目构建" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake命令执行和项目构建.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake命令执行和项目构建</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件制作" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件制作.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件制作</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件输出路径设置" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件输出路径设置.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件输出路径设置</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件链接" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的库文件链接.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的库文件链接</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的日志和变量操作" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的日志和变量操作.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的日志和变量操作</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的宏定义" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake中的宏定义.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake中的宏定义</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\CMake 保姆级教程（上）.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（上）.md</guid><pubDate>Sun, 01 Dec 2024 11:38:42 GMT</pubDate></item><item><title><![CDATA[CMake 保姆级教程（下）]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://subingwen.cn/cmake/CMake-advanced/#1-%E5%B5%8C%E5%A5%97%E7%9A%84CMake" rel="noopener nofollow" class="external-link" href="https://subingwen.cn/cmake/CMake-advanced/#1-%E5%B5%8C%E5%A5%97%E7%9A%84CMake" target="_blank">CMake 保姆级教程（下） | 爱编程的大丙 (subingwen.cn)</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/嵌套的CMake" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\嵌套的CMake.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/嵌套的CMake</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake构建项目" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake构建项目.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake构建项目</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake流程控制" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake流程控制.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake流程控制</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake条件判断" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake条件判断.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake条件判断</a><br><a data-href="1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake循环" href="1_Projects\嵌入式软件开发-交叉编译-2p\D\CMake循环.html" class="internal-link" target="_self" rel="noopener nofollow">1_Projects/嵌入式软件开发-交叉编译-2p/D/CMake循环</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\CMake 保姆级教程（下）.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/CMake 保姆级教程（下）.md</guid><pubDate>Sun, 01 Dec 2024 11:38:42 GMT</pubDate></item><item><title><![CDATA[GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建]]></title><description><![CDATA[<a class="tag" href="?query=tag:include" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#include</a> 
 <br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/576972892" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/576972892" target="_blank">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署21 赞同 · 6 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/621089837" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/621089837" target="_blank">GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建27 赞同 · 14 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/690964572" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/690964572" target="_blank">GCC + Vscode 搭建 STM32 开发环境（三）- 调试6 赞同 · 1 评论文章</a><br>Cmake 管理工程灵活性很高，且 Cmake 官方文档并没有提供一个完整的模板教用户如何去较好的组织一个项目。 结合工程实践，我整理出了一套自己的使用方法。在我的项目里面，一共有三类 Cmake 文件：<br>
<br>公共的 *.cmake，这部分主要提供了编译器及其参数、处理器等信息的描述；
<br>模块的 CmakeList.txt，用来描述项目里会引用不同的模块（自己创建的或应用第三方的库）；
<br>工程的 CmakeList.txt，该文件指定了具体的编译规则，并最终生成可执行文件；这个文件会引用 1、2 两个文件；
<br>这部分的文件后缀是 cmake，主要提供在使用 Cmake 管理工程时的共用部分。<br><img alt="https://pica.zhimg.com/80/v2-4b03ac9070e6e92929fb3936d3100a7e_720w.webp" src="https://pica.zhimg.com/80/v2-4b03ac9070e6e92929fb3936d3100a7e_720w.webp" referrerpolicy="no-referrer"><br>这里面包含了两类文件：编译器说明文件和内核说明文件。<br><br>这个文件说明了在编译工程时使用的编译套件以及编译参数，具体可阅读代码的注释。<br>代码清单：arm-none-eabi.cmake<br># 编译工具链；
# 请确保已经添加到环境变量；
# 如果使用的是 linux 环境，需要将后面的 '.exe' 移除；
SET(CMAKE_C_COMPILER "arm-none-eabi-gcc.exe")
SET(CMAKE_CXX_COMPILER "arm-none-eabi-g++.exe")
SET(AS "arm-none-eabi-as.exe")
SET(AR "arm-none-eabi-ar.exe")
SET(OBJCOPY "arm-none-eabi-objcopy.exe")
SET(OBJDUMP "arm-none-eabi-objdump.exe")
SET(SIZE "arm-none-eabi-size.exe")

# 使用的 C 语言版本；
SET(CMAKE_C_STANDARD 99)
# 使用的 cpp 版本；
SET(CMAKE_CXX_STANDARD 17)
# 生成 compile_commands.json，可配合 clangd 实现精准的代码关联与跳转；
SET(CMAKE_EXPORT_COMPILE_COMMANDS True)
# 彩色日志输出；
SET(CMAKE_COLOR_DIAGNOSTICS True)

# 路径查找；
SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

# this makes the test compiles use static library option so that we don't need to pre-set linker flags and scripts
SET(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

# 包含gcc头文件路径
SET(SYSTEM_PATH "-isystem C:/~Arm_Development_Toolchains/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include")

# 定义通用编译器参数；
# ${MCPU_FLAGS}   处理器内核信息
# ${VFP_FLAGS}    浮点运算单元类型
# ${SYSTEM_PATH}  编译器头文件路径
SET(CFCOMMON
    "${MCPU_FLAGS} ${VFP_FLAGS} ${SYSTEM_PATH} --specs=nano.specs -specs=rdimon.specs --specs=nosys.specs -Wall -fmessage-length=0 -ffunction-sections -fdata-sections"
)

# 定义最快运行速度发行模式的编译参数；
SET(CMAKE_C_FLAGS_RELEASE "-Os  ${CFCOMMON}")
SET(CMAKE_CXX_FLAGS_RELEASE "-Os  ${CFCOMMON} -fno-exceptions")
SET(CMAKE_ASM_FLAGS_RELEASE "${MCPU_FLAGS} ${VFP_FLAGS} -x assembler-with-cpp")

# 定义最小尺寸且包含调试信息的编译参数；
SET(CMAKE_C_FLAGS_RELWITHDEBINFO "-Os -g  ${CFCOMMON}")
SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-Os -g  ${CFCOMMON} -fno-exceptions")
SET(CMAKE_ASM_FLAGS_RELWITHDEBINFO "${MCPU_FLAGS} ${VFP_FLAGS} -x assembler-with-cpp")

# 定义最小尺寸的编译参数；
SET(CMAKE_C_FLAGS_MINSIZEREL "-Os  ${CFCOMMON}")
SET(CMAKE_CXX_FLAGS_MINSIZEREL "-Os  ${CFCOMMON} -fno-exceptions")
SET(CMAKE_ASM_FLAGS_MINSIZEREL "${MCPU_FLAGS} ${VFP_FLAGS} -x assembler-with-cpp")

# 定义调试模式编译参数；
SET(CMAKE_C_FLAGS_DEBUG "-O0 -g  ${CFCOMMON}")
SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g  ${CFCOMMON} -fno-exceptions")
SET(CMAKE_ASM_FLAGS_DEBUG "${MCPU_FLAGS} ${VFP_FLAGS} -x assembler-with-cpp")

IF("${CMAKE_BUILD_TYPE}" STREQUAL "Release")
  MESSAGE(STATUS "**** Maximum optimization for speed ****")
ELSEIF("${CMAKE_BUILD_TYPE}" STREQUAL "RelWithDebInfo")
  MESSAGE(STATUS "**** Maximum optimization for size, debug info included ****")
ELSEIF("${CMAKE_BUILD_TYPE}" STREQUAL "MinSizeRel")
  MESSAGE(STATUS "**** Maximum optimization for size ****")
ELSE() # "Debug"
  MESSAGE(STATUS "**** No optimization, debug info included ****")
ENDIF()
<br><br>该文件描述了当前工程使用的处理器的内核信息，如内核版本、指令集类型、浮点运算单元类型等等。<br>代码清单：cortex_m4.cmake<br>SET(CMAKE_SYSTEM_NAME Generic)
SET(CMAKE_SYSTEM_PROCESSOR cortex-m4)
SET(THREADX_ARCH "cortex_m4")
SET(THREADX_TOOLCHAIN "gnu")
ADD_DEFINITIONS(-DARM_MATH_CM4 -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -D__FPU_PRESENT=1)
SET(MCPU_FLAGS "-mthumb -mcpu=cortex-m4")
SET(VFP_FLAGS "-mfloat-abi=soft")
MESSAGE(STATUS "**** Platform: ${MCPU_FLAGS} ${VFP_FLAGS} ****")
INCLUDE(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi.cmake)
<br>代码清单：cortex_m0.cmake<br>SET(CMAKE_SYSTEM_NAME Generic)
SET(CMAKE_SYSTEM_PROCESSOR cortex-m0)
SET(THREADX_ARCH "cortex_m0")
SET(THREADX_TOOLCHAIN "gnu")
SET(MCPU_FLAGS "-mcpu=cortex-m0 -mthumb")
SET(VFP_FLAGS "")
MESSAGE(STATUS "**** Platform: ${MCPU_FLAGS} ${VFP_FLAGS} ${FLOAT_ABI} ****")
INCLUDE(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi.cmake)
<br>其他内核的写法依葫芦画瓢就可以了。<br>值得注意的是 INCLUDE(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi.cmake) 这句话，这里是引用了第 1.1 小节提到的编译器描述文件。这有点类似 c 语言的 <a href=".?query=tag:include" class="tag" target="_blank" rel="noopener nofollow">#include</a> “xxxxx.h”。<br>而工程的 Cmake 文件又会引用处理器的描述文件。通过这种层层引用的操作，会把构建的必要参数传递给构建过程。<br><br>模块的 CmakeList.txt 用来组织功能模块的编译规则。这里以一个 LED 指示灯的驱动模块为例说明。 模块文件夹内容如图。<br><img alt="https://pic2.zhimg.com/80/v2-8ac13df3874a013db992ade4b076ce29_720w.webp" src="https://pic2.zhimg.com/80/v2-8ac13df3874a013db992ade4b076ce29_720w.webp" referrerpolicy="no-referrer"><br>drv_led.c 和 drv_led.h 为具体的源代码，这里不展开。CmakeLists.txt 就是该模块的规则描述文件了，文件内容及说明如下。<br>代码清单：CmakeLists.txt<br># 要连接到构建目标的源文件；
TARGET_SOURCES(
  ${PROJECT_NAME}
  PRIVATE # {{BEGIN_TARGET_SOURCES}}
          ${CMAKE_CURRENT_LIST_DIR}/drv_led.c
          # {{END_TARGET_SOURCES}}
)

# 将模块头文件路径添加到目标；
TARGET_INCLUDE_DIRECTORIES(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_LIST_DIR})
<br>其中提到的 构建目标 是由工程的 CmakeLists.txt 指定的，在这里我们使用变量替代，在构建过程中会用实际的目标名称替换该变量。 在组织工程的时候，将需要的模块的子目录添加到工程的 CmakeLists.txt 中便可以完成对该模块的调用。这类似于 Keil 或 IAR 中工程右键添加文件或目录，只不过他们在后台帮你完成了构建脚本的修改。<br><br>工程的 CmakeList.txt 是整个项目的编译入口，主要： - 指定工程名称（构建目标名称）； - 构建规则声明； - 依赖管理； - 预定义宏； - ....<br>代码清单：CmakeList.txt<br># ######################################################################################################################
# 0、硬件平台信息与编译器信息；
# ######################################################################################################################

SET(PATH_WORKSPACE_ROOT ${CMAKE_SOURCE_DIR}/../../..)

INCLUDE("${PATH_WORKSPACE_ROOT}/components/toolchain/cmake/cortex_m4f.cmake")

# ######################################################################################################################
# 1、工程信息
# ######################################################################################################################

# 设置CMAKE最低版本
CMAKE_MINIMUM_REQUIRED(VERSION 3.20)

# 设置当前的工程名称
PROJECT(
  demo
  VERSION 0.0.1
  LANGUAGES C CXX ASM)
MESSAGE(STATUS "**** Building project: ${CMAKE_PROJECT_NAME}, Version: ${CMAKE_PROJECT_VERSION} ****")

# 指定链接文件；
SET(LINKER_SCRIPT ${CMAKE_SOURCE_DIR}/stm32f429bit_flash.ld)

# 指定启动文件；
SET(STARTUP_ASM ${PATH_WORKSPACE_ROOT}/components/cmsis/Device/ST/STM32F4xx/Source/Templates/gcc/startup_stm32f429xx.S)

# 项目底层公共头文件；
INCLUDE_DIRECTORIES(${PATH_WORKSPACE_ROOT}/include)

# ######################################################################################################################
# 2、编译控制；
# ######################################################################################################################

# 是否开启更详细的编译过程信息显示
SET(CMAKE_VERBOSE_MAKEFILE OFF)

# ######################################################################################################################
# 3、预定义宏；
# ######################################################################################################################

# 平台相关宏定义
ADD_DEFINITIONS(
  -DUSE_STDPERIPH_DRIVER
  -DSTM32
  -DSTM32F429_439xx
  -DHSE_VALUE=8000000
  -DCMAKE_DEMO
  -DUSING_NON_RTOS=0 # 不使用 RTOS
  -DUSING_FREERTOS=1 # 使用 FreeRTOS
  -DUSING_THREADX=2 # 使用 Threadx
  -DUSING_RTOS=USING_NON_RTOS # 选择使用的 RTOS
)

# ######################################################################################################################
# 4、差异化构建配置；
# ######################################################################################################################

OPTION(OPEN_LOG_OMN_DEBUG "Open log output for debug" OFF)

# 修改该变量的值，可以修改输出文件的名称；
SET(OUTPUT_EXE_NAME "demo")

# 优化级别的差异配置
# ######################################################################################################################
IF("${CMAKE_BUILD_TYPE}" STREQUAL "Release")
  ADD_DEFINITIONS()
ELSEIF("${CMAKE_BUILD_TYPE}" STREQUAL "RelWithDebInfo")
  ADD_DEFINITIONS()
ELSEIF("${CMAKE_BUILD_TYPE}" STREQUAL "MinSizeRel")
  ADD_DEFINITIONS()
ELSE()
  IF(OPEN_LOG_OMN_DEBUG)
    ADD_DEFINITIONS(-DLOG_BACKEND=LOG_BACKEND_NONE)
  ELSE()
    ADD_DEFINITIONS(-DLOG_BACKEND=LOG_BACKEND_NONE)
  ENDIF()
ENDIF()

MESSAGE(STATUS "**** Build for ${CMAKE_BUILD_TYPE} ****")

# ######################################################################################################################
# 5、设置文件输出路径；
# ######################################################################################################################

# 设置库输出路径
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib_obj)

SET(ELF_FILE ${PROJECT_BINARY_DIR}/${OUTPUT_EXE_NAME}.elf)
SET(HEX_FILE ${PROJECT_BINARY_DIR}/${OUTPUT_EXE_NAME}.hex)
SET(BIN_FILE ${PROJECT_BINARY_DIR}/${OUTPUT_EXE_NAME}.bin)

# ######################################################################################################################
# 6、组织公共库源文件；
# ######################################################################################################################

# ######################################################################################################################
# 7、组织用户源文件；
# ######################################################################################################################

# 用户源码；
# ######################################################################################################################
INCLUDE_DIRECTORIES(
  # 应用层头文件包含路径；
  ${PATH_WORKSPACE_ROOT}/projects/demo/source/applications ${PATH_WORKSPACE_ROOT}/projects/demo/source/config/board
  # 硬件驱动头文件路径；
  ${PATH_WORKSPACE_ROOT}/common_src/drivers/internal_driver ${PATH_WORKSPACE_ROOT}/common_src/drivers/module_driver)

SET(USER_SOURCE
    ${PATH_WORKSPACE_ROOT}/projects/demo/source/applications/stm32f4xx_it.c
    ${PATH_WORKSPACE_ROOT}/projects/demo/source/config/board/system_stm32f4xx.c
    ${PATH_WORKSPACE_ROOT}/projects/demo/source/main.c)

# ######################################################################################################################
# 8、编译、连接，生成可执行文件
# ######################################################################################################################

# 定义连接器参数； --gc-sections：指示链接器去掉不用的 section
SET(CMAKE_EXE_LINKER_FLAGS
    "${CMAKE_EXE_LINKER_FLAGS} -T ${LINKER_SCRIPT} -Wl,-Map=${PROJECT_BINARY_DIR}/${OUTPUT_EXE_NAME}.map -Wl,--gc-sections,--print-memory-usage"
)

# 生成可执行文件
ADD_EXECUTABLE(${PROJECT_NAME} ${COMMON_SERVICES_SOURCE} ${USER_SOURCE} ${LINKER_SCRIPT} ${STARTUP_ASM})

# 添加依赖；

SET(PATH_COMPONENTS ${PATH_WORKSPACE_ROOT}/components)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/cmsis/ ${LIBRARY_OUTPUT_PATH}/cmsis)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/soc_std_driver/stm32f4xx ${LIBRARY_OUTPUT_PATH}/soc_std_driver/stm32f4xx)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/bsp/stm32/ ${LIBRARY_OUTPUT_PATH}/bsp/stm32/)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/driver/led ${LIBRARY_OUTPUT_PATH}/led)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/libraries/fifo/ ${LIBRARY_OUTPUT_PATH}/fifo)
ADD_SUBDIRECTORY(${PATH_COMPONENTS}/libraries/link_list/ ${LIBRARY_OUTPUT_PATH}/link_list)

# ######################################################################################################################
# 9、生成 hex 和 bin 文件
# ######################################################################################################################

ADD_CUSTOM_COMMAND(
  TARGET "${PROJECT_NAME}"
  POST_BUILD
  # Build .hex and .bin files
  COMMAND ${OBJCOPY} -Obinary "${PROJECT_NAME}" "${OUTPUT_EXE_NAME}.bin"
  COMMAND ${OBJCOPY} -Oihex "${PROJECT_NAME}" "${OUTPUT_EXE_NAME}.hex"
  COMMENT "Building ${OUTPUT_EXE_NAME}.bin and ${OUTPUT_EXE_NAME}.hex"
  # Display sizes
  COMMAND ${SIZE} --format=berkeley ${PROJECT_NAME}
  COMMENT "Invoking: Cross ARM GNU Print Size")
<br><br>我通常习惯在 VScode 的工作空间放置两个目录， 具体看下图：<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2677eaae-d464-4f07-b1fe-9de715174bce/49cafb34-d22b-4dff-a972-9707216eff79/image.png" referrerpolicy="no-referrer" style="width: 1103px; max-width: 100%;"><br>第 1 个目录是工程的目录，这样可以快速的查看工程的信息。<br>通常我的一个项目里面可能存在多个工程，而这些工程会引用一些公共过的库文件，所以这些文件会放置在项目的公共目录里面，如 components 目录。<br>那么这个时候，我会把整个项目的目录添加到工作空间，这样我就可以方便的查阅公共模块的代码或其他文件了。你会发现，在上述截图中的第二个目录会包含第一个目录的全部内容。<br>这只是我的习惯，你可以按照实际情况酢情处理。<br><br>到此为止，我们可以开始启动构建，并得到最终的二进制文件了。<br><br>展开 demo/.vscode 目录，创建 task,json 文件，这个文件会定义具体的生成与构建任务。<br>代码清单：tasks.json<br>{
   "version": "2.0.0",
   "tasks": [
      { /// 如果你使用的是 J-link 调试，并配置了 RTT 打印，那么开启该任务可以在终端打印 RTT 日志；
         "label": "0. Segger-RTT", 
         "type": "shell",
         "command": "C:/'Program Files (x86)'/SEGGER/JLink/JLinkRTTClient.exe",
         "args": [],
         "problemMatcher": [],
         "group": {
            "kind": "build",
            "isDefault": true
         }
      },
      { /// 执行该任务，你可以生成构建脚本，我这里使用的是 Ninja;
         "label": "1. Reload Cmake Project (Orion675FS)",
         "type": "shell",
         "command": "clear ; Remove-Item -Recurse ./build ; mkdir ./build ; cd ./build ; cmake -G \\"Ninja\\" -DOPEN_LOG_OMN_DEBUG=ON -DCMAKE_BUILD_TYPE=Debug ..",
         "options": {
            "cwd": "${workspaceFolder}/gcc/"
         },
         "group": {
            "kind": "build",
            "isDefault": true
         }
      },
      { /// 执行该任务，你可以执行编译，并得到可用的二进制文件；
         "label": "2. Build (Debug)",
         "type": "shell",
         "command": "clear ; cd ./build ; cmake -G \\"Ninja\\" -DOPEN_LOG_OMN_DEBUG=ON .. ; ninja -j8",
         "options": {
            "cwd": "${workspaceFolder}/gcc/"
         },
         "group": {
            "kind": "build",
            "isDefault": true
         },
      }
   ]
}
<br>该文件中具体的每个参数的含义这里不解释，具体的命令的含义在命令行编译的方式里面会有详细的说明。<br>创建好文件后，在 VScode 中使用快捷键 ctrl + shift + B，可以调出上述任务，点击对应的任务就可以执行了。<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2677eaae-d464-4f07-b1fe-9de715174bce/ca692ccc-9765-4a23-9a8b-059c20916bab/image.png" referrerpolicy="no-referrer"><br>当然，你也可以通过菜单栏 Terminal / Run Task 打开相同的界面。<br><br>在 gcc 目录上右键，在弹出的菜单中点击 Open in Integrated Terminal，会打开一个终端。 在终端输入命令：<br>mkdir build &amp;&amp; cd build
<br>创建构建的过程文件以及最终输出文件的存放路径，你可以取其他名称。<br>当然了，你也可以直接在 gcc 目录启动构建，但是你的目录可能变得乱七八糟。 执行完该命令后，会进入该目录。<br>在终端输入如下命令，生成构建脚本，这里以 Ninja 为例。<br>cmake -G "Ninja" -DOPEN_LOG_OMN_DEBUG=ON -DCMAKE_BUILD_TYPE=Debug ..
<br>命令内容解释：<br>
<br>cmake -G "Ninja" 生成适用于 ninja 的构建脚本；如果需要其他的，请在终端输入 cmake -G -help 查阅帮助。
<br>-DOPEN_LOG_OMN_DEBUG=ON，传递一个开关宏的值，通常我们可以在 cmake 文件中定义一些开关宏，在生成的时候指定这些宏的值，这可以方便的实现差异化构建。
<br>-DCMAKE_BUILD_TYPE=Debug 告诉 cmake 在生成构建脚本时的优化类型，可选 Debug、MinSizeRel、RelWithDebInfo、Release。
<br>目前，我们已经完成了构建脚本的生成，接下来可以启动构建了。<br>在终端输入如下命令，执行构建。<br>ninja -j8
<br>其中， -j8 是开启多线程编译，后面的数值表示使用的线程数。 编译输出的内容如下。<br>$  ninja -j8 
[51/51] Linking C executable demo
Memory region         Used Size  Region Size  %age Used
          CCMRAM:          0 GB        64 KB      0.00%
             RAM:        9264 B       192 KB      4.71%
           FLASH:        2340 B         2 MB      0.11%
          EXTRAM:          0 GB         1 MB      0.00%
   text    data     bss     dec     hex filename
   2316      24    9248   11588    2d44 demo
<br>build 目录的内容如图。<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2677eaae-d464-4f07-b1fe-9de715174bce/d5cfa944-a0d5-48cb-8aa8-298e0d6d3a04/image.png" referrerpolicy="no-referrer" style="width: 1103px; max-width: 100%;"><br><br>
<br>Cmake 和 tasks.json 可以有很灵活写法，文章只是写了我常用的形式，希望你可以在理解的基础上总结出适合自己的方式和方法；<br>

<br>上述方法对 clion 同样适用；<br>

<br>上述 Demo 的工程源码，你可以通过下面的命令获取。
git clone https://jihulab.com/liuy928/cmake_arm_gcc_demo.git


]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建.md</guid><pubDate>Sat, 30 Nov 2024 01:25:06 GMT</pubDate><enclosure url="https://pica.zhimg.com/80/v2-4b03ac9070e6e92929fb3936d3100a7e_720w.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://pica.zhimg.com/80/v2-4b03ac9070e6e92929fb3936d3100a7e_720w.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GCC + Vscode 搭建 STM32 开发环境（三）- 调试]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/576972892" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/576972892" target="_blank">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署21 赞同 · 6 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/621089837" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/621089837" target="_blank">GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建27 赞同 · 14 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/690964572" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/690964572" target="_blank">GCC + Vscode 搭建 STM32 开发环境（三）- 调试6 赞同 · 1 评论文章</a><br><br>通过上一篇文章，我们知道了构建的任务是通过 tasks.json 来管理的。这里我们要介绍的调试、运行等任务是由 launch.json 来管理的。 展开 demo/.vscode 目录，创建 launch.json 文件，在这个文件中定义通过不同的调试器进行调试的任务。依次是：<br>
<br>J-link
<br>OpenOCD
<br>创建 launch.json 后，在该文件的右下角有 Add Configuration... 按钮，点击后在弹出的菜单选择 Cortex Debug: Jink 可以得到如下内容。<br>代码清单：launch,json 的基本格式<br>{
   "configurations": [
      {
         "cwd": "${workspaceFolder}",
         "executable": "./bin/executable.elf",
         "name": "Debug with JLink",
         "request": "launch",
         "type": "cortex-debug",
         "device": "",
         "runToEntryPoint": "main",
         "showDevDebugOutput": "none",
         "servertype": "jlink"
      }
   ]
}
<br>在此基础上，可以修改得到不同的运行任务。<br><br>在使用 J-Link 调试前，你需要确保 J-Link 驱动被正确安装。 然后，在 VScode 的 settings.json 页面增加如下代码。关于如何打开 settings.json 请自行查阅 VScode 文档。<br>"cortex-debug.JLinkGDBServerPath": "C:/Program Files (x86)/SEGGER/JLink/JLinkGDBServerCL.exe",
<br>这句话会告诉 Cortex-Debug 插件 J-Link GDB server 的路径。<br>代码清单： 使用 J-link 调试的配置<br>{
   "version": "0.2.0",
   "configurations": [
      {
         "name": "CortexDebug-Jlink",
         "type": "cortex-debug",
         "request": "launch",
         "cwd": "${workspaceFolder}",
         "executable": "${workspaceFolder}/gcc/build/demo", /// 目标文件，是编译时生成的 elf 文件，在该 demo 中没有后缀；
         "device": "STM32F429BI", /// 器件型号；
         "runToEntryPoint": "main", /// 程序进入调试后的入口点，通常会停在这里；
         "showDevDebugOutput": "none", /// 选择调试输出的内容，阅读 cortex-debug 的文档可以获得进一步的信息；
         "servertype": "jlink",
         "svdPath": "${workspaceFolder}/../../components/toolchain/soc_svd/st/STM32F429.svd", /// 器件的寄存器描述文件，提供调试模式下寄存器的观察功能；
         "preLaunchTask": "2. Build (Debug)", /// 在进入运行前，执行的任务。这里是 task.json 里面的 build 任务。
      }
   ]
}
<br><br><br><br>第 2 节提到的使用 J-Link 调试，是直接使用的 J-Link Server。 OpenOCD 也是支持 J-link 调试的，但是它只会把 J-Jlink 当作普通的 USB 设备，如果直接使用 J-Link 的驱动回出现无法识别的问题。<br>这时，你可以通过一款叫 zadig 的软件替换驱动，但这会导致 J-Link 无法在 J-Flash 等软件正常使用。<br>基于这些原因，所以我一般不会使用 OpenOCD 配合 J-link 来进行调试，更多的是配合 ST-Link 或开源的调试器(如 CMSIS-DAP、DAP-Link等)。<br>代码清单： 使用 ST-link 调试的配置<br>{
   "version": "0.2.0",
   "configurations": [
      { /// 基于 OpenOCD 使用 ST-link 调试的任务；
         "name": "CortexDebug-STLink",
         "type": "cortex-debug", 
         "request": "launch",
         "cwd": "${workspaceFolder}",
         "runToEntryPoint": "main", /// 程序进入调试后的入口点，通常会停在这里；
         "executable": "${workspaceFolder}/gcc/build/demo", /// 目标文件，是编译时生成的 elf 文件，在该 demo 中没有后缀；
         "device": "STM32F429BIT6",
         "svdFile": "${workspaceFolder}/../../components/toolchain/soc_svd/st/STM32F429.svd", /// 器件的寄存器描述文件，提供调试模式下寄存器的观察功能；
         "preLaunchTask": "2. Build (Debug)", /// 调试前执行 build 任务；
         "servertype": "openocd", /// 使用 OpenOCD 调试
         "configFiles": [ /// 使用的 OpenOCD 调试脚本；
            "${workspaceFolder}/../../components/toolchain/openocd_scripts/openocd-stm32f4-stlink.cfg"
         ]
      }
   ]
}
<br><br><img alt="https://picx.zhimg.com/80/v2-ba7ee6c123a51947341c108c6844c733_720w.webp" src="https://picx.zhimg.com/80/v2-ba7ee6c123a51947341c108c6844c733_720w.webp" referrerpolicy="no-referrer"><br>在 VScode 左侧点击三角符号（有个 bug 小虫的），在弹出的侧边栏上方的下拉框选择你想要使用的调试方式，然后点击 F5 或鼠标点击下拉框左侧的三角形启动调试。<br><br>点击代码行数左侧，可以创建一个断点。在断点上点击鼠标右键，点击编辑断点，可以设置条件断点。<br>
<br>表达式满足；
<br>运行次数到达；
<br>打印一条消息；
<br>在侧边栏的 BREAKPOINTS 可以看到所有你创建的断点。<br><br>VScode 的调试界面是不支持 Live watch 的(新版的 Cortex-debug 插件已经提供了支持，阅读插件的文档可以获取具体的<a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95&amp;zhida_source=entity&amp;is_preview=1" target="_blank">配置方法</a>，此处不再展开)。<br>在左侧的 VARIABLES 窗口，你可以观察断点停止点的局部变量、全局变量、Static 变量、内核寄存器等。 在 WATCH 窗口，你可以输入你想观察的变量。<br><br>必须在 launch.json 中设置了 SVD 寄存器描述文件，你才可以在左侧的寄存器观察外设寄存器的状态。<br><br>ctrl + shift + p 打开 VScode 的命令窗口，输入 cortex 你可以打开下图所示的界面，点击其中的 View Memory。<br><img alt="https://pic2.zhimg.com/80/v2-fcbab7b789fdb09e7418aef2792578fb_720w.webp" src="https://pic2.zhimg.com/80/v2-fcbab7b789fdb09e7418aef2792578fb_720w.webp" referrerpolicy="no-referrer"><br><br>这三篇文章只是描述了通过 VScode 调试 STM32 的一种基本方法，很多细节并没有展开讲。如，<br>
<br>什么是 OpenOCD 脚本；如何编写目标编程器和处理器的脚本；
<br>如何通过 pyOCD 来进行调试；环境如何配置，包如何管理等；
<br>还有一些工具更进一步的用法
<br>这些都是值得写一篇文章来具体介绍的技术了。 另外，网络如此方便，你完全可以阅读对应工具的文档获取必要的信息。<br><br>
<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//openocd.org/pages/documentation.html" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//openocd.org/pages/documentation.html" target="_blank">Documentation (openocd.org)</a>
<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/cpp/launch-json-reference" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/cpp/launch-json-reference" target="_blank">Configure launch.json for C/C++ debugging in Visual Studio Code</a>
<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//pyocd.io/docs/index" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//pyocd.io/docs/index" target="_blank">Documentation — pyOCD</a>
<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/getstarted/settings%23%3A~%3Atext%3DIn%2520general%252C%2520VS%2520Code%2520extensions%2520store%2520their%2520settings%2Csettings.json%2520file%2520%2528%2520Preferences%253A%2520Open%2520Settings%2520%2528JSON%2529%2520%2529" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/getstarted/settings%23%3A~%3Atext%3DIn%2520general%252C%2520VS%2520Code%2520extensions%2520store%2520their%2520settings%2Csettings.json%2520file%2520%2528%2520Preferences%253A%2520Open%2520Settings%2520%2528JSON%2529%2520%2529" target="_blank">Visual Studio Code User and Workspace Settings</a>
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（三）- 调试.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（三）- 调试.md</guid><pubDate>Sun, 27 Oct 2024 03:13:33 GMT</pubDate><enclosure url="https://picx.zhimg.com/80/v2-ba7ee6c123a51947341c108c6844c733_720w.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://picx.zhimg.com/80/v2-ba7ee6c123a51947341c108c6844c733_720w.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/576972892" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/576972892" target="_blank">GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署21 赞同 · 6 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/621089837" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/621089837" target="_blank">GCC + Vscode 搭建 STM32 开发环境（二）- 使用Cmake管理与构建27 赞同 · 14 评论文章</a><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/690964572" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/690964572" target="_blank">GCC + Vscode 搭建 STM32 开发环境（三）- 调试6 赞同 · 1 评论文章</a><br>在开始使用 vscode 开发 STM32 之前，你需要按照如下步骤先安装和配置好必须的工具链。 本文所有的开发环境均使用 Windows11 x64，但是所有操作是 Windows10 适用的。对于如何安装软件、如何设置环境变量等，本系列文章不会展开讲解，你需要自行检索了解相关知识。<br><br>vscode 是微软发布的一款代码编辑器，注意仅仅是代码编辑器。但是，依托其丰富的插件市场，在安装必要的插件后可以实现特定开发领域 IDE 的功能。比如，替代 IAR 或 Keil 作为<a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&amp;zhida_source=entity&amp;is_preview=1" target="_blank">嵌入式开发</a>环境。<br>相对于 IAR 和 Keil，vscode 具有启动速度快、现代化的界面风格、强大的代码编辑功能、商业免费等优点。借助必要的插件可以实现编译、调试等功能，相对于传统的 IDE ，vscode 的调试功能略显薄弱，但是绝对是够用的。笔者已经在一些比较复杂的项目中使用 vscode 作为主力开发环境了，完全了可以胜任日常的开发工作。<br>接下来，你可以按照如下步骤安装 vscode 及必要的插件。<br>
<br>打开链接： <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/" target="_blank">Visual Studio Code - Code Editing. Redefined</a>，下载 vscode 并安装；
<br>安装完成后，打开 vscode 安装插件
<br>
<br>clangd 用于代码提示；
<br><img alt="https://pic1.zhimg.com/80/v2-5466be73242fdb3f046886d3888accda_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp" referrerpolicy="no-referrer"><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/583201222" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/583201222" target="_blank">liuy928：VSCode - 使用Clangd搭建C++开发环境11 赞同 · 1 评论文章</a><br>
<br>Cortex-Debug 这个插件提供了调试功能，支持寄存器查看、内存查看、断点调试、变量观察等功能。
<br><img alt="https://pic1.zhimg.com/80/v2-b653c734688acaaa368f25d4cb26815a_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b653c734688acaaa368f25d4cb26815a_720w.webp" referrerpolicy="no-referrer"><br>
<br>Embedded Tools 这是微软官方提供的调试插件，功能和 Cortex Debug相似；在实际使用的时候和 Cortex-Debug 二选一便可；
<br><img alt="https://pic4.zhimg.com/80/v2-b1572bf5f85ba8fa90cc0b0e379e84df_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b1572bf5f85ba8fa90cc0b0e379e84df_720w.webp" referrerpolicy="no-referrer"><br><br>gcc-arm-none-eabi 是由 ARM 官方维护的开源<a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&amp;zhida_source=entity&amp;is_preview=1" target="_blank">交叉编译</a>工具，提供了编译、调试、可执行文件格式转换，文件分析等一系列的工具。 交叉编译是指，我们在 PC 上编译出运行在 ARM 上的可执行程序。而交叉编译工具就是用来完成这项工作的。<br>你可以按照如下步骤安装 gcc-arm-none-eabi。<br>
<br>点击链接 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//developer.arm.com/downloads/-/gnu-rm" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//developer.arm.com/downloads/-/gnu-rm" target="_blank"></a><a rel="noopener nofollow" class="external-link" href="https://developer.arm.com/downloads/-/gnu-rm" target="_blank">https://developer.arm.com/downloads/-/gnu-rm</a> ，进入下载页面；
<br>下载下图标识的压缩包。截图为文章编写时候的版本号，实际请以当时部署的版本为准，只需要确保按照实际的开发环境下载对应的文件便可；
<br><img alt="https://pica.zhimg.com/80/v2-6b8b7f8617b17b980c51805e78b5e186_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-6b8b7f8617b17b980c51805e78b5e186_720w.webp" referrerpolicy="no-referrer"><br>
<br>将下载下来的压缩包解压到指定目录。比如，笔者在 C 盘专门创建了一个目录 ~Arm_Development_Toolchains 用来存放开发过程中常用的工具，所以将压缩包解压到了此处。解压后的内容如下图；
<br><img alt="https://pic3.zhimg.com/80/v2-965c244b5999756655348b18d776236c_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-965c244b5999756655348b18d776236c_720w.webp" referrerpolicy="no-referrer"><br>
<br>将目录 C:~Arm_Development_Toolchains\gcc-arm-none-eabi-10.3-2021.10\bin，添加到 系统环境变量；
<br>验证是否安装成功。打开命令行窗口，输入如下命令 arm-none-eabi-gcc -v，如果输出如下内容说明安装成功了。
<br><img alt="https://pic4.zhimg.com/80/v2-b0f6159c766e28f0f89cfa72f92c479d_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-b0f6159c766e28f0f89cfa72f92c479d_720w.webp" referrerpolicy="no-referrer"><br>
<br>如果输出内容不正确，请检查 系统环境变量 设置是否正确。
<br><br>MinGW 是 Windows 平台上的 C、C++ 编译与构建工具，这里我们只使用了其提供的 make 工具。 当我们编译一个过少数几个源文件的时候，可以直接使用编译器进行编译，并得到可执行文件。但是当遇到文件数量增加、依赖关系复杂，直接使用编译工具来编译就有点力不从心了，所以我们需要使用构建工具来简化我们的工作。 make 作为构建工具，可以通过 makefile 脚本文件，指定你要编译哪些源文件、这些源文件依赖于哪些文件、使用什么编译器来编译这些文件、编译时采用什么优化等信息。<br>你可以按照如下步骤安装 MinGW 。<br>
<br>打开链接 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/skeeto/w64devkit/releases" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/skeeto/w64devkit/releases" target="_blank">Releases · skeeto/w64devkit (github.com)</a> ，进入下载页面；
<br>点击下面的按钮下载文件；
<br><img alt="https://pic3.zhimg.com/80/v2-11d1721fa78c2024d45326da0a90a55c_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-11d1721fa78c2024d45326da0a90a55c_720w.webp" referrerpolicy="no-referrer"><br>
<br>解压下载的压缩包到 C:~Arm_Development_Toolchains，文件内容如下；
<br><img alt="https://picx.zhimg.com/80/v2-a240574c49374a2b6a0fbdad23caa3db_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-a240574c49374a2b6a0fbdad23caa3db_720w.webp" referrerpolicy="no-referrer"><br>
<br>将目录 C:~Arm_Development_Toolchains\w64devkit\bin，添加到 系统环境变量；
<br>验证安装结果。打开命令行窗口，依次输入命令：make -v 和 gcc -v；应该得到如下结果；
<br><img alt="https://picx.zhimg.com/80/v2-758f250274e66458db4fb5f51efdf45d_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-758f250274e66458db4fb5f51efdf45d_720w.webp" referrerpolicy="no-referrer"><br>
<br>如果出现错误，请检查是否正确配置环境变量。
<br><br>Ninja 和 Make 都属于构建系统。Ninja 是谷歌的一名程序员设计的注重速度的小型构建系统，官网 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//ninja-build.org/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//ninja-build.org/" target="_blank"></a><a rel="noopener nofollow" class="external-link" href="https://ninja-build.org" target="_blank">https://ninja-build.org</a>。 不过对于一般的嵌入式项目的体量，Ninja 和 Make 在构建速度上是感觉不到很大差异的，这里之所以着列举出来，主要是笔者个人喜好。 你可以在实际体验过 Make 和 Ninja 后做出自己的选择。<br>你可以按照如下步骤安装 Ninja。<br>
<br>打开链接 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ninja-build/ninja/releases" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ninja-build/ninja/releases" target="_blank"></a><a rel="noopener nofollow" class="external-link" href="https://github.com/ninja-build/ninja/releases" target="_blank">https://github.com/ninja-build/ninja/releases</a> ，下载压缩包；
<br><img alt="https://pic2.zhimg.com/80/v2-f4088ab4fc011347f82edc41bc94b2a1_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-f4088ab4fc011347f82edc41bc94b2a1_720w.webp" referrerpolicy="no-referrer"><br>
<br>解压下载后的压缩包到 C:~Arm_Development_Toolchains，文件内容如下；
<br><img alt="https://pica.zhimg.com/80/v2-fd293caee007198d1cc45f4d9bf043de_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-fd293caee007198d1cc45f4d9bf043de_720w.webp" referrerpolicy="no-referrer"><br>
<br>将目录 C:~Arm_Development_Toolchains\Ninja，添加到 系统环境变量；
<br>验证安装结果。打开命令行窗口，输入命令 ninja --version，应看他如下结果；
<br><img alt="https://pica.zhimg.com/80/v2-fd293caee007198d1cc45f4d9bf043de_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-fd293caee007198d1cc45f4d9bf043de_720w.webp" referrerpolicy="no-referrer"><br>
<br>如果结果不正确，请检查环境变量设置是否正确。
<br><br>一般情况下，笔者不会自己去编写 Make 或 Ninja 的构建脚本，而是通过 cmake 工具生成对应的构建脚本。 cmake 是一种构建脚本生成工具。它允许开发者编写一个与平台无关的文件CmakeLists.txt ，来制定整个编译流程。然后，再根据目标用户的平台进一步生成所需的构建文件，如 Unix 的 Makefile 或 ninja 或其他。显然，CMake 是一个比上述构建工具更高级的编译配置工具。另外，CMakeLists.txt 的语法清晰明确，更适合手工编写，后面的文章会详细介绍。<br>你可以按照如下步骤安装 Cmake。<br>
<br>打开链接 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//cmake.org/download/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//cmake.org/download/" target="_blank"></a><a rel="noopener nofollow" class="external-link" href="https://cmake.org/download/" target="_blank">https://cmake.org/download/</a> ，找到 “Binary distributions” ，然后按照你的操作系统类型下载对应的二进制包。笔者使用的是 Win11 x64 ，所以下载的是
<br><img alt="https://pic3.zhimg.com/80/v2-af9b81cf3c55df6157eb3a0872b19976_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-af9b81cf3c55df6157eb3a0872b19976_720w.webp" referrerpolicy="no-referrer"><br>
<br>将下载的压缩包解压到 C:~Arm_Development_Toolchains, 文件内容如下；
<br><img alt="https://pic1.zhimg.com/80/v2-9f3e765746ecd68b22eeca585aac177c_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-9f3e765746ecd68b22eeca585aac177c_720w.webp" referrerpolicy="no-referrer"><br>
<br>将目录 C:~Arm_Development_Toolchains\cmake-3.22.1-windows-x86_64\bin，添加到 系统环境变量；
<br>检查安装结果；打开命令行窗口，输入命令 cmake --version，应看到如下结果；
<br><img alt="https://pic1.zhimg.com/80/v2-2327013e114b8094d0795d6050e7de14_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-2327013e114b8094d0795d6050e7de14_720w.webp" referrerpolicy="no-referrer"><br>
<br>如果结果不正确，请检查环境变量设置是否正确。
<br><br>通过前面的步骤，你已经完成了 编辑器、构建工具、编译工具、调试工具的安装，接下来我们需要安装调试管理工具。 OpenOCD（Open On-Chip Debugger） 是一个开源的片上调试器，旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。OpenOCD 的功能需要调试仿真器的支持，例如 ST-Link、_J-Link、_DAP-Link* 等。 详细的使用方法，可以阅读官网（<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//openocd.org/pages/documentation.html" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//openocd.org/pages/documentation.html" target="_blank">Documentation (openocd.org)</a>）的文档，在后面的文章中也会讲到一些基本的用法。<br>你可以按照如下步骤安装 OpenOCD。<br>
<br>打开链接 <a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/xpack-dev-tools/openocd-xpack/releases/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/xpack-dev-tools/openocd-xpack/releases/" target="_blank">Releases · xpack-dev-tools/openocd-xpack (github.com)</a>，下载图示压缩包；
<br><img alt="https://pic4.zhimg.com/80/v2-2276dac478f3b8f18724503b6477bcc9_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-2276dac478f3b8f18724503b6477bcc9_720w.webp" referrerpolicy="no-referrer"><br>
<br>将下载的压缩包解压到 C:~Arm_Development_Toolchains, 文件内容如下；
<br><img alt="https://picx.zhimg.com/80/v2-8df30c4076a702cdc5e3ab0161198a9b_720w.webp" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-8df30c4076a702cdc5e3ab0161198a9b_720w.webp" referrerpolicy="no-referrer"><br>
<br>将目录 C:~Arm_Development_Toolchains\xpack-openocd-0.11.0-4\bin，添加到 系统环境变量；
<br>检查安装结果；打开命令行窗口，输入命令 openocd --version，应看到如下结果；
<br><img alt="IMG-48C006B34EAB3E422700F2F7DA72BDC7-20241114140150217" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-48C006B34EAB3E422700F2F7DA72BDC7-20241114140150217.png" referrerpolicy="no-referrer"><br>
<br>如果结果不正确，请检查环境变量设置是否正确。
<br><br>本文介绍了一套用于嵌入式开发的完整工具链。<br>通过它们你可以完成 编译、构建、调试 等工作。 IAR 、Keil 、CubeIDE 等 IDE 在实际使用的时候，也包含了提供上述功能的工具，只不过开发者在使用的时候不用过多的去了解细节。<br><br>你可以通过如下命令获取到上述除 vscode 以外的所有工具，前提是你已经安装了 Git 工具。<br>git clone https://gitee.com/sherlock290/arm_development_toolchains.git
<br>关于什么是 Git 以及如何使用Git，这又是另外一个技术话题了，此处不展开。如果你从来没有接触过 Git ，那么可以去网上检索一些优秀的 Git 技术教程，花上半个小时了解一下 Git 的基本用法，然后在再以后的工作或学习中逐步深入了解 Git 的高级用法]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/GCC + Vscode 搭建 STM32 开发环境（一）- 环境部署.md</guid><pubDate>Sat, 30 Nov 2024 05:49:39 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-5466be73242fdb3f046886d3888accda_720w.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OpenOCD添加第三方设备支持HT32F52352 Cortex-M0]]></title><description><![CDATA[ 
 <br><br><br>开发板上板载了一个e-link32 Lite，其实就是一个<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=CMSIS&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=CMSIS&amp;spm=1001.2101.3001.7020" target="_blank">CMSIS</a>-DAP，不过只支持SWD方式。在Holtek官网找到芯片手册，芯片大致信息:<br>
<br>32-bit Arm® Cortex®-M0+ 处理器内核（基于ARMv6-M）
<br>128KB 片上 Flash 存储器用作指令 / 数据和选项存储
<br>16KB 片上 SRAM
<br>Flash 存储器控制器 – FMC
<br>内部总线矩阵连接 AHB-Lite 接口，单循环 I/O 口和调试访问端口 (DAP)
<br>串行线调试端口 (SW-DP)
<br>ARM芯片大多数都遵循CMSIS协议，OpenOCD也自带了调试接口，这也就意味着芯片的<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=DAP&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=DAP&amp;spm=1001.2101.3001.7020" target="_blank">DAP</a>不需要我们自己设计。而 HT32F52352芯片没有被OpenOCD官方分支收录(怎么会被收录呢)，这个其实就是没有对应的target规则和flash烧写规则，需要我们自己去编写，因此本文主要是编写针对HT32F52352的target文件和flash文件。<br>要让OpenOCD能够找到我们编写的芯片信息，需要进行如下步骤：(引用)<br>在./tcl/target中,添加自己设备的.cfg文件,此文件用于编译后传递到scripts中供用户调用，此文件用于编译后传递到scripts中供用户调用<br>在./src/flash/nor中,添加自己设备的.c文件,此文件用于告知openocd你文件的flash烧录流程，此文件用于告知openocd你文件的flash烧录流程<br>在 /src/flash/drivers.c中,添加自己设备的设备名,此处让openocd知晓你的设备.，此处让openocd知晓你的设备.<br>在flash/nor中,更改Makefile.am,令openocd的编译过程可以引用到你刚刚添加的文件.，令openocd的编译过程可以引用到你刚刚添加的文件.<br>
ht32f523xx.cfg
<br>target文件参照自带的stm32l0.cfg来改写<br>根据OpenOCD官方的文档，一个target的cfg文件应该以如下方式开头：<br>source [find target/swj-dp.tcl]
source [find mem_helper.tcl]
 
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
#stm32l0 refer to your device
   set _CHIPNAME stm32l0
}
<br>贴出完整文件:(ht32f523xx.cfg),这个比较简单，看注释即可<br>#
# M0+ devices only have SW-DP, but swj-dp code works, just don't
# set any jtag related features
#
 
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]
 
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME ht32f5xxxx
}
 
set _ENDIAN little
 
# Work-area is a space in RAM used for flash programming
# By default use 2kB (max ram on smallest part)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x0800
}
 
# JTAG speed should be &lt;= F_CPU/6.
# F_CPU after reset is ~2MHz, so use F_JTAG max = 333kHz
adapter speed 300
 
adapter srst delay 100
 
if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    # Arm, m0+, non-multidrop.
    # http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka16088.html
    # you can also find this id in keil MDK
    set _CPUTAPID 0x0bc11477
}
 
swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
 
#diffirent of v0.10.x,in OpenOCD v0.11.x it should use -dap instead of -chain-position
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap
 
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32lx 0 0x00020000 0 0 $_TARGETNAME
 
reset_config srst_nogate
 
#I don't know what the following is
if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
$_TARGETNAME configure -event reset-start {
  
  #default speed
  adapter speed 300
}
 
$_TARGETNAME configure -event examine-end {
  
  #close DBG_WDT
  mmw 0x40088304 0x00000008 0
}
<br><br>
ht32f523xx.c
<br>此处开始讨论flash处理程序<br>首先要知道芯片片内FLASH的操作外设信息，此处贴出HT32F52352的官网资料:(主要信息)<br>片内FLASH控制器为FLASH Manage Controller(FMC)，其挂载在AHB总线上，复位后默认时钟为开启。FMC提供页擦除，整片擦除，字编程，页保护等功能<br>操作步骤具体参考芯片厂家的描述，对于HT32F52352的FMC，其字编程流程为:<br>
<br>写入编程地址(4 bytes align)到TADR寄存器(0x000 offset)
<br>写入要写入的数据(4 bytes)到WRDR寄存器 (0x004 offset)
<br>向OCMR寄存器的CMD[3:0]位写入操作命令{0x4 字编程；0x8 页擦除；0xA 整片擦除} (0x00C offset)
<br>检查OPCR寄存器的OPM[4:1]位 {0x6 第一次前空闲,0xE 操作完成空闲,other FMC繁忙} (0x010 offset)
<br>当OPM为0x6活0xE时，向OPM写入0xA以执行命令
<br>完成
<br>&nbsp;在flash中主要要做的是把FMC各个外设寄存器的地址以及操作命令，状态参数等通过宏定义声明在文件内。对每个实现构造函数，openocd的编辑脚本采用的是严格的编译检查，因此每个需要被回调的函数的返回值，参数类型，参数个数都要于openocd声明的严格一致。<br>参照官方的stm32lx.c（l0系列也是Cortex-M0+）以下是写出的程序:<br>程序中其实还有一些部分没有实现，主要是片内flash保护和info获取，因为本人觉得这两个功能不怎么用得上，需要的话按照手册上的说明构造对应的函数，在flash_driver<a data-tooltip-position="top" aria-label="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782?utm_source=glcblog&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782?utm_source=glcblog&amp;spm=1001.2101.3001.7020" target="_blank">结构体</a>的protect元素中赋值对应函数的指针即可。<br>(可以clone源码再来看，文件路径是 src/flash/nor/ht32f523xx.c)<br>#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
 
#include "imp.h"
#include &lt;helper/binarybuffer.h&gt;
#include &lt;target/algorithm.h&gt;
#include &lt;target/armv7m.h&gt;
#include &lt;target/cortex_m.h&gt;
 
/*******HT32F523xx Flash Manager Contorler(FMC) regisister location*******/
#define FMC_REG_BASE  0x40080000  /*FLASH Manager Contorller base addr   */
/*************************************************************************/
#define FMC_REG_TADR  0x000  /*FLASH ADDR REG                            */
#define FMC_REG_WRDR  0x004  /*Data for writing REG                      */
#define FMC_REG_OCMR  0x00C  /*Operation CMD REG                         */
#define FMC_REG_OPCR  0x010  /*Operation CTRL REG                        */
#define FMC_REG_OIER  0x014  /*Interrupt ENABLE REG                      */
#define FMC_REG_OISR  0x018  /*Interrupt STATUS REG                      */
#define FMC_REG_PPSR  0x020  /*Page erase/Programming protect STATUS REG */
#define FMC_REG_CPSR  0x030  /*Safety protection STATUS REG              */
#define FMC_REG_VMCR  0x100  /*Vector mapping CTRL REG                   */
#define FMC_REG_MDID  0x180  /*Manufacture and Microcontroller ID REG    */
#define FMC_REG_PNSR  0x184  /*Pages STATUS REG                          */
#define FMC_REG_PSSR  0x188  /*Size of page STATUS REG                   */
#define FMC_REG_CFCR  0x200  /*Cache and pre-read control REG            */
#define FMC_REG_CIDR0 0x310  /*User-defined ID REG0                      */
#define FMC_REG_CIDR1 0x314  /*User-defined ID REG1                      */
#define FMC_REG_CIDR2 0x318  /*User-defined ID REG2                      */
#define FMC_REG_CIDR3 0x31C  /*User-defined ID REG3                      */
/*************************************************************************/
 
/***************************FMC OPRC regisister***************************/
#define FMC_OPM_MASK  0x1E
#define FMC_COMMIT   (0xA &lt;&lt; 1)
#define FMC_FINISHED (0xE &lt;&lt; 1)
#define FMC_START    (0x6 &lt;&lt; 1)
/*************************************************************************/
 
/***************************FMC OCMR regisister***************************/
#define FMC_CMD_MASK        0xF
#define FMC_CMD_WORD_PROG   0x4
#define FMC_CMD_PAGE_ERASE  0x8
#define FMC_CMD_MASS_ERASE  0xA
/*************************************************************************/
 
/***************************FMC option byte regisister***************************/
#define OPTION_BYTE_BASE 0x1FF00000
#define OPT_OB_PP 0x000
#define OPT_OB_CP 0x010
 
/*************************************************************************/
 
#define FLASH_ERASE_TIMEOUT  1000  /*timeout count*/
 
/*Command flash bank ht32f523xx &lt;base&gt; &lt;size&gt; 0 0 &lt;target&gt;*/
FLASH_BANK_COMMAND_HANDLER(ht32f523xx_flash_bank_command)
{
    if(CMD_ARGC &lt; 6)
        return ERROR_COMMAND_SYNTAX_ERROR;
    
    bank-&gt;driver_priv = NULL;
 
    return ERROR_OK;
}
 
static inline int ht32f523xx_get_flash_status(struct flash_bank *bank, uint32_t *status)
{
    struct target *target = bank-&gt;target;
    return target_read_u32(target,FMC_REG_BASE + FMC_REG_OPCR, status);
}
 
static int ht32f523xx_wait_status_busy(struct flash_bank *bank,int timeout)
{
    uint32_t status;
    int retval = ERROR_OK;
 
    for(;;){
        retval = ht32f523xx_get_flash_status(bank,&amp;status);
        if(retval != ERROR_OK){
            return retval;
        }
        if( ((status &amp; FMC_OPM_MASK)==FMC_FINISHED) || ((status &amp; FMC_OPM_MASK) == FMC_START) ){
            return ERROR_OK;
        }
        if(timeout-- &lt;= 0){
            LOG_DEBUG("Timed out waiting for flash: 0x%04x", status);
            return ERROR_FAIL;
        }
        alive_sleep(10);
    }
 
    return retval;
}
 
static int ht32f523xx_erase(struct flash_bank *bank, unsigned int first, unsigned int last)
{
    struct target *target = bank-&gt;target;
 
    LOG_DEBUG("ht32f523xx erase: %d - %d", first, last);
 
    if(target-&gt;state != TARGET_HALTED){
        LOG_ERROR("Target not halted");
        return ERROR_TARGET_NOT_HALTED;
    }
 
    for(unsigned int i = first ; i &lt;= last; ++i){
        /*flash memory page erase*/
        int retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_TADR,bank-&gt;sectors[i].offset);
        if(retval != ERROR_OK){
            return retval;
        }
 
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OCMR,FMC_CMD_PAGE_ERASE);
        if(retval != ERROR_OK){
            return retval;
        }
 
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OPCR,FMC_COMMIT);
        if(retval != ERROR_OK){
            return retval;
        }
 
        //wait
        retval = ht32f523xx_wait_status_busy(bank,FLASH_ERASE_TIMEOUT);
        if(retval != ERROR_OK){
            return retval;
        }
 
        LOG_DEBUG("HT32F523xx erased page %d", i);
        bank-&gt;sectors[i].is_erased = 1;
    }
 
    return ERROR_OK;
}
 
static int ht32f523xx_protect(struct flash_bank *bank, int set, unsigned int first, unsigned int last)
{
    return ERROR_FLASH_OPER_UNSUPPORTED;
}
 
static int ht32f523xx_write(struct flash_bank *bank, const uint8_t *buffer,uint32_t offset, uint32_t count)
{
    struct target *target = bank-&gt;target;
 
    LOG_DEBUG("ht32f523xx flash write: 0x%x 0x%x", offset, count);
 
    if(target-&gt;state != TARGET_HALTED){
        LOG_ERROR("Target not halted");
        return ERROR_TARGET_NOT_HALTED;
    }
    if(offset &amp; 0x03){
        LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte alignment", offset);
        return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
    }
    if(count &amp; 0x3){
        LOG_ERROR("size 0x%" PRIx32 " breaks required 4-byte alignment", count);
        return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
    }
 
    uint32_t addr = offset;
    for(uint32_t i = 0; i &lt; count; i += 4){
        uint32_t word = (buffer[i]   &lt;&lt; 0)  |
                        (buffer[i+1] &lt;&lt; 8)  |
                        (buffer[i+2] &lt;&lt; 16) |
                        (buffer[i+3] &lt;&lt; 24);
 
        LOG_DEBUG("ht32f523xx flash write word 0x%x 0x%x 0x%08x", i, addr, word);
 
        // flash memory word program
        int retval;
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_TADR, addr);
        if (retval != ERROR_OK)
            return retval;
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_WRDR, word);
        if (retval != ERROR_OK)
            return retval;
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OCMR, FMC_CMD_WORD_PROG);
        if (retval != ERROR_OK)
            return retval;
        retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OPCR, FMC_COMMIT);
        if (retval != ERROR_OK)
            return retval;
 
        // wait
        retval = ht32f523xx_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
        if (retval != ERROR_OK)
            return retval;
        addr += 4;
    }
 
    LOG_DEBUG("ht32f523xx flash write success");
    return ERROR_OK;
}
 
static int ht32f523xx_probe(struct flash_bank *bank)
{
    int page_size = 512;
    int num_pages = bank-&gt;size / page_size;
 
    LOG_INFO("ht32f523xxx probe: %d pages, 0x%x bytes, 0x%x total", num_pages, page_size, bank-&gt;size);
 
    if(bank-&gt;sectors){
        free(bank-&gt;sectors);
    }
 
    bank-&gt;base = 0x0;
    bank-&gt;num_sectors = num_pages;
    bank-&gt;sectors = malloc(sizeof(struct flash_sector) * num_pages);
 
    for(int i = 0; i &lt; num_pages; ++i){
        bank-&gt;sectors[i].offset = i * page_size;
        bank-&gt;sectors[i].size = page_size;
        bank-&gt;sectors[i].is_erased = -1;
        bank-&gt;sectors[i].is_protected = 1;
    }
 
    return ERROR_OK;
}
 
static int ht32f523xx_auto_probe(struct flash_bank * bank)
{
    return ht32f523xx_probe(bank);
}
 
static int ht32f523xx_protect_check(struct flash_bank *bank)
{
    struct target *target = bank-&gt;target;
    uint32_t ob_pp[4];
    uint32_t ob_cp;
    
    //read OB_PP REG
    for(int i=0; i&lt;4; ++i)
    {
        target_read_u32(target,(OPTION_BYTE_BASE + OPT_OB_PP) + (i &lt;&lt; 2),ob_pp + i);
    }
 
    //read OB_CP REG
    target_read_u32(target,(OPTION_BYTE_BASE + OPT_OB_CP),&amp;ob_cp);
 
    LOG_INFO("ht32f523xx opt byte: %04x %04x %04x %04x %04x", ob_pp[0], ob_pp[1], ob_pp[2], ob_pp[3], ob_cp);
    
    // Set page protection
    for(int i = 0 ; i &lt; 128; ++i){
        int bit = (ob_pp[i / 32] &lt;&lt; (i % 32)) &amp; 1;
        bank-&gt;sectors[2*i].is_protected = bit ? 0 : 1;
        bank-&gt;sectors[(2*i)+1].is_protected = bit ? 0 : 1;
    }
 
    return ERROR_OK;
}
 
static int ht32f523xx_info(struct flash_bank *bank, struct command_invocation *cmd)
{
    command_print_sameline(cmd, "ht32f523xx");
    return ERROR_OK;
}
 
static int ht32f523xx_mass_erase(struct flash_bank *bank)
{
    struct target *target = bank-&gt;target;
 
    if (target-&gt;state != TARGET_HALTED) {
        LOG_ERROR("Target not halted");
        return ERROR_TARGET_NOT_HALTED;
    }
 
    //WITHOUT FMC_BUSY CHECK?!
 
    // flash memory mass erase
    int retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OCMR, FMC_CMD_MASS_ERASE);
    if (retval != ERROR_OK)
        return retval;
    retval = target_write_u32(target, FMC_REG_BASE + FMC_REG_OPCR, FMC_COMMIT);
    if (retval != ERROR_OK)
        return retval;
 
    retval = ht32f523xx_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
    if (retval != ERROR_OK)
        return retval;
 
    return ERROR_OK;
}
 
COMMAND_HANDLER(ht32f523xx_handle_mass_erase_command)
{
    if(CMD_ARGC &lt; 6){
        return ERROR_COMMAND_SYNTAX_ERROR;
    }
 
    struct flash_bank *bank;
    int retval = CALL_COMMAND_HANDLER(flash_command_get_bank,0,&amp;bank);
    if(retval != ERROR_OK){
        return retval;
    }
 
    retval = ht32f523xx_mass_erase(bank);
    if (retval == ERROR_OK) {
        // set all sectors as erased
        unsigned int i;
        for (i = 0; i &lt; bank-&gt;num_sectors; i++)
            bank-&gt;sectors[i].is_erased = 1;
 
        //command_print(CMD_CTX, "ht32f523xx mass erase complete");
    } else {
        //command_print(CMD_CTX, "ht32f523xx mass erase failed");
    }
 
    return ERROR_OK;
}
 
COMMAND_HANDLER(ht32f523xx_handle_test_write)
{
    if(CMD_ARGC &lt; 6){
        return ERROR_COMMAND_SYNTAX_ERROR;
    }
 
    struct flash_bank *bank;
    int retval = CALL_COMMAND_HANDLER(flash_command_get_bank,0,&amp;bank);
    if(retval != ERROR_OK){
        return retval;
    }
 
    uint8_t buffer[32];
    for(int i = 0; i &lt; 32; ++i){
        buffer[i] = i;
    }
 
    retval = ht32f523xx_erase(bank, 0, 0);
    if (retval != ERROR_OK)
        return retval;
 
    retval = ht32f523xx_write(bank, buffer, 0, 32);
    if (retval == ERROR_OK) {
        //command_print(CMD_CTX, "ht32f523xx test write complete");
    } else {
        //command_print(CMD_CTX, "ht32f523xx test write failed");
    }
 
    return retval;
}
 
static const struct command_registration ht32f523xx_exec_command_handlers[] = {
    {
        .name = "mass_erase",
        .handler = ht32f523xx_handle_mass_erase_command,
        .mode = COMMAND_EXEC,
        .usage = "bank_id",
        .help = "test flash write",
    },
    {
        .name = "test_write",
        .handler = ht32f523xx_handle_test_write,
        .mode = COMMAND_EXEC,
        .usage = "bank_id",
        .help = "test flash write",
    },
    COMMAND_REGISTRATION_DONE
};
 
static const struct command_registration ht32f523xx_command_handlers[] = {
    {
        .name = "ht32f523xx",
        .mode = COMMAND_ANY,
        .help = "ht32f523xx flash command group",
        .usage = "",
        .chain = ht32f523xx_exec_command_handlers,
    },
    COMMAND_REGISTRATION_DONE
};
 
const struct flash_driver ht32f523xx_flash = {
    .name = "ht32f523xx",
    .commands = ht32f523xx_command_handlers,
    .flash_bank_command = ht32f523xx_flash_bank_command,
 
    .erase = ht32f523xx_erase,
    .protect = ht32f523xx_protect,
    .write = ht32f523xx_write,
    .read = default_flash_read,
    .probe = ht32f523xx_probe,
    .auto_probe = ht32f523xx_auto_probe,
    .erase_check = default_flash_blank_check,
    .protect_check = ht32f523xx_protect_check,
    .info = ht32f523xx_info,
};
<br>其中COMMAND_HANDLER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLASH_BANK_COMMAND_HANDLER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND_HELPER&nbsp;这三个宏都是定义函数，其接受多参数输入，上面所有的函数定义最终都是实现最后面三个结构体需要的回调函数。<br><br>在编写好flash的.c文件之后，修改nor目录下的drivers.c，把ht32f523xx_flash声明为全局并把其指针加入下面的指针<a data-tooltip-position="top" aria-label="https://edu.csdn.net/course/detail/40020?utm_source=glcblog&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://edu.csdn.net/course/detail/40020?utm_source=glcblog&amp;spm=1001.2101.3001.7020" target="_blank">数组</a>。完成后修改nor目录下的Makefile.am，加入对ht32f523xx.c的编译。回到主目录:<br>user@localhost:./bootstarp &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install
<br>这样就安装完成了。下面放一些运行的效果图:<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ed00b1560c37480b5ba30ce90304c240.png" referrerpolicy="no-referrer"><br>图:openocd连接设备<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5826531d3fb663f08d90677188fee034.png" referrerpolicy="no-referrer"><br>图:telnet连接openocd服务器并进行烧录<br>(可以看到烧录很慢，即便把adapter speed提高到1MHz也要3.84s，针对这个问题正在设法解决)<br>在此补充一下openocd在telnet下面的常规烧录步骤:<br>#halt the cpu
halt
#write hex
flash write-image erase xxx.hex
#reset
reset
<br>小结：<br>这个是我第一次为OpenOCD添加设备支持，也是我第一次动手改<a data-tooltip-position="top" aria-label="https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020" target="_blank">开源</a>代码(之前改过一次6relayd的只是修改CMakeLists.txt去使用交叉编译和静态链接)。前前后后我其实已经用了两个多星期。因为不管在国内还是国外网站关于OpenOCD的使用大多是基于官方自带的芯片库(以STM32为主)，对于添加第三方芯片的教程几乎没有，刚开始的时候是一直看芯片手册，然后是看OpenOCD官方的User's Guide 和 Developer's Guide。不过说实话，OpenOCD官方的文档中似乎并没有设计第三方芯片添加需要进行的关键操作，其只是在cfg文件格式和命令上有比较大的篇幅。<br>主要参考资料:(其实参考了很多很多，不过大部分都忘记记录了)<br>OpenOCD 官方手册<br>HT32F52342_52 UserManuals<br><a data-tooltip-position="top" aria-label="https://blog.csdn.net/idk500/article/details/98476288?spm=1001.2014.3001.5502" rel="noopener nofollow" class="external-link" title="OpenOCD RISCV" href="https://blog.csdn.net/idk500/article/details/98476288?spm=1001.2014.3001.5502" target="_blank">OpenOCD RISCV</a>  <br>&nbsp;<br><a data-tooltip-position="top" aria-label="https://blog.csdn.net/SMarxX/article/details/8486052" rel="noopener nofollow" class="external-link" title="Ubuntu 下使用OpenOCD进行烧录" href="https://blog.csdn.net/SMarxX/article/details/8486052" target="_blank">Ubuntu 下使用OpenOCD进行烧录</a><br><a data-tooltip-position="top" aria-label="http://xn--githubopenocd-ht32-s642h/" rel="noopener nofollow" class="external-link" title="https://github.com/ChaoticEnigma/openocd-ht32" href="http://xn--githubopenocd-ht32-s642h/" target="_blank">https://github.com/ChaoticEnigma/openocd-ht32</a>]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\OpenOCD添加第三方设备支持HT32F52352 Cortex-M0.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/OpenOCD添加第三方设备支持HT32F52352 Cortex-M0.md</guid><pubDate>Sun, 01 Dec 2024 15:02:56 GMT</pubDate><enclosure url="https://i-blog.csdnimg.cn/blog_migrate/befa6bcf0cb5a89108ab1feabdc629b5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i-blog.csdnimg.cn/blog_migrate/befa6bcf0cb5a89108ab1feabdc629b5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSCode - 使用Clangd搭建C++开发环境]]></title><description><![CDATA[ 
 <br>一直使用的是微软出品的 C/C++ 插件，但是时不时就会出现代码提示失效，跳转失败的问题。在 c_cpp_properties.json 配置了 compileCommands 后，效果也不理想。 尝试使用了 Clion 被代码提示和跳转功能惊艳了，了解到 Clion 使用的是 Clangd 来进行代码解析的。而 VSCODE 也有 Clangd 插件，所以尝试使用 Clangd 替代 C/C++ 插件。<br>打开 VSCode 插件市场搜索 Clangd 安装；<br><img alt="https://pic1.zhimg.com/80/v2-70a0c665d4f87aea23aa0f2b8a59430e_720w.webp" src="https://pic1.zhimg.com/80/v2-70a0c665d4f87aea23aa0f2b8a59430e_720w.webp" referrerpolicy="no-referrer"><br>如果之前有安装过 C/C++ 插件，那么 Clangd 会提示 Intelli Scense 冲突，然后可以在弹出的提示框选择禁用 C/C++ 的 Intelli Scense ，但是考虑到我用不到 C/C++ 的调试功能，所以选择了直接卸载。<br>将如下配置，粘贴到 VSCODE <a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;zhida_source=entity&amp;is_preview=1" target="_blank">用户配置文件</a> Settings.josn 的最后。<br>/// clangd
"clangd.checkUpdates": true,
"clangd.arguments": [
   "--background-index",            /// 在后台自动分析文件（基于complie_commands)
   "--compile-commands-dir=${workspaceFolder}/gcc/build",                 /// 标记compelie_commands.json文件的目录位置
   "-j=12",                         /// 同时开启的任务数量
   "--query-driver=C:/~Arm_Development_Toolchains/LLVM/bin/clang++.exe",  /// clang 路径，使用命令 which clang++ 获取的的路径
   "--clang-tidy",                  /// clang-tidy功能
   "--clang-tidy-checks=performance-*,bugprone-*",
   "--all-scopes-completion",       /// 全局补全（会自动补充头文件）
   "--completion-style=detailed",   /// 更详细的补全内容
   "--header-insertion=iwyu",       /// 补充头文件的形式
   "--pch-storage=disk",            /// pch优化的位置
],
<br>compelie_commands.json 文件 在 CMakeLists 文件增加 set(CMAKE_EXPORT_COMPILE_COMMANDS True)，运行 CMake 后会在输出目录自动创建 compelie_commands.json 文件。 通过 compelie_commands.json 你可以获得良好的代码跳转、错误提示、代码补全等功能。<br>安装 LSP 在 VSCODE 中，ctrl+shift+p 打开命令窗口，输入 Clangd 然后在命令列表里面找到 clangd: Download language server , 点击安装语言服务器； 安装完成后会提示 重新加载。<br>重启后，可以试试效果了。<br>在实际使用的时候，有可能出现即使重新编译了，但是代码提示和跳转依旧存在问题，那么可以尝试重启 clangd。具体做法是 ctrl+shift+p ，输入 Clangd 然后找到 clangd: Restart language server，点击后会<a data-tooltip-position="top" aria-label="https://zhida.zhihu.com/search?q=%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C&amp;zhida_source=entity&amp;is_preview=1" rel="noopener nofollow" class="external-link" href="https://zhida.zhihu.com/search?q=%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C&amp;zhida_source=entity&amp;is_preview=1" target="_blank">重新执行</a>索引。]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\VSCode - 使用Clangd搭建C++开发环境.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/VSCode - 使用Clangd搭建C++开发环境.md</guid><pubDate>Wed, 06 Nov 2024 07:38:23 GMT</pubDate><enclosure url="https://pic1.zhimg.com/80/v2-70a0c665d4f87aea23aa0f2b8a59430e_720w.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://pic1.zhimg.com/80/v2-70a0c665d4f87aea23aa0f2b8a59430e_720w.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSCode-GDB-J-Link-单片机程序调试实践]]></title><description><![CDATA[ 
 <br><br>本文介绍如何创建VSCode的调试配置，如何控制<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B&amp;spm=1001.2101.3001.7020" target="_blank">调试过程</a>，如何查看修改各种变量。<br><br>
<br>在 VSCode 扩展窗口搜索安装 Cortex-Debug插件<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C7A3C2E10A45A937409D739D58DF6729-20240923152155058.png" referrerpolicy="no-referrer">
<br><img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-34653845545D2E28F30582C06D9CA054-20240923152155101.png" referrerpolicy="no-referrer"><br><br>
<br>在 Run and Debug 窗口点击 create a launch.json file ，弹出窗口选择 Cortex Debug 。将创建一个默认的配置文件。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B390631182CE79C9F18B8F10E90CE1C7-20240923152155138.png" referrerpolicy="no-referrer">
<br><br>
<br>修改 executable 字段，填入待调试的程序文件名，注意：必须是 elf 格式，不是 hex 或 bin 。
<br>修改 device 字段，填入 MCU 型号。
<br>可选修改 name 字段，填入易理解的名称，这是区分不同调试配置的名称。
<br>可选添加 svdPath 字段，如果需要查看外设寄存器。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E867CDEFAAEEC00EF50049F0569D15B6-20240923152155174.png" referrerpolicy="no-referrer">
<br><br>
<br>完成配置后， Run and Debug 窗口将显示调试配置名称，点击绿色三角形 StartDebugging 按钮启动调试，如下图所示。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-51EC2D0195DFC8BB8178E673EF8389D1-20240923152155213.png" referrerpolicy="no-referrer">
<br>启动调试后，将在窗口上方显示<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7&amp;spm=1001.2101.3001.7020" target="_blank">调试工具</a>栏，如下图所示。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D552C8958E8A43259E2DA22AF49D5380-20240923152155258.png" referrerpolicy="no-referrer">
<br>Warning
注意项目路径不能出现中文, 否则会出现无法调试的情况<br>
<img alt="Pasted image 20241129172509" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/Pasted%20image%2020241129172509.png" referrerpolicy="no-referrer">
<br><br>
<br>第一个按钮为 Reset device 。复位 MCU ，重新从 main 开始执行。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BB2EBD77E3AC766421F55F61D21845A6-20240923152155294.png" referrerpolicy="no-referrer">
<br>第二个按钮为 Continue ，连续执行，即 Run 操作。连续执行期间，该按钮将变成 Pause 按钮，点击Pause 按钮将暂停 CPU 的执行，即Halt 操作。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E741B1B7A14A71855DB0BA88A5C53549-20240923152155388.png" referrerpolicy="no-referrer"><br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-76B67C6C39949353449963A71B58C419-20240923152155428.png" referrerpolicy="no-referrer">
<br>Step Over 按钮，单步执行，碰到函数，将函数作为一个步骤执行。
<br>若当前焦点在源代码窗口，则执行语句单步。
<br>若当前焦点在反汇编窗口，则执行指令单步。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4E74876C3FC508841690BD76A0CC0ABB-20240923152155460.png" referrerpolicy="no-referrer">
<br>Step Into 按钮，单步执行，碰到函数则进入函数。
<br>若当前焦点在源代码窗口，则执行语句单步。
<br>若当前焦点在反汇编窗口，则执行指令单步。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-7F7B8E8FB4950E0CD1C54F4BC43A89DE-20240923152155495.png" referrerpolicy="no-referrer">
<br>Step Out ，执行完当前函数剩余语句并返回调用处后暂停。即 Return操作。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-16F3BE285CC1452CD11171D8234EB8FA-20240923152155530.png" referrerpolicy="no-referrer">
<br>Restart ，重新开始，复位MCU ，重新从 main 开始执行。与 Reset device 按钮等效。
<br>但是，点击过 Restart 按钮后，结束调试时，调试工具栏不会消失，因此推荐使用 Reset device按钮。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A16D7CE2FB85FF9DCA0723190253E34A-20240923152155562.png" referrerpolicy="no-referrer">
<br>Stop ，结束调试。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4F72145B811A5336B74AC0B60ACB665F-20240923152155594.png" referrerpolicy="no-referrer">
<br><br>
<br>在源代码窗口行号左侧点击添加断点。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-24AEBDD30B4CF490280DACB653250C7A-20240923152155629.png" referrerpolicy="no-referrer">
<br>在 BREAKPOINTS 窗口点击加号图标添加函数断点。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FD89045C18EC27915EEF6CCFA992F478-20240923152155676.png" referrerpolicy="no-referrer">
<br><br>
<br>CALL STACK 窗口查看当前调用栈，下方函数调用上方函数。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5090B01B25FCD9812D1BE9B1886B3B37-20240923152155710.png" referrerpolicy="no-referrer">
<br><br>
<br>在 VARIABLES 窗口的 Local 分类下查看函数局部变量。
<br>在 VARIABLES 窗口的 Registers 分类下查看 CPU 寄存器。
<br>VARIABLES 窗口还可以查看全部全局变量和当前源文件的静态变量，这里列出的变量太多了，不利查看，要查看全局变量可以将全局变量添加到 WATCH窗口。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-446373CA08F59A9CA22B4C74AFF57AE8-20240923152155746.png" referrerpolicy="no-referrer">
<br><br>
<br>选中全局变量，弹出右键菜单，选择 Add to Watch ，将全局变量添加到 WATCH 窗口。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-994277A9C2710B3F1538BAC02D76C5E1-20240923152155792.png" referrerpolicy="no-referrer">
<br>也可以在 WATCH 窗口点击加号按钮添加全局变量到 WATCH 窗口。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4F48105E4D8BA60FDC319E18BB6FADD1-20240923152155825.png" referrerpolicy="no-referrer">
<br><br>
<br>XPERIPHERALS 窗口查看外设寄存器。
<br>若未在调试配置中指定 svdPath ，那么外设寄存器窗口将不可见。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-41B65527441708883658A7DD5C613BDB-20240923152155861.png" referrerpolicy="no-referrer">
<br>
<br>svdPath配置方式, .svd文件可以在pack包中找到<br>
<img alt="949482dd9a8c91221a8c3fa6f5197a4" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/949482dd9a8c91221a8c3fa6f5197a4.png" referrerpolicy="no-referrer">
<br><br>
<br>在 CPU 被 halt 的状态下，在源代码窗口点击右键选择Open Disassembly View 打开反汇编窗口。
<br>可以拖动反汇编窗口，使其与源代码窗口并排，以便对照。
<br>单步执行时，若焦点在源代码窗口，那么执行语句单步，若焦点在反汇编窗口，那么执行指令单步。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B8AB16DF31CB61A5F3ADFC6EFBBFD5B7-20240923152155898.png" referrerpolicy="no-referrer">
<br><br>
<br>若在调试配置中设置了liveWatch 字段，将支持 Live Watch ，即在线监视变量。
<br>添加到 CORTEX LIVEWATCH 窗口中的变量在CPU 执行期间将定时读取其数值，并在窗口内显示。
<br>其它方式查看变量值时需要将CPU 停下，而 Live Watch 可以在不暂停 CPU 执行的情况下定时更新变量值。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1A101290FCA7138F311FFB40E6ECAE1D-20240923152155935.png" referrerpolicy="no-referrer">
<br><br>
<br>Cortex-Debug 插件包含 XRTOS 窗口，可以自动检测程序是否使用了操作系统，并可以查看所支持的操作系统任务列表，如下图所示， XRTOS 检测到当前程序使用了 uC/OS-II ，并列出了所有任务，包括任务优先级、任务名称、堆栈使用情况。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-06B1734F2753B0E4AD4F750DF93B12A5-20240923152155987.png" referrerpolicy="no-referrer">
<br><br>
<br>VSCode 图形界面未找到添加Watchpoint 的入口。
<br>可以通过调试器命令行窗口输入调试命令的方式添加Watchpoint 。
<br>在 DEBUG CONSOLE 窗口输入 watch OSRunning 添加Watchpoint 监视 OSRunning被修改的位置。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-12669FD08EB92AC33174EFCED7B499D8-20240923152156036.png" referrerpolicy="no-referrer">
<br>DEBUG CONSOLE 输入 info break 可以查看添加的Watchpoint 。<br>
<img alt="在这里插入图片描述" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-AE0AF3F431E7FBAA0D09894CA3C6CC17-20240923152156088.png" referrerpolicy="no-referrer">
]]></description><link>1_Projects\嵌入式软件开发-交叉编译-2p\VSCode-GDB-J-Link-单片机程序调试实践.html</link><guid isPermaLink="false">1_Projects/嵌入式软件开发-交叉编译-2p/VSCode-GDB-J-Link-单片机程序调试实践.md</guid><pubDate>Fri, 29 Nov 2024 09:25:25 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C7A3C2E10A45A937409D739D58DF6729-20240923152155058.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C7A3C2E10A45A937409D739D58DF6729-20240923152155058.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[开发板介绍]]></title><description><![CDATA[ 
 <br><br>HC6800-ES V2.0<br>
<img alt="IMG-4C9D6CD2852D665256A432729D9A4DFE-20240919203953268" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4C9D6CD2852D665256A432729D9A4DFE-20240919203953268.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-54CEC64AFE791440C40187EF1B38A945-20240919203953867" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-54CEC64AFE791440C40187EF1B38A945-20240919203953867.png" referrerpolicy="no-referrer">]]></description><link>2_Areas\C51单片机\51单片机开发板.html</link><guid isPermaLink="false">2_Areas/C51单片机/51单片机开发板.md</guid><pubDate>Sun, 27 Oct 2024 03:47:09 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4C9D6CD2852D665256A432729D9A4DFE-20240919203953268.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4C9D6CD2852D665256A432729D9A4DFE-20240919203953268.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[笔记-嵌入式学习路径]]></title><description><![CDATA[ 
 <br>C语言<br>Linux系统<br>C++语言<br>STL标准模板库<br>Qt<br>Shell脚本<br>无名管道/有名管道<br>共享内存<br>线程<br>计算机网络<br>RFID<br>cc2530<br>zigbee<br>STM32<br>蓝牙开发<br>MQTT<br>NB-IoT<br>wifi-nodeMCU-esp8266开发平台<br>5G<br>数据库<br>opencv<br>PCA<br>左基础, 右深入<br>
<img alt="IMG-5FEDD25884544CBD2347297F37208BF0-20240919203953294" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5FEDD25884544CBD2347297F37208BF0-20240919203953294.png" referrerpolicy="no-referrer"><br><a data-href="image-嵌入式学习路径-mmexport53882f11a51d2094e6d510ee9ecf0c50_1676119748986.png" href="image-嵌入式学习路径-mmexport53882f11a51d2094e6d510ee9ecf0c50_1676119748986.png" class="internal-link" target="_self" rel="noopener nofollow">image-嵌入式学习路径-mmexport53882f11a51d2094e6d510ee9ecf0c50_1676119748986.png</a><br><a data-href="image-C语言学习路径-mmexportc92c818ed8197a5a9ee787dc770a46c8_1676119756336.png" href="image-C语言学习路径-mmexportc92c818ed8197a5a9ee787dc770a46c8_1676119756336.png" class="internal-link" target="_self" rel="noopener nofollow">image-C语言学习路径-mmexportc92c818ed8197a5a9ee787dc770a46c8_1676119756336.png</a><br><a data-href="imagebed-master/images-rename/2022.12-嵌入式自学地图" href="imagebed-master\images-rename\2022.12-嵌入式自学地图" class="internal-link" target="_self" rel="noopener nofollow">imagebed-master/images-rename/2022.12-嵌入式自学地图</a>]]></description><link>2_Areas\C51单片机\笔记-嵌入式学习路径.html</link><guid isPermaLink="false">2_Areas/C51单片机/笔记-嵌入式学习路径.md</guid><pubDate>Sun, 27 Oct 2024 03:47:08 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5FEDD25884544CBD2347297F37208BF0-20240919203953294.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5FEDD25884544CBD2347297F37208BF0-20240919203953294.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[存储器介绍]]></title><description><![CDATA[ 
 <br><br><img alt="IMG-56B6E2D5795BDC0B2FB485AA3FD33502-20240919203954180" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-56B6E2D5795BDC0B2FB485AA3FD33502-20240919203954180.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-B43DAB9E357A1A9D15CB04DCA63D0E7F-20240919203956135" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B43DAB9E357A1A9D15CB04DCA63D0E7F-20240919203956135.png" referrerpolicy="no-referrer"><br>与扫描按键矩阵类似, 地址总线逐一扫描置1, 横纵线交叉的位置如果相连就会输出1,反之不相连输出0.为了横线之间不互相干扰,相连处用二极管.这就是Mask ROM ,出厂后无法修改,是固定的电路.<br>如果在相连增加一个反向的二极管,写入时用高电压击穿,出厂后就可以写入一次.还有一种方法是在连接处增加一个保险丝,写入时用大流烧断,出厂后也可写入一次.所以下载程序也会称为烧录.这种储存器称为PROM可编程储存器.<br>如果找一种特殊二极管,击穿后在一定条件下可以恢复,那么储存器就可以再次写入数据,EPROM可擦除可编程储存器就是用紫外线照射30分钟后可以擦除数据.E2PROM电可擦除可编程储存器就是通过通电就可以擦除数据的储存器.<br><br><a data-href="24C02.pdf" href="24C02.pdf" class="internal-link" target="_self" rel="noopener nofollow">24C02.pdf</a><br>
<br>AT24C02是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息
<br>存储介质：E2PROM
<br>通讯接口：I2C总线
<br>容量：256字节
<br><img alt="IMG-1841E870193BDC0BADD4E647556D3158-20240919203956163" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1841E870193BDC0BADD4E647556D3158-20240919203956163.png" referrerpolicy="no-referrer"><br><img alt="IMG-28FB3CEFAAB90B224BD4C9EA641F9B64-20240919203958035" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-28FB3CEFAAB90B224BD4C9EA641F9B64-20240919203958035.png" referrerpolicy="no-referrer"><br><img alt="IMG-A34C6D71C43B49229D2C069905A177D2-20240919203958086" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A34C6D71C43B49229D2C069905A177D2-20240919203958086.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-C2B252DF6D06ECCFC0BFC15899208EFE-20240919203959851" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C2B252DF6D06ECCFC0BFC15899208EFE-20240919203959851.png" referrerpolicy="no-referrer"><br><img alt="IMG-8AB86CB42CF5424AB7358502DF9A6EA0-20240919203959897" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8AB86CB42CF5424AB7358502DF9A6EA0-20240919203959897.png" referrerpolicy="no-referrer"><br>
A0,A1,A2都接在GND,表示A0,A1,A2都为0, 说明储存器的地址为000.<br><br><img alt="IMG-614E535F140DEA72D116B8A2A77B8C2F-20240919204001575" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-614E535F140DEA72D116B8A2A77B8C2F-20240919204001575.png" referrerpolicy="no-referrer"><br>
<br>START STOP LOGIC(启动停止逻辑),SERIAL CONTROL LOGIC(串行控制逻辑),DEVICE ADDRESS COMPARATOR(器件地址比较器)都是与接口相关的

<br>EEPROM 电可擦除可编程储存器,里面是网格
<br>X DECODER X译码器, 用于扫描横轴.
<br>Y DECODER Y译码器, 用于控制纵轴输出数据
<br>SERIAL MUX  串行多路复用器,借助Y DECODER读取EEPROM数据.
<br>/ACKNOWLEDGE D输出/承认,控制数据输出
<br>DATA WORD ADDRESS COUNTER 数据字地址计数器,用于存储地址,每写入或读取一次,计数器加1.如果不指定地址,默认读取计数器的数据.


<br><br>
<br>
AT24C02的固定地址为1010，可配置地址本开发板上为000所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1

<br>
字节写：在WORD ADDRESS处写入数据DATA

<br><img alt="IMG-D21C88508D34FFAF1C8E5DE5859E3A24-20240919204001625" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D21C88508D34FFAF1C8E5DE5859E3A24-20240919204001625.png" referrerpolicy="no-referrer">


<br>
随机读：读出在WORD ADDRESS处的数据DATA

<br><img alt="IMG-6D11089DEF81077148400BB21706DE55-20240919204003334" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6D11089DEF81077148400BB21706DE55-20240919204003334.png" referrerpolicy="no-referrer">


<br>
字节写：在“字地址”处写入“数据”

<br><img alt="IMG-8D013A1CCC3A21ED3A6474FD4D2CFAC1-20240919204003409" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8D013A1CCC3A21ED3A6474FD4D2CFAC1-20240919204003409.png" referrerpolicy="no-referrer">


<br>
随机读：读出在“字地址”处的“数据”

<br><img alt="IMG-45C8FE526CC071350D743126B9BEC088-20240919204005333" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-45C8FE526CC071350D743126B9BEC088-20240919204005333.png" referrerpolicy="no-referrer">


<br><br>
<br>读取AT24C02数据

<br>主机发出开始通信信号
<br>之后发送一个字节,内容是需要通信的从机地址加上W(写),表示该数据是向谁发送.

<br>地址一般是7位,加上读写位第一个字节共8位.  表示0是W(写),1是R(读).


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后发送后面的数据地址
<br>主机发送数据地址,从机接收后应答
<br>主机接收到应答后重新开始接收数据

<br>主机发出开始通信信号
<br>主机发送第一个字节,从机地址加上R(读),表示要接收谁的数据.

<br>地址一般是7位,加上读写位第一个字节共8位.&nbsp;W―&nbsp;表示0是W(写),1是R(读).


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后接收后面的数据
<br>循环下列操作直到全部接收

<br>主机接收一个字节的数据
<br>主机接收后发送应答


<br>若不在接收数据,主机发送非应答

<br>非应答就是在下一个时序不操作,如果没有接收到数据,会自动发送非应答
<br>如果只想接收1字节数据,主机也可以主动发送非应答


<br>停止通信




<br><br><br>通过按键和LCD确定要写入的数据Num<br>#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "Key.h"
#include "Delay.h"

unsigned char KeyNum;
unsigned int Num;

void main()
{
	LCD_Init();
	LCD_ShowNum(1,1,Num,5);
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)	//K1按键，Num自增
		{
			Num++;
			LCD_ShowNum(1,1,Num,5);
		}
		if(KeyNum==2)	//K2按键，Num自减
		{
			Num--;
			LCD_ShowNum(1,1,Num,5);
		}
	}
}
<br><br>
<br>将按键和LCD得到的Num作为要写入的数据,写入的int类型有2字节,有16位数据,写入时需要进行二进制化处理.

<br>Num%256表达低8位,写入位置0.
<br>Num/256表示高8位,写入位置1.


<br>//向AT24C02写入数据
AT24C02_WriteByte(0,Num%256);
Delay(5);
AT24C02_WriteByte(1,Num/256);
Delay(5);
LCD_ShowString(2,1,"Write OK");
Delay(1000);
LCD_ShowString(2,1,"        ");

<br><br>
<br>读取时先读取位置0的低8位数据
<br>读取位置1的高八位数据后先左位移8位,再|=运算赋值到Num的高8位
<br>//从AT24C02读取数据
Num=AT24C02_ReadByte(0);
Num|=AT24C02_ReadByte(1)&lt;&lt;8;
LCD_ShowNum(1,1,Num,5);
LCD_ShowString(2,1,"Read OK ");
Delay(1000);
LCD_ShowString(2,1,"        ");

<br><br><a data-href="3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" href="3_Resources\Attachments\2_Areas\C51单片机\IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" class="internal-link" target="_self" rel="noopener nofollow">3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf</a>5<br>
AT24C02的固定地址为1010,EEPROM模块的地址为000,所以AT24C02_ADDRESS为1010 000<br>#define AT24C02_ADDRESS		0xA0
<br><br>
<br>A0,A1,A2都接在GND,表示A0,A1,A2都为0, 说明储存器的地址为000.
<br><br>
<br>AT24C02的固定地址为1010，可配置地址本开发板上为000

<br>所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1


<br><br>/**
  * @brief  AT24C02写入一个字节
  * @param  WordAddress 要写入字节的地址
  * @param  Data 要写入的数据
  * @retval 无
  */
void AT24C02_WriteByte(unsigned char WordAddress,Data)
{
	I2C_Start();           //起始条件
	I2C_SendByte(AT24C02_ADDRESS); //发送AT24C02地址+W
    I2C_ReceiveAck();  //接收应答
	I2C_SendByte(WordAddress);  //发送要写入的地址
	I2C_ReceiveAck();  //接收应答
	I2C_SendByte(Data);  //发送要写入的数据
	I2C_ReceiveAck();  //接收应答
	I2C_Stop();  //停止条件
}
<br><br>/**
  * @brief  AT24C02读取一个字节
  * @param  WordAddress 要读出字节的地址
  * @retval 读出的数据
  */
unsigned char AT24C02_ReadByte(unsigned char WordAddress)
{
	unsigned char Data;    //声明一个变量用于储存数据
	I2C_Start();  //起始条件
	I2C_SendByte(AT24C02_ADDRESS);  //发送AT24C02地址+W
	I2C_ReceiveAck();  //接收应答
	I2C_SendByte(WordAddress);  //发送要读取的地址
	I2C_ReceiveAck();  //接收应答
	
	I2C_Start();  //起始条件
	I2C_SendByte(AT24C02_ADDRESS|0x01); //发送AT24C02地址+R表示读取.
	I2C_ReceiveAck();  //接收应答
	Data=I2C_ReceiveByte();  //接收一个字节
	I2C_SendAck(1);  //发送非应答
	I2C_Stop();  //停止条件
	return Data;
}
<br><br><br><br>#include &lt;REGX52.H&gt;
#include "Timer0.h"
#include "Key.h"
#include "Nixie.h"
#include "Delay.h"
#include "AT24C02.h"

unsigned char KeyNum;
unsigned char Min,Sec,MiniSec;
unsigned char RunFlag;  //启动标志位

void main()
{
	Timer0_Init();  //初始化定时器
	while(1){
	}
}
<br><br>
<br>K1按键按下时,标志位翻转,秒表开始或停止工作.
<br>K2按键按下时,分秒清0.
<br>
KeyNum=Key();
if(KeyNum==1)			//K1按键按下
{
    RunFlag=!RunFlag;	//启动标志位翻转
}
if(KeyNum==2)			//K2按键按下
{
    Min=0;				//分秒清0
    Sec=0;
    MiniSec=0;
}
<br><br>
<br>K3按键按下时,将分秒写入AT24C02

<br>将分钟数值写入位置0
<br>将秒钟数值写入位置1
<br>将MiniSec数值写入位置2


<br>K4按键按下时,读出AT24C02的分秒数据

<br>读取位置0的数据到Min分钟
<br>


<br>if(KeyNum==3)			//K3按键按下
{
    AT24C02_WriteByte(0,Min);	//将分秒写入AT24C02
    Delay(5);
    AT24C02_WriteByte(1,Sec);
    Delay(5);
    AT24C02_WriteByte(2,MiniSec);
    Delay(5);
}

if(KeyNum==4)			//K4按键按下
{
    Min=AT24C02_ReadByte(0);	//读出AT24C02数据
    Sec=AT24C02_ReadByte(1);
    MiniSec=AT24C02_ReadByte(2);
}
<br><br>
<br>设置显示缓存，显示数据

<br>第1个数码管显示分钟的十位数,Min/10
<br>第2个数码管显示分钟的个位数,Min%/%10
<br>第3个和第6个数码管显示-,


<br>Nixie_SetBuf(1,Min/10);	//设置显示缓存，显示数据
Nixie_SetBuf(2,Min%10);
Nixie_SetBuf(3,11);
Nixie_SetBuf(4,Sec/10);
Nixie_SetBuf(5,Sec%10);
Nixie_SetBuf(6,11);
Nixie_SetBuf(7,MiniSec/10);
Nixie_SetBuf(8,MiniSec%10);

<br><br><br>
<br>秒表驱动函数，在中断中调用

<br>RunFlag为1时开始计时
<br>RunFlag为0时停止计时


<br>/**
  * @brief  秒表驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Sec_Loop(void)
{
	if(RunFlag)
	{
		MiniSec++;
		if(MiniSec&gt;=100)
		{
			MiniSec=0;
			Sec++;
			if(Sec&gt;=60)
			{
				Sec=0;
				Min++;
				if(Min&gt;=60)
				{
					Min=0;
				}
			}
		}
	}
}
<br><br>
<br>定时器中断函数,定时器每隔1毫秒会进入中断函数

<br>设置定时器初值,进入下一个定时
<br>每隔20毫秒调用一次按键驱动函数,扫描一次按键
<br>每隔2ms调用一次数码管驱动函数,扫描数码管
<br>每隔10ms调用一次数秒表驱动函数,使MiniSec加1


<br>void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count1,T0Count2,T0Count3;
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	
	T0Count1++;
	if(T0Count1&gt;=20)
	{
		T0Count1=0;
		Key_Loop();	//20ms调用一次按键驱动函数
	}
	
	T0Count2++;
	if(T0Count2&gt;=2)
	{
		T0Count2=0;
		Nixie_Loop();//2ms调用一次数码管驱动函数
	}
	
	T0Count3++;
	if(T0Count3&gt;=10)
	{
		T0Count3=0;
		Sec_Loop();	//10ms调用一次数秒表驱动函数
	}
}

<br>]]></description><link>2_Areas\C51单片机\储存器AT24C02.html</link><guid isPermaLink="false">2_Areas/C51单片机/储存器AT24C02.md</guid><pubDate>Sun, 27 Oct 2024 03:47:07 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-56B6E2D5795BDC0B2FB485AA3FD33502-20240919203954180.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-56B6E2D5795BDC0B2FB485AA3FD33502-20240919203954180.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[触摸屏控制器XPT2046]]></title><description><![CDATA[<a class="tag" href="?query=tag:填坑" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#填坑</a> 
 <br><br><a data-href="xpt2046中文.pdf" href="xpt2046中文.pdf" class="internal-link" target="_self" rel="noopener nofollow">xpt2046中文.pdf</a><br>
<br>XPT2046 是一款 4 线制电阻式触摸屏控制器，内含 12 位分辨率 125KHz 转换速率逐步逼近型 A/D 转换器。
<br>XPT2046 支持从 1.5V 到 5.25V 的低电压 I/O 接口。
<br>XPT2046 能通过执行两次 A/D 转换查出被按的屏幕位置， 除此之外，还可以测量加在触摸屏上的压力。
<br>XPT2046 内部自带 2.5V 参考电压，可以作为辅助输入、温度测量和电池监测之用，电池监测的电压范围可以从 0V 到 6V。
<br>XPT2046 片内集成有一个温度传感器。 在 2.7V 的典型工作状态下，关闭参考电压，功耗可小于 0.75mW。
<br>XPT2046 采用微小的封装形式：TSSOP-16,QFN-16 和 VFBGA－48。工作温度范围为-40℃～+85℃。与 ADS7846、TSC2046、AK4182A 完全兼容
<br><br>
<br>XPT2046是个SPI通信

<br>CS 片选, 每个从机单独有一根CS线与主机相连,

<br>主机通过CS选择需要通信的从机


<br>DCLK 时钟总线,
<br>DIN  从机输入总线,

<br>MOSI, 主机输入总线


<br>DOUT 从机输出总线,

<br>MISO, 主机输出总线




<br><img alt="IMG-FE7CF9F922D59E96B551A7A1EED26AF4-20240919203955029" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FE7CF9F922D59E96B551A7A1EED26AF4-20240919203955029.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-A6484B0E43113D9F9CD717F6FC4BC504-20240919203956982" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A6484B0E43113D9F9CD717F6FC4BC504-20240919203956982.png" referrerpolicy="no-referrer"><br><br><br><br>#define XPT2046_VBAT	0xAC   //光敏传感器的模拟信号
#define XPT2046_AUX		0xEC   //数字信号转换的模拟信号
#define XPT2046_XP		0x9C	//0xBC  //电位器的模拟信号
#define XPT2046_YP		0xDC  //温度传感器的模拟信号
<br><img alt="IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007.png" referrerpolicy="no-referrer"><br><br>#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

//引脚定义
sbit XPY2046_DIN=P3^4;
sbit XPY2046_CS=P3^5;
sbit XPY2046_DCLK=P3^6;
sbit XPY2046_DOUT=P3^7;
<br><img alt="IMG-F9979C9CDA0723C17005459442815CEA-20240919204000594" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F9979C9CDA0723C17005459442815CEA-20240919204000594.png" referrerpolicy="no-referrer"><br>
<a data-href="3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" href="3_Resources\Attachments\2_Areas\C51单片机\IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" class="internal-link" target="_self" rel="noopener nofollow">3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf</a>5<br><br>
<br><a href=".?query=tag:填坑" class="tag" target="_blank" rel="noopener nofollow">#填坑</a> 对SPI通信还不了解,暂时读不懂
<br>/**
  * @brief  XPT2046读取AD值
  * @param  Command 命令字，范围：头文件内定义的宏，结尾的数字表示转换的位数
  * @retval AD转换后的数字量，范围：8位为0~255，12位为0~4095
  */
unsigned int XPT2046_ReadAD(unsigned char Command)
{
	unsigned char i;
	unsigned int Data=0;
	XPY2046_DCLK=0;
	XPY2046_CS=0;
	for(i=0;i&lt;8;i++)
	{
		XPY2046_DIN=Command&amp;(0x80&gt;&gt;i);
		XPY2046_DCLK=1;
		XPY2046_DCLK=0;
	}
	for(i=0;i&lt;16;i++)
	{
		XPY2046_DCLK=1;
		XPY2046_DCLK=0;
		if(XPY2046_DOUT){Data|=(0x8000&gt;&gt;i);}
	}
	XPY2046_CS=1;
	return Data&gt;&gt;8;
}
]]></description><link>2_Areas\C51单片机\触摸屏控制器XPT2046.html</link><guid isPermaLink="false">2_Areas/C51单片机/触摸屏控制器XPT2046.md</guid><pubDate>Sun, 27 Oct 2024 03:47:05 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FE7CF9F922D59E96B551A7A1EED26AF4-20240919203955029.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FE7CF9F922D59E96B551A7A1EED26AF4-20240919203955029.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[串口通信]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=958bd49d-53fd-2f5d-c5bc-2cf5f7116659&amp;page=234&amp;rect=110.693,566.995,200.693,590.989" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=958bd49d-53fd-2f5d-c5bc-2cf5f7116659&amp;page=234&amp;rect=110.693,566.995,200.693,590.989" target="_blank">串行口通信</a><br>
<br>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。
<br>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大的扩展了单片机的应用范围，增强了单片机系统的硬件实力。
<br>51单片机内部自带UART（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现单片机的串口通信。
<br><img alt="IMG-283BD07551D60C427967EBA0A282CFEA-20240919203953278" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-283BD07551D60C427967EBA0A282CFEA-20240919203953278.png" referrerpolicy="no-referrer"><br>
串口转USB<br><img alt="IMG-64B91A20D91D6B586BCD326E88F11CCD-20240919203954299" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-64B91A20D91D6B586BCD326E88F11CCD-20240919203954299.png" referrerpolicy="no-referrer"><br>
陀螺仪模块--串口通信<br><img alt="IMG-41E0C3BCCB6EC3E3FB2A156AF520E12B-20240919203956203" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-41E0C3BCCB6EC3E3FB2A156AF520E12B-20240919203956203.png" referrerpolicy="no-referrer"><br>
蓝牙模块--串口通信<br><br>
<br>简单双向串口通信有两根通信线（发送端TXD和接收端RXD）
<br>TXD与RXD要交叉连接
<br>当只需单向的数据传输时，可以直接一根通信线
<br>当电平标准不一致时，需要加电平转换芯片
<br><img alt="IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226.png" referrerpolicy="no-referrer"><br>Tip
TXD: transmit exchange data
<br><br>
<br>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：
<br>TTL电平：+5V表示1，0V表示0
<br>RS232电平：-3~-15V表示1，+3~+15V表示0
<br>RS485电平：两线压差+2~+6V表示1，-2~-6V表示0（差分信号）
<br><br><img alt="IMG-ABA6338EE9572BBE852AFFE997266E67-20240919203958168" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ABA6338EE9572BBE852AFFE997266E67-20240919203958168.png" referrerpolicy="no-referrer"><br><img alt="IMG-FD0CBB8B516414F909C0041FBE53D6B1-20240919203958218" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FD0CBB8B516414F909C0041FBE53D6B1-20240919203958218.png" referrerpolicy="no-referrer"><br>Tip
与VGA接口相似,但功能不同.
<br><br><br><br>
<br>STC89C52有1个UART(通用异步收发器)
<br>STC89C52的UART有四种工作模式：<a data-href="2_Areas/C51单片机/串口通信#^45wguq" href="2_Areas\C51单片机\串口通信.html#^45wguq" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C51单片机/串口通信 &gt; ^45wguq</a>2<br>
模式0：同步移位寄存器<br>
模式1：8位UART，波特率可变（常用）<br>
模式2：9位UART，波特率固定<br>
模式3：9位UART，波特率可变
<br><img alt="IMG-BA962406F07B043EE248B7D0E6C5F611-20240919203959973" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BA962406F07B043EE248B7D0E6C5F611-20240919203959973.png" referrerpolicy="no-referrer"><br><br><br>
<br>SM0/FE： 

<br>当PCON寄存器中的SMOD0/PCON.6位为1时，该位用于帧错误检测。
<br>当检测到一个无效停止位时，通过UART接收器设置该位。它必须由软件清零。
<br>当PCON寄存器中的SMOD0/PCON.6位为0时，该位和SM1一起指定串行通信的工作方式，如下表所示。<img alt="IMG-7AE735AC5DE6D7CF7FDA6E5965F94ABE-20240919204006900" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-7AE735AC5DE6D7CF7FDA6E5965F94ABE-20240919204006900.png" referrerpolicy="no-referrer"> 


2<br><br>
<br>波特率：串口通信的速率（发送和接收各数据位的间隔时间）
<br>检验位：用于数据验证
<br>停止位：用于数据帧间隔
<br><img alt="IMG-90B4EE680D642B449810804007E73FA5-20240919204001696" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-90B4EE680D642B449810804007E73FA5-20240919204001696.png" referrerpolicy="no-referrer"><br>
<a data-href="2_Areas/C51单片机/串口通信#^t9gvpf" href="2_Areas\C51单片机\串口通信.html#^t9gvpf" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C51单片机/串口通信 &gt; ^t9gvpf</a> TB8/RB8<br>串口助手<br>
<img alt="IMG-68254586307B3AF4C0F7DC06F59548F0-20240919204001739" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-68254586307B3AF4C0F7DC06F59548F0-20240919204001739.png" referrerpolicy="no-referrer"><br>波特率和比特率是不一样的概念,波特率的单位是帧,比特率的单位是位.<br>数据显示模式<br>
<br>HEX模式/十六进制模式/二进制模式：以原始数据的形式显示
<br>文本模式/字符模式：以原始数据编码后的形式显示
<br>波特率计算器<br>
<img alt="IMG-4F79B20E21A5790410BBE679818A88C1-20240919204003500" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4F79B20E21A5790410BBE679818A88C1-20240919204003500.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582.png" referrerpolicy="no-referrer"><br>
<br>SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器
<br>控制中断 TI/RI<br>
<br><br>
<br>TI：发送中断请求标志位。 

<br>在方式0，当串行发送数据第8位结束时(即发送完成)，由内部硬件自动置位，即TI=1，向主机请求中断，响应中断后必须用软件复位，即TI=0。
<br>在其他方式中，则在停止位开始发送时由内部硬件置位，必须用软件复位。


<br>
<br><br>
<br>RI：接收中断请求标志位。   

<br>在方式0，当串行接收到第8位结束时(即接收完成)由内部硬件自动置位RI=1，向主机请求中断，响应中断后必须用软件复位，即RI=0。
<br>在其他方式中，串行接收到停止位的中间时刻由内部硬件置位，即RI=1（例外情况见SM2说明），必须由软件复位，即RI=0。


<br><br><img alt="IMG-6E6C775EA4CE9E595EBE46DAC99A20CA-20240919204005504" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6E6C775EA4CE9E595EBE46DAC99A20CA-20240919204005504.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=d3d700eb-c465-fc03-7ada-7465465631b1&amp;page=234&amp;rect=82.943,361.071,202.943,381.066" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=d3d700eb-c465-fc03-7ada-7465465631b1&amp;page=234&amp;rect=82.943,361.071,202.943,381.066" target="_blank">串行口相关寄存器</a><br><br><img alt="IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582.png" referrerpolicy="no-referrer"><br>
SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器<br>SBUF=Byte;    //将数据写入SBUF寄存器
<br>P1 = SBUF;    //将SBUF的数据读取到P1寄存器
<br><br><img alt="IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3F7F28E345D499D82D3DF2BBB920D61A-20240919204003582.png" referrerpolicy="no-referrer"><br>
STC89C52系列单片机的串行口设有两个控制寄存器：串行控制寄存器SCON和波特率选择特殊功能寄存器PCON。<br>
<img alt="IMG-6E519AD859AA1CD7C86112EC3C5CB106-20240919204006851" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6E519AD859AA1CD7C86112EC3C5CB106-20240919204006851.png" referrerpolicy="no-referrer"><br>
<br>SM0/FE： 

<br>当PCON寄存器中的SMOD0/PCON.6位为1时，该位用于帧错误检测。
<br>当检测到一个无效停止位时，通过UART接收器设置该位。它必须由软件清零。
<br>当PCON寄存器中的SMOD0/PCON.6位为0时，该位和SM1一起指定串行通信的工作方式，如下表所示。<img alt="IMG-7AE735AC5DE6D7CF7FDA6E5965F94ABE-20240919204006900" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-7AE735AC5DE6D7CF7FDA6E5965F94ABE-20240919204006900.png" referrerpolicy="no-referrer"> 


<br>SM2：允许方式2或方式3多机通信控制位。

<br>在方式2或方式3时，如SM2位为1，REN位为1，则从机处于只有接收到RB8位为1（地址帧）时才激活中断请求标志位RI为1，并向主机请求中断处理。被确认为寻址的丛机则复位SM2位为0，从而才接收RB8为0的数据帧。
<br>在方式1时，如果SM2位为1，则只有在接收到有效的停止位时才置位中断请求标志位RI为1；
<br>在方式0时，SM2 应为0。


<br>REN：允许/禁止串行接收控制位。

<br>由软件置位REN，即REN=1为允许串行接收状态，可启动串行接收器RxD，开始接收信息。
<br>软件复位REN，即REN=0，则禁止接收。


<br>TB8：  

<br>在方式2或方式3，它为要发送的第9位数据，按需要由软件置位或清0。
<br>例如，可用作数据的校验位或多机通信中表示地址帧/数据帧的标志位。


<br>RB8： 

<br>在方式2或方式3，是接收到的第9位数据。
<br>在方式1，若SM2=0，则RB8是接收到的停止位。方式0不用RB8。


<br>TI：发送中断请求标志位。 

<br>在方式0，当串行发送数据第8位结束时(即发送完成)，由内部硬件自动置位，即TI=1，向主机请求中断，响应中断后必须用软件复位，即TI=0。
<br>在其他方式中，则在停止位开始发送时由内部硬件置位，必须用软件复位。


<br>RI：接收中断请求标志位。   

<br>在方式0，当串行接收到第8位结束时(即接收完成)由内部硬件自动置位RI=1，向主机请求中断，响应中断后必须用软件复位，即RI=0。
<br>在其他方式中，串行接收到停止位的中间时刻由内部硬件置位，即RI=1（例外情况见SM2说明），必须由软件复位，即RI=0。


<br><a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=662ba71e-2190-5dac-c059-d739b46b76a8&amp;page=235&amp;rect=87.535,578.930,245.209,593.593" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=662ba71e-2190-5dac-c059-d739b46b76a8&amp;page=235&amp;rect=87.535,578.930,245.209,593.593" target="_blank">串行口控制寄存器SCON和PCON</a>
<br>SCON = 0x50;        //8位数据,可变波特率,即工作方式1,允许串行接收状态
<br>while(TI==0); //等待TI变为1,TI变为1后会请求中断
TI=0;         //软件复位
<br><br>因为资源有限,秉承不浪费的原则,将SMOD和SMOD0放在电源控制寄存器PCON闲置的位中.<br>电源控制寄存器PCON中的SMOD/PCON.7用于设置方式1、方式2、方式3的波特率是否加倍。<br><img alt="IMG-1CDF83AFDE304D7E1666C39AAD285525-20240919204007534" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1CDF83AFDE304D7E1666C39AAD285525-20240919204007534.png" referrerpolicy="no-referrer"><br>
<br>SMOD：波特率选择位。

<br>当用软件置位SMOD，即SMOD=1，则使串行通信方式1、2、3的波特率加倍；
<br>SMOD=0，则各工作方式的波特率加倍。
<br>复位时SMOD=0。


<br>SMOD0：帧错误检测有效控制位。

<br>当SMOD0=1，SCON寄存器中的SM0/FE位用于FE(帧错误检测)功能；
<br>当SMOD0=0，SCON寄存器中的SM0/FE位用于SM0功能,和SM1一起指定串行口的工作方式。
<br>复位时SMOD0=0


<br>PCON |= 0x80;        //使能波特率倍速位SMOD,即令SMOD =1
<br><br><img alt="IMG-33F8157E9F8D360C972F1B636015B33F-20240919204007574" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-33F8157E9F8D360C972F1B636015B33F-20240919204007574.png" referrerpolicy="no-referrer"><br>
为了方便讲解，这里使用的中断系统图是传统51单片机的图，STC89C52的中断系统图可参考手册<br>//连接中断入口
EA=1;
ES=1;
<br><br>串口接收到信号进入中断<br>void UART_Routine() interrupt 4
{
    if(RI==1)                    //如果接收标志位为1，接收到了数据
    {
        P1=~SBUF;                //读取数据，取反后输出到LED
        UART_SendByte(SBUF);    //将受到的数据发回串口
        RI=0;                    //接收标志位清0
    }
}
<br><br>设置波特率<br>
每隔1s通过串口发送一个数据并让数据增加<br>main.c<br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "UART.h"

unsigned char Sec;

void main()
{
    UART_Init();            //串口初始化
    while(1)
    {
        UART_SendByte(Sec);    //串口发送一个字节
        Sec++;                //Sec自增
        Delay(1000);        //延时1秒
    }
}

<br>UART.c<br>#include &lt;REGX52.H&gt;

/**
  * @brief  串口初始化，设置波特率, 4800bps@12.000MHz
  * @param  无
  * @retval 无
  */
void UART_Init()
{
    SCON=0x40;
    PCON |= 0x80;
    TMOD &amp;= 0x0F;        //设置定时器模式
    TMOD |= 0x20;        //设置定时器模式
    TL1 = 0xF3;        //设定定时初值
    TH1 = 0xF3;        //设定定时器重装值
    ET1 = 0;        //禁止定时器1中断
    TR1 = 1;        //启动定时器1
}

/**
  * @brief  串口发送一个字节数据
  * @param  Byte 要发送的一个字节数据
  * @retval 无
  */
void UART_SendByte(unsigned char Byte)
{
    SBUF=Byte;
    while(TI==0);
    TI=0;
}
<br><br>设置波特率并初始化<br>
死循环待机<br>
串口接收到数据时中断(需要提前连接中断入口)<br>
读取数据,控制LED<br>
将数据发回串口<br>main.c<br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "UART.h"

void main()
{
    UART_Init();        //串口初始化
    while(1)
    {
        
    }
}

void UART_Routine() interrupt 4
{
    if(RI==1)                    //如果接收标志位为1，接收到了数据
    {
        P1=~SBUF;                //读取数据，取反后输出到LED
        UART_SendByte(SBUF);    //将受到的数据发回串口
        RI=0;                    //接收标志位清0
    }
}

<br>UART.c<br>#include &lt;REGX52.H&gt;

/**
  * @brief  串口初始化，4800bps@12.000MHz
  * @param  无
  * @retval 无
  */
void UART_Init()
{
    SCON=0x50;
    PCON |= 0x80;
    TMOD &amp;= 0x0F;        //设置定时器模式
    TMOD |= 0x20;        //设置定时器模式
    TL1 = 0xF3;        //设定定时初值
    TH1 = 0xF3;        //设定定时器重装值
    ET1 = 0;        //禁止定时器1中断
    TR1 = 1;        //启动定时器1

    //连接中断入口
    EA=1;
    ES=1;
}

/**
  * @brief  串口发送一个字节数据
  * @param  Byte 要发送的一个字节数据
  * @retval 无
  */
void UART_SendByte(unsigned char Byte)
{
    SBUF=Byte;
    while(TI==0);
    TI=0;
}

/*串口中断函数模板
void UART_Routine() interrupt 4
{
    if(RI==1)
    {
        
        RI=0;
    }
}
*/

]]></description><link>2_Areas\C51单片机\串口通信.html</link><guid isPermaLink="false">2_Areas/C51单片机/串口通信.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-283BD07551D60C427967EBA0A282CFEA-20240919203953278.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-283BD07551D60C427967EBA0A282CFEA-20240919203953278.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[单片机]]></title><description><![CDATA[ 
 <br><br><br>• 单片机，英文Micro Controller Unit，简称MCU<br>
• 内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能<br>
• 单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制<br>
• 单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用<br>
• 同时，学习使用单片机是了解计算机原理与结构的最佳选择<br><br>• 单片机的使用领域已十分广泛，如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机，就能起到使产品升级换代的功效，常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等<br><br><a data-href="STC89C52.pdf" href="STC89C52.pdf" class="internal-link" target="_self" rel="noopener nofollow">STC89C52.pdf</a><br>
• 所属系列：51单片机系列<br>
• 公司：STC公司<br>
• 位数：8位<br>
• RAM：512字节<br>
• ROM：8K（Flash）<br>
• 工作频率：12MHz（本开发板使用）<br><img alt="IMG-DAB8EFFB038E80BA02A43AF5774BE19D-20240919203953280" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAB8EFFB038E80BA02A43AF5774BE19D-20240919203953280.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-4D4EEF1490FE4F486FBBCF7A1C14CCF3-20240919203954368" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4D4EEF1490FE4F486FBBCF7A1C14CCF3-20240919203954368.png" referrerpolicy="no-referrer"><br><img alt="IMG-363CFEB41561E091FEDDCAB771EE6FA7-20240919203956336" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-363CFEB41561E091FEDDCAB771EE6FA7-20240919203956336.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-ABC42995320AEFE1F557E56138DC8897-20240919203958376" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ABC42995320AEFE1F557E56138DC8897-20240919203958376.png" referrerpolicy="no-referrer"><br><img alt="IMG-427BAE188EC5FBCADF1DEDBFF9A915E0-20240919204000091" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-427BAE188EC5FBCADF1DEDBFF9A915E0-20240919204000091.png" referrerpolicy="no-referrer"><br><img alt="IMG-AAFBCFF1FDB4DBCCF9F16FF4FB76C137-20240919204001934" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-AAFBCFF1FDB4DBCCF9F16FF4FB76C137-20240919204001934.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-95D8B827C6C0C60D892857A172E7A368-20240919204003734" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-95D8B827C6C0C60D892857A172E7A368-20240919204003734.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-1112709784A0A68E69F3F23FFC459C0D-20240919204005636" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1112709784A0A68E69F3F23FFC459C0D-20240919204005636.png" referrerpolicy="no-referrer">]]></description><link>2_Areas\C51单片机\单片机.html</link><guid isPermaLink="false">2_Areas/C51单片机/单片机.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAB8EFFB038E80BA02A43AF5774BE19D-20240919203953280.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAB8EFFB038E80BA02A43AF5774BE19D-20240919203953280.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[单总线]]></title><description><![CDATA[ 
 <br><br><br>
<br>单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线
<br>一根通信线：DQ
<br>异步、半双工
<br>单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线
<br><img alt="IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279.png" referrerpolicy="no-referrer"><br><img alt="IMG-23EB6150CB5847E1A5BBB7EEC4975C58-20240919203954335" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-23EB6150CB5847E1A5BBB7EEC4975C58-20240919203954335.png" referrerpolicy="no-referrer"><br><br>
<br>设备的DQ均要配置成开漏输出模式
<br>DQ添加一个上拉电阻，阻值一般为4.7KΩ左右
<br>若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路
<br><img alt="IMG-CC34C36DC688D8293481EC11D4D41151-20240919203955306" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CC34C36DC688D8293481EC11D4D41151-20240919203955306.png" referrerpolicy="no-referrer"><br>
<br>独立供电
<br><img alt="IMG-2D512A032A2716D0AB2BC869029AF2FC-20240919203956265" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2D512A032A2716D0AB2BC869029AF2FC-20240919203956265.png" referrerpolicy="no-referrer"><br>
<br>寄生供电

<br>MOS管开关供电电路,MOS上是一个o表示低电平打开.


<br><br><br>
<br>主机将总线拉低至少480us，然后释放总线，等待15~60us后，存在的从机会拉低总线60~240us以响应主机，之后从机将释放总线
<br><img alt="IMG-9FB7BD859AB01F2187D861F24679678E-20240919203956292" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9FB7BD859AB01F2187D861F24679678E-20240919203956292.png" referrerpolicy="no-referrer"><br>
<br>Resistor pullup 由上拉电阻将总线电平拉回高位.
<br><br>
<br>主机将总线拉低60~120us，然后释放总线，表示发送0；
<br>主机将总线拉低1~15us，然后释放总线，表示发送1。
<br>从机将在总线拉低30us后（典型值）读取电平，整个时间片应大于60us
<br><img alt="IMG-3B86A2729F382641258B5D41D158B76A-20240919203958302" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3B86A2729F382641258B5D41D158B76A-20240919203958302.png" referrerpolicy="no-referrer"><br><br>
<br>主机将总线拉低1~15us，然后释放总线，并在拉低后15us内读取总线电平（尽量贴近15us的末尾），

<br>读取为低电平则为接收0，

<br>主机拉低时,从机也跟着拉低,所以15us后才被电阻拉回.


<br>读取为高电平则为接收1 ，

<br>主机拉低时,从机不跟着拉低,主机释放后总线立即被电阻拉回.




<br>整个时间片应大于60us
<br><img alt="IMG-F163B0AA2ABFC806BEA1056580AA846D-20240919204000024" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F163B0AA2ABFC806BEA1056580AA846D-20240919204000024.png" referrerpolicy="no-referrer"><br><br>
<br>连续调用8次发送一位的时序，依次发送一个字节的8位（低位在前）
<br><img alt="IMG-0AFBE3D4707A9284C78E414D649E9208-20240919204001810" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0AFBE3D4707A9284C78E414D649E9208-20240919204001810.png" referrerpolicy="no-referrer"><br><br>
<br>连续调用8次接收一位的时序，依次接收一个字节的8位（低位在前）
<br><img alt="IMG-6AEB34E2CE5D18703B3CC090549E36D5-20240919204001851" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6AEB34E2CE5D18703B3CC090549E36D5-20240919204001851.png" referrerpolicy="no-referrer"><br><br>#include &lt;REGX52.H&gt;

//引脚定义
sbit OneWire_DQ=P3^7;

/**
  * @brief  单总线初始化
  * @param  无
  * @retval 从机响应位，0为响应，1为未响应
  */
unsigned char OneWire_Init(void)
{
	unsigned char i;
	unsigned char AckBit;
	OneWire_DQ=1;
	OneWire_DQ=0;
	i = 247;while (--i);		//Delay 500us
	OneWire_DQ=1;
	i = 32;while (--i);			//Delay 70us
	AckBit=OneWire_DQ;
	i = 247;while (--i);		//Delay 500us
	return AckBit;
}

/**
  * @brief  单总线发送一位
  * @param  Bit 要发送的位
  * @retval 无
  */
void OneWire_SendBit(unsigned char Bit)
{
	unsigned char i;
	OneWire_DQ=0;
	i = 4;while (--i);			//Delay 10us
	OneWire_DQ=Bit;
	i = 24;while (--i);			//Delay 50us
	OneWire_DQ=1;
}

/**
  * @brief  单总线接收一位
  * @param  无
  * @retval 读取的位
  */
unsigned char OneWire_ReceiveBit(void)
{
	unsigned char i;
	unsigned char Bit;
	OneWire_DQ=0;
	i = 2;while (--i);			//Delay 5us
	OneWire_DQ=1;
	i = 2;while (--i);			//Delay 5us
	Bit=OneWire_DQ;
	i = 24;while (--i);			//Delay 50us
	return Bit;
}

/**
  * @brief  单总线发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void OneWire_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i&lt;8;i++)
	{
		OneWire_SendBit(Byte&amp;(0x01&lt;&lt;i));
	}
}

/**
  * @brief  单总线接收一个字节
  * @param  无
  * @retval 接收的一个字节
  */
unsigned char OneWire_ReceiveByte(void)
{
	unsigned char i;
	unsigned char Byte=0x00;
	for(i=0;i&lt;8;i++)
	{
		if(OneWire_ReceiveBit()){Byte|=(0x01&lt;&lt;i);}
	}
	return Byte;
}

]]></description><link>2_Areas\C51单片机\单总线.html</link><guid isPermaLink="false">2_Areas/C51单片机/单总线.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[定时器]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=32d9e0b3-6ba9-1cd3-90da-2fa9447bd15a&amp;page=187&amp;rect=110.693,566.428,227.693,590.422" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=32d9e0b3-6ba9-1cd3-90da-2fa9447bd15a&amp;page=187&amp;rect=110.693,566.428,227.693,590.422" target="_blank">定时器/计数器</a><br><br>• 定时器介绍：51单片机的定时器属于单片机的内部资源，其电路的连接和运转均在单片机内部完成<br>
• 定时器作用：<br>
（1）用于计时系统，可实现软件计时，或者使程序每隔一固定时间完成一项操作<br>
（2）替代长时间的Delay，提高CPU的运行效率和处理速度<br>
（…）<br><br>• 定时器个数：3个（T0、T1、T2），T0和T1与传统的51单片机兼容，T2是此型号单片机增加的资源<br>
• 注意：定时器的资源和单片机的型号是关联在一起的，不同的型号可能会有不同的定时器个数和操作方式，但一般来说，T0和T1的操作方式是所有51单片机所共有的<br><br>定时器在单片机内部就像一个小闹钟一样，根据时钟的输出信号，每隔“一秒”，计数单元的数值就增加一，当计数单元数值增加到“设定的闹钟提醒时间”时，计数单元就会向中断系统发出中断申请，产生“响铃提醒”，使程序跳转到中断服务函数中执行<br><img alt="IMG-2EC4526D0B74C85C28DB6B121638C351-20240919203953280" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2EC4526D0B74C85C28DB6B121638C351-20240919203953280.png" referrerpolicy="no-referrer"><br><br>• 寄存器是连接软硬件的媒介<br>
• 在单片机中寄存器就是一段特殊的RAM存储器，一方面，寄存器可以存储和读取数据，另一方面，每一个寄存器背后都连接了一根导线，控制着电路的连接方式<br>
• 寄存器相当于一个复杂机器的“操作按钮”<br><img alt="IMG-F94BDF6B292C169D7C100EF1655E40F0-20240919203954399" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F94BDF6B292C169D7C100EF1655E40F0-20240919203954399.png" referrerpolicy="no-referrer"><br><img alt="IMG-A1E365FE7201D2352551968E0F4C733B-20240919203954419" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A1E365FE7201D2352551968E0F4C733B-20240919203954419.png" referrerpolicy="no-referrer"><br><br>• STC89C52的T0和T1均有四种工作模式：<br>
模式0：13位定时器/计数器<br>
模式1：16位定时器/计数器（常用）<br>
模式2：8位自动重装模式,另外八位用于储存提醒时间,自动重装<br>
模式3：两个8位计数器<br>
• 工作模式1框图：<br>
<img alt="IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-EDA2905168FDD7FFEBB42FB333D51BE4-20240919203956412" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EDA2905168FDD7FFEBB42FB333D51BE4-20240919203956412.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-3B0E27EDE21D82E2D3EB95BB52547D16-20240919203958447" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3B0E27EDE21D82E2D3EB95BB52547D16-20240919203958447.png" referrerpolicy="no-referrer"><img alt="IMG-24721BE573530A2DAF89A3470BD7F0CC-20240919203958492" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-24721BE573530A2DAF89A3470BD7F0CC-20240919203958492.png" referrerpolicy="no-referrer"><img alt="IMG-753C846276E6AB6D28F2878B34798BAB-20240919204000143" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-753C846276E6AB6D28F2878B34798BAB-20240919204000143.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=5e5962f4-c15f-e770-7047-20ca4951a3c4&amp;page=189&amp;rect=87.535,577.723,270.256,592.386" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=5e5962f4-c15f-e770-7047-20ca4951a3c4&amp;page=189&amp;rect=87.535,577.723,270.256,592.386" target="_blank">定时器/计数器工作模式寄存器/计数器工作模式寄存器TMOD</a>
<br>设置为工作模式1:16位定时器<br>    TMOD &amp;= 0xF0;        //设置定时器模式--把TMOD的低四位清零,而高四位不变
    TMOD |= 0x01;        //设置定时器模式--修改TMOD的低四位,高四位不变
<br><br><br><img alt="IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382.png" referrerpolicy="no-referrer"><br>• SYSclk：系统时钟，即晶振周期，本开发板上的晶振为11.0592MHz<br>Tip
1MHz = 1000000Hz,1秒 = 1000000微秒
<br>晶振产生的振荡信号除12变成固定周期的脉冲信号,该脉冲信号就是定时器的时钟信号,周期为1微秒.每过1微秒,计数器加1<br>晶振为11.0592MHz时定时1毫秒的代码<br>void Timer0Init(void)        //1毫秒@11.0592MHz
{
    //AUXR &amp;= 0x7F;        //定时器时钟12T模式, STC89C52只有这一种时钟模式
    TMOD &amp;= 0xF0;        //设置定时器模式
    TMOD |= 0x01;        //设置定时器模式
    TL0 = 0x66;        //设置定时初值
    TH0 = 0xFC;        //设置定时初值
    TF0 = 0;        //清除TF0标志
    TR0 = 1;        //定时器0开始计时
}
<br><br><img alt="IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382.png" referrerpolicy="no-referrer"><br>
TL0,THO为计数寄存器,可以记两个字节,最多可以存65535个数.<br>脉冲信号的周期为1微秒,存在误差.每接收一个脉冲信号,计数器加1,直到加到最大值65535.继续加1,内存溢出到TF0,计数寄存器全部变为0.TF0为1,控制中断,<br>Tip
计数单元计数范围为0-65535, 每过1微秒,计数器加1.为了尽快计满溢出,产生中断,需要设置计数初值.如设定1毫秒后中断,应当令初值为64535,即TH0 = 64535/256;TL0 = 64535%256;
<br>设置定时初值并开始计时<br>TL0 = 0x66;        //设置定时初值
TH0 = 0xFC;        //设置定时初值
<br><br><img alt="IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6021D26F3768565D6EABC7193A628C72-20240919203956382.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-AE2C44735DD725A4D5A37DF49434E464-20240919204000317" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-AE2C44735DD725A4D5A37DF49434E464-20240919204000317.png" referrerpolicy="no-referrer"><br>
<br>T1

<br>TF1:  定时器/计数器T1溢出标志。

<br>T1被允许计数以后，从初值开始加1计数。
<br>当最高位产生溢出时由硬件置“1”TF1，向CPU请求中断，一直保持到CPU响应中断时，才由硬件清“0”TF1（TF1也可由程序查询清“0”）。


<br>TR1: 定时器T1的运行控制位。

<br>该位由软件置位和清零。
<br>当GATE（TMOD.7）=0，TR1=1时就允许T1开始计数，TR1=0时禁止T1计数。
<br>当GATE（TMOD.7）=1，TR1=1且INT1输入高电平时，才允许T1计数。




<br>T0

<br>TF0：定时器/计数器T0溢出中断标志。

<br>T0被允许计数以后，从初值开始加1计数，当最高位产生溢出时，由硬件置“1”TF0，向CPU请求中断，一直保持CPU响应该中断时，才由硬件清“0”TF0（ TF0也可由程序查询清“0”）。


<br>TR0:  定时器T0的运行控制位。

<br>该位由软件置位和清零。
<br>当GATE（TMOD.3）=0，TR0=1时就允许T0开始计数，TR0=0时禁止T0计数。
<br>当GATE（TMOD.3）=1，TR0=0且INT0输入高电平时，才允许T0计数。




<br>外部中断1

<br>IE1：

<br>外部中断1请求源（INT1/P3.3）标志。IE1=1，外部中断向CPU请求中断，当CPU响应该中断时由硬件清“0”IE1。


<br>IT1：

<br>外部中断1触发方式控制位。IT1=0时，外部中断1为低电平触发方式，当INT1（P3.3）输入低电平时，置位IE1   。采用低电平触发方式时，外部中断源（输入到INT1）必须保持低电平有效，直到该中断被CPU   响应，同时在该中断服务程序执行完之前，外部中断源必须被清除(P3.3要变高)，否则将产生另一次中断。当IT1=1时，则外部中断1(INT1)端口由“1”→“0”下降沿跳变，激活中断请求标志位IE1   ，向主机请求中断处理。




<br>外部中断0

<br>IE0：

<br>外部中断0请求源（INT0/P3.2）标志。IE0=1外部中断0向CPU请求中断，当CPU响应外部中断时，由硬件清“0”IE0（边沿触发方式）。


<br>IT0：

<br>外部中断0触发方式控制位。IT0=0时，外部中断0为低电平触发方式，当INT0（P3.2）输入低电平时，置位IE0。采用低电平触发方式时，外部中断源（输入到INT0）必须保持低电平有效，直到该中断被CPU响应，同时在该中断服务程序执行完之前，外部中断源必须被清除（P3.2要变高），否则将产生另一次中断。当IT0=1时，则外部中断0(INT0)端口由“1”→“0”下降沿跳变，激活中断请求标志位IE0   ，向主机请求中断处理。




<br><a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=0f7553cd-a314-da30-ee42-6d71ff98409a&amp;page=188&amp;rect=87.535,576.096,245.814,590.759" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=0f7553cd-a314-da30-ee42-6d71ff98409a&amp;page=188&amp;rect=87.535,576.096,245.814,590.759" target="_blank">定时器/计数器控制寄存器TCON</a><br>Tip
可位寻址可以单独给一位赋值,不可位寻址只能整体赋值
<br>TF0 = 0;        //清除TF0标志
TR0 = 1;        //定时器0开始计时
<br><br><br><br><br><a data-href="2_Areas/C51单片机/定时器" href="2_Areas\C51单片机\定时器.html" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C51单片机/定时器</a>5是一种中断源<br>
<img alt="IMG-01FD2CB989FA616C3B73D40DD48B548A-20240919204007416" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-01FD2CB989FA616C3B73D40DD48B548A-20240919204007416.png" referrerpolicy="no-referrer"><br>为了方便讲解，这里使用的中断系统图是传统51单片机的图，STC89C52的中断系统图可参考手册2<br><br><br><br>• 中断源个数：8个（外部中断0 INT0、定时器0中断 Timer 0、外部中断1 INT1、定时器1中断 Timer1、串口中断 UART、定时器2中断 Timer2、外部中断2 INT2、外部中断3 INT3）<br>
• 中断优先级个数：4个<br>
• 中断号：<img alt="IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093.png" referrerpolicy="no-referrer"><br>
• 注意：中断的资源和单片机的型号是关联在一起的，不同的型号可能会有不同的中断资源，例如中断源个数不同、中断优先级个数不同等等<br><br><img alt="IMG-700CFCA8AC732B12C35E68A68D667EDA-20240919203957901" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-700CFCA8AC732B12C35E68A68D667EDA-20240919203957901.png" referrerpolicy="no-referrer"><br>
自然优先级<br>
<img alt="IMG-FAF9F1CC3C5959C3132C3996247A6206-20240919203957957" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FAF9F1CC3C5959C3132C3996247A6206-20240919203957957.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=989d3aa1-f461-0b9e-d53e-d631b1c6d12f&amp;page=166&amp;rect=82.943,574.095,157.943,594.090" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=989d3aa1-f461-0b9e-d53e-d631b1c6d12f&amp;page=166&amp;rect=82.943,574.095,157.943,594.090" target="_blank">中断优先级</a>
2<br><br><br>/**
  * @brief  定时器0初始化，1毫秒@12.000MHz
  * @param  无
  * @retval 无
  */
void Timer0Init(void)
{
    TMOD &amp;= 0xF0;        //设置定时器模式
    TMOD |= 0x01;        //设置定时器模式
    TL0 = 0x18;        //设置定时初值
    TH0 = 0xFC;        //设置定时初值
    TF0 = 0;        //清除TF0标志
    TR0 = 1;        //定时器0开始计时

    //连通定时器到中断入口路径
    ET0=1;
    EA=1;
    PT0=0;
}
<br><br>ET0=1;EA=1;PT0=0; 连接的低级中断入口<br><br>/*定时器中断函数模板
void Timer0_Routine() interrupt 1
{
    static unsigned int T0Count;
    TL0 = 0x18;        //设置定时初值
    TH0 = 0xFC;        //设置定时初值
    T0Count++;
    if(T0Count&gt;=1000)
    {
        T0Count=0;
        
    }
}
*/

<br><br><br>
<br>这里的定时器只产生周期信号,用于分析信号
<br>定时器启动后,计数器寄存器中的值会自动增加

<br>晶振为11.0592MHz每过1微秒,计数器加1


<br>如果从0启动,根据晶振的频率和计数器值的大小可以判断开始计数到此时的时间间隔.
<br>根据这个间隔就可以分析出接收到的是哪种信号
<br>#include &lt;REGX52.H&gt;

/**
  * @brief  定时器0初始化
  * @param  无
  * @retval 无
  */
void Timer0_Init(void)
{
	TMOD &amp;= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0;		//设置定时初值
	TH0 = 0;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 0;		//定时器0不计时
}
<br><br>/**
  * @brief  定时器0设置计数器值
  * @param  Value，要设置的计数器值，范围：0~65535
  * @retval 无
  */
void Timer0_SetCounter(unsigned int Value)
{
	TH0=Value/256;
	TL0=Value%256;
}
<br><br>/**
  * @brief  定时器0获取计数器值
  * @param  无
  * @retval 计数器值，范围：0~65535
  */
unsigned int Timer0_GetCounter(void)
{
	return (TH0&lt;&lt;8)|TL0;
}
<br><br>/**
  * @brief  定时器0启动停止控制
  * @param  Flag 启动停止标志，1为启动，0为停止
  * @retval 无
  */
void Timer0_Run(unsigned char Flag)
{
	TR0=Flag;
}
<br><br>初始化P2引脚,先让1个灯亮<br>
初始化定时器<br>根据按键切换流水灯运动方向<br>
循环结构<br>
获取按键码<br>
判断按键码<br>
执行相应操作<br>定时器初始化函数<br>定时器中断函数<br><img alt="IMG-E2A8418F788AE3AF208DCA9A930416D4-20240919204002007" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E2A8418F788AE3AF208DCA9A930416D4-20240919204002007.gif" referrerpolicy="no-referrer"><br><br>main.c<br>#include &lt;REGX52.H&gt;
#include "Timer0.h"
#include "Key.h"
#include &lt;INTRINS.H&gt;

unsigned char KeyNum,LEDMode;

void main()
{
    P2=0xFE;
    Timer0Init();
    while(1)
    {
        KeyNum=Key();        //获取独立按键键码
        if(KeyNum)            //如果按键按下
        {
            if(KeyNum==1)    //如果K1按键按下
            {
                LEDMode++;    //模式切换
                if(LEDMode&gt;=2)LEDMode=0;
            }
        }
    }
}
<br><br>void Timer0_Routine() interrupt 1
{
    static unsigned int T0Count;
    TL0 = 0x18;        //设置定时初值
    TH0 = 0xFC;        //设置定时初值
    T0Count++;        //T0Count计次，对中断频率进行分频
    if(T0Count&gt;=500)//分频500次，500ms
    {
        T0Count=0;
        if(LEDMode==0)            //模式判断
            P2=_crol_(P2,1);    //LED输出
        if(LEDMode==1)
            P2=_cror_(P2,1);
    }
}
<br><br>定义时分秒的初始数值<br>
LCD初始化<br>
定时器初始化<br>
显示静态字符串<br>
显示时分秒<br>
中断 让时分秒改变<br>LCD初始化函数<br>
LCD显示函数<br>
定时器初始化函数<br>
定时器中断函数<br>效果:<br>
<img alt="IMG-3BA66D98DDFA2D95640D8E9D3D21379E-20240919204003813" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3BA66D98DDFA2D95640D8E9D3D21379E-20240919204003813.gif" referrerpolicy="no-referrer"><br><br>main.c<br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "Timer0.h"

unsigned char Sec=55,Min=59,Hour=23;

void main()
{
    LCD_Init();
    Timer0Init();
    
    LCD_ShowString(1,1,"Clock:");    //上电显示静态字符串
    LCD_ShowString(2,1,"  :  :");
    
    while(1){
    
    }
}
<br><br>LCD_ShowNum(2,1,Hour,2);    //显示时分秒
LCD_ShowNum(2,4,Min,2);
LCD_ShowNum(2,7,Sec,2);
<br><br>void Timer0_Routine() interrupt 1
{
    static unsigned int T0Count;  //定义静态变量--函数结束后不消失
    TL0 = 0x18;        //设置定时初值
    TH0 = 0xFC;        //设置定时初值
    T0Count++;
    if(T0Count&gt;=1000)    //定时器分频，1s
    {
        T0Count=0;
        Sec++;            //1秒到，Sec自增
        if(Sec&gt;=60)
        {
            Sec=0;        //60秒到，Sec清0，Min自增
            Min++;
            if(Min&gt;=60)
            {
                Min=0;    //60分钟到，Min清0，Hour自增
                Hour++;
                if(Hour&gt;=24)
                {
                    Hour=0;    //24小时到，Hour清0
                }
            }
        }
    }
}

]]></description><link>2_Areas\C51单片机\定时器.html</link><guid isPermaLink="false">2_Areas/C51单片机/定时器.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2EC4526D0B74C85C28DB6B121638C351-20240919203953280.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2EC4526D0B74C85C28DB6B121638C351-20240919203953280.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[蜂鸣器]]></title><description><![CDATA[<a class="tag" href="?query=tag:电子" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#电子</a> <a class="tag" href="?query=tag:元器件" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#元器件</a> 
 <br><a href=".?query=tag:电子" class="tag" target="_blank" rel="noopener nofollow">#电子</a> <a href=".?query=tag:元器件" class="tag" target="_blank" rel="noopener nofollow">#元器件</a>  <br><br>蜂鸣器为一种发声元器件。而蜂鸣器分为有源蜂鸣器和无源蜂鸣器。（注意:这里的"源"不是指电源，而是指震荡源。）<br>
有源蜂鸣器内部带震荡源，只要一通电就会叫。<br>
而无源内部不带震荡源，所以如果用直流信号无法令其鸣叫。必须用2K-5K的方波去驱动它。<br>单片机驱动无源蜂鸣器的方式有两种:一种是PWM 输出口直接驱动，另一种是利用I/O 定时翻转电平产生驱动波形对蜂鸣器进行驱动。<br><br>有源蜂鸣器与无源蜂鸣器的区别如图：<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F58302F9B132AB8164D8632B56925BE2-20240919203953296.png" referrerpolicy="no-referrer"><br>有源蜂鸣器底部为黑胶，而无源蜂鸣器底部可见绿色电路板。无论有源还是无源蜂鸣器都是标注了“+”的引脚为正脚。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-21DCF8CD8FAE45631867E64198B72DD5-20240919203954968.png" referrerpolicy="no-referrer"><br><br><br><br><img alt="IMG-569CE42631CFA9E59F4B5BC12422043E-20240919203956940" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-569CE42631CFA9E59F4B5BC12422043E-20240919203956940.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-FD7A30CFC3FCBCB3F22635F000EE75E4-20240919203959255" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FD7A30CFC3FCBCB3F22635F000EE75E4-20240919203959255.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-A918108091E2359BBC250D83233A1336-20240919204000884" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A918108091E2359BBC250D83233A1336-20240919204000884.png" referrerpolicy="no-referrer"><br><img alt="IMG-47410A10239C552B9A661C49061DDBD3-20240919204002556" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-47410A10239C552B9A661C49061DDBD3-20240919204002556.png" referrerpolicy="no-referrer"><br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Buzzer.h"

unsigned char KeyNum;

void main()
{
	Nixie(1,0);
	while(1)
	{

	}
}
<br><br>KeyNum=Key();
if(KeyNum)
{
    Buzzer_Time(100);
    Nixie(1,KeyNum);
}
<br><br>#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

//蜂鸣器端口：
sbit Buzzer=P2^5;
<br><br>/**
  * @brief  蜂鸣器私有延时函数，延时500us
  * @param  无
  * @retval 无
  */
void Buzzer_Delay500us()		//@12.000MHz
{
	unsigned char i;

	_nop_();
	i = 247;
	while (--i);
}
<br><br>/**
  * @brief  蜂鸣器发声
  * @param  ms 发声的时长，范围：0~32767
  * @retval 无
  */
void Buzzer_Time(unsigned int ms)
{
	unsigned int i;
	for(i=0;i&lt;ms*2;i++)
	{
		Buzzer=!Buzzer;
		Buzzer_Delay500us();
	}
}

<br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "Timer0.h"

//蜂鸣器端口定义
sbit Buzzer=P2^5;
<br><br>//播放速度，值为四分音符的时长(ms)
#define SPEED	500

//音符与索引对应表，P：休止符，L：低音，M：中音，H：高音，下划线：升半音符号#
#define P	0
#define L1	1
#define L1_	2
#define L2	3
#define L2_	4
#define L3	5
#define L4	6
#define L4_	7
#define L5	8
#define L5_	9
#define L6	10
#define L6_	11
#define L7	12
#define M1	13
#define M1_	14
#define M2	15
#define M2_	16
#define M3	17
#define M4	18
#define M4_	19
#define M5	20
#define M5_	21
#define M6	22
#define M6_	23
#define M7	24
#define H1	25
#define H1_	26
#define H2	27
#define H2_	28
#define H3	29
#define H4	30
#define H4_	31
#define H5	32
#define H5_	33
#define H6	34
#define H6_	35
#define H7	36
<br><br>//索引与频率对照表
unsigned int FreqTable[]={
	0,
	63628,63731,63835,63928,64021,64103,64185,64260,64331,64400,64463,64528,
	64580,64633,64684,64732,64777,64820,64860,64898,64934,64968,65000,65030,
	65058,65085,65110,65134,65157,65178,65198,65217,65235,65252,65268,65283,
};
<br><br>//乐谱
unsigned char code Music[]={
	//音符,时值,
	
	//1
	P,	4,
	P,	4,
	P,	4,
	M6,	2,
	M7,	2,
	
	H1,	4+2,
	M7,	2,
	H1,	4,
	H3,	4,
	
	M7,	4+4+4,
	M3,	2,
	M3,	2,
	
	//2
	M6,	4+2,
	M5,	2,
	M6, 4,
	H1,	4,
	
	M5,	4+4+4,
	M3,	4,
	
	M4,	4+2,
	M3,	2,
	M4,	4,
	H1,	4,
	
	//3
	M3,	4+4,
	P,	2,
	H1,	2,
	H1,	2,
	H1,	2,
	
	M7,	4+2,
	M4_,2,
	M4_,4,
	M7,	4,
	
	M7,	8,
	P,	4,
	M6,	2,
	M7,	2,
	
	//4
	H1,	4+2,
	M7,	2,
	H1,	4,
	H3,	4,
	
	M7,	4+4+4,
	M3,	2,
	M3,	2,
	
	M6,	4+2,
	M5,	2,
	M6, 4,
	H1,	4,
	
	//5
	M5,	4+4+4,
	M2,	2,
	M3,	2,
	
	M4,	4,
	H1,	2,
	M7,	2+2,
	H1,	2+4,
	
	H2,	2,
	H2,	2,
	H3,	2,
	H1,	2+4+4,
	
	//6
	H1,	2,
	M7,	2,
	M6,	2,
	M6,	2,
	M7,	4,
	M5_,4,
	
	
	M6,	4+4+4,
	H1,	2,
	H2,	2,
	
	H3,	4+2,
	H2,	2,
	H3,	4,
	H5,	4,
	
	//7
	H2,	4+4+4,
	M5,	2,
	M5,	2,
	
	H1,	4+2,
	M7,	2,
	H1,	4,
	H3,	4,
	
	H3,	4+4+4+4,
	
	//8
	M6,	2,
	M7,	2,
	H1,	4,
	M7,	4,
	H2,	2,
	H2,	2,
	
	H1,	4+2,
	M5,	2+4+4,
	
	H4,	4,
	H3,	4,
	H3,	4,
	H1,	4,
	
	//9
	H3,	4+4+4,
	H3,	4,
	
	H6,	4+4,
	H5,	4,
	H5,	4,
	
	H3,	2,
	H2,	2,
	H1,	4+4,
	P,	2,
	H1,	2,
	
	//10
	H2,	4,
	H1,	2,
	H2,	2,
	H2,	4,
	H5,	4,
	
	H3,	4+4+4,
	H3,	4,
	
	H6,	4+4,
	H5,	4+4,
	
	//11
	H3,	2,
	H2,	2,
	H1,	4+4,
	P,	2,
	H1,	2,
	
	H2,	4,
	H1,	2,
	H2,	2+4,
	M7,	4,
	
	M6,	4+4+4,
	P,	4,
	
	0xFF	//终止标志
};
<br><br>unsigned char FreqSelect,MusicSelect;

void main()
{
	Timer0Init();
	while(1)
	{

	}
}
<br><br>if(Music[MusicSelect]!=0xFF)	//如果不是停止标志位
{
    FreqSelect=Music[MusicSelect];	//选择音符对应的频率
    MusicSelect++;
    Delay(SPEED/4*Music[MusicSelect]);	//选择音符对应的时值
    MusicSelect++;
    TR0=0;
    Delay(5);	//音符间短暂停顿
    TR0=1;
}
else	//如果是停止标志位
{
    TR0=0;
    while(1);
}
<br><br>void Timer0_Routine() interrupt 1
{
	if(FreqTable[FreqSelect])	//如果不是休止符
	{
		/*取对应频率值的重装载值到定时器*/
		TL0 = FreqTable[FreqSelect]%256;		//设置定时初值
		TH0 = FreqTable[FreqSelect]/256;		//设置定时初值
		Buzzer=!Buzzer;	//翻转蜂鸣器IO口
	}
}
<br><br><img alt="IMG-9FA93A15E1E5955B6626D11F8459B44B-20240919204002610" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9FA93A15E1E5955B6626D11F8459B44B-20240919204002610.png" referrerpolicy="no-referrer"><br><img alt="IMG-9598B39FBA60DAC743133BD3D516BD77-20240919204004543" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9598B39FBA60DAC743133BD3D516BD77-20240919204004543.png" referrerpolicy="no-referrer"><br><img alt="IMG-8AB3B3E65186E74788ABC24029E52BA6-20240919204006438" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8AB3B3E65186E74788ABC24029E52BA6-20240919204006438.jpg" referrerpolicy="no-referrer"><br><br>#include "stm32f10x.h"                  // Device header
#include "Delay.h"

int main(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //输出模式为
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
	
	while (1)
	{

	}
}

<br><br>GPIO_WriteBit(GPIOB, GPIO_Pin_12, Bit_RESET);
Delay_ms(100);
GPIO_WriteBit(GPIOB, GPIO_Pin_12, Bit_SET);
Delay_ms(100);
GPIO_WriteBit(GPIOB, GPIO_Pin_12, Bit_RESET);
Delay_ms(100);
GPIO_WriteBit(GPIOB, GPIO_Pin_12, Bit_SET);
Delay_ms(700);
<br><br><br>#include "stm32f10x.h"                  // Device header

void Buzzer_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
	
	GPIO_SetBits(GPIOB, GPIO_Pin_12);
}
<br><br>void Buzzer_ON(void)
{
	GPIO_ResetBits(GPIOB, GPIO_Pin_12);
}

void Buzzer_OFF(void)
{
	GPIO_SetBits(GPIOB, GPIO_Pin_12);
}

void Buzzer_Turn(void)
{
	if (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == 0)
	{
		GPIO_SetBits(GPIOB, GPIO_Pin_12);
	}
	else
	{
		GPIO_ResetBits(GPIOB, GPIO_Pin_12);
	}
}

]]></description><link>2_Areas\C51单片机\蜂鸣器.html</link><guid isPermaLink="false">2_Areas/C51单片机/蜂鸣器.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F58302F9B132AB8164D8632B56925BE2-20240919203953296.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F58302F9B132AB8164D8632B56925BE2-20240919203953296.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[红外遥控简介]]></title><description><![CDATA[ 
 <br><br>• 红外遥控是利用红外光进行通信的设备，由红外LED将调制后的信号发出，由专用的红外接收头进行解调输出<br>
• 通信方式：单工，异步<br>
• 红外LED波长：940nm<br>
• 通信协议标准：NEC标准<br><img alt="IMG-E3993057A04F4A73B2003D9E7E04FD47-20240919203953295" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E3993057A04F4A73B2003D9E7E04FD47-20240919203953295.png" referrerpolicy="no-referrer"><br><img alt="IMG-117E36A875D2615C46B221748C266CEF-20240919203954868" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-117E36A875D2615C46B221748C266CEF-20240919203954868.png" referrerpolicy="no-referrer"><br><img alt="IMG-7C3D7DC919087C349833A5E977D24F0D-20240919203954892" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-7C3D7DC919087C349833A5E977D24F0D-20240919203954892.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-617564BCF57947E9AFF33E91089F8179-20240919203956869" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-617564BCF57947E9AFF33E91089F8179-20240919203956869.png" referrerpolicy="no-referrer"><br>
红外线发送电路<br><img alt="IMG-DA0400790F792D9680690651EE1B9C29-20240919203959160" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DA0400790F792D9680690651EE1B9C29-20240919203959160.png" referrerpolicy="no-referrer"><br>红外线接收电路<br>
输出端接在外部中断上<br><br>• 空闲状态：红外LED不亮，接收头输出高电平<br>
• 发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平<br>
• 发送高电平：红外LED不亮，接收头输出高电平<br><img alt="IMG-6AFD2031C5E1E3ECD4CC6C35C33D55A9-20240919204000777" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6AFD2031C5E1E3ECD4CC6C35C33D55A9-20240919204000777.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-ADFAFC8177B81929111D69E4DAA7FC18-20240919204002458" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ADFAFC8177B81929111D69E4DAA7FC18-20240919204002458.png" referrerpolicy="no-referrer"><br>
低位在前, 高位在后<br><img alt="IMG-F6B43E7945C43713CB372E47382E1C4E-20240919204002500" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F6B43E7945C43713CB372E47382E1C4E-20240919204002500.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-EAE3341B7A6211FC6913CC53569DE5C4-20240919204004435" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EAE3341B7A6211FC6913CC53569DE5C4-20240919204004435.png" referrerpolicy="no-referrer"><br><br><br><br><br>
#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "IR.h"

unsigned char Num;
unsigned char Address;
unsigned char Command;

void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"ADDR  CMD  NUM");
	LCD_ShowString(2,1,"00    00   000");
	
	IR_Init();
	
	while(1)
	{

	
	}
}

<br><br>if(IR_GetDataFlag() || IR_GetRepeatFlag())	//如果收到数据帧或者收到连发帧
{
    Address=IR_GetAddress();		//获取遥控器地址码
    Command=IR_GetCommand();		//获取遥控器命令码
    
    LCD_ShowHexNum(2,1,Address,2);	//显示遥控器地址码
    LCD_ShowHexNum(2,7,Command,2);	//显示遥控器命令码
    
    if(Command==IR_VOL_MINUS)		//如果遥控器VOL-按键按下
    {
        Num--;						//Num自减
    }
    if(Command==IR_VOL_ADD)			//如果遥控器VOL+按键按下
    {
        Num++;						//Num自增
    }
    
    LCD_ShowNum(2,12,Num,3);		//显示Num
}
<br><br><br>
#define IR_POWER		0x45
#define IR_MODE			0x46
#define IR_MUTE			0x47
#define IR_START_STOP	0x44
#define IR_PREVIOUS		0x40
#define IR_NEXT			0x43
#define IR_EQ			0x07
#define IR_VOL_MINUS	0x15
#define IR_VOL_ADD		0x09
#define IR_0			0x16
#define IR_RPT			0x19
#define IR_USD			0x0D
#define IR_1			0x0C
#define IR_2			0x18
#define IR_3			0x5E
#define IR_4			0x08
#define IR_5			0x1C
#define IR_6			0x5A
#define IR_7			0x42
#define IR_8			0x52
#define IR_9			0x4A
<br><br>#include &lt;REGX52.H&gt;
#include "Timer0.h"
#include "Int0.h"

unsigned int IR_Time;
unsigned char IR_State;

unsigned char IR_Data[4];
unsigned char IR_pData;

unsigned char IR_DataFlag;
unsigned char IR_RepeatFlag;
unsigned char IR_Address;
unsigned char IR_Command;
<br><br>
<br>初始化定时器
<br>初始化外部中断
<br>/**
  * @brief  红外遥控初始化
  * @param  无
  * @retval 无
  */
void IR_Init(void)
{
	Timer0_Init();
	Int0_Init();
}

<br><br>/**
  * @brief  红外遥控获取收到数据帧标志位
  * @param  无
  * @retval 是否收到数据帧，1为收到，0为未收到
  */
unsigned char IR_GetDataFlag(void)
{
	if(IR_DataFlag)
	{
		IR_DataFlag=0;
		return 1;
	}
	return 0;
}
<br><br>
/**
  * @brief  红外遥控获取收到连发帧标志位
  * @param  无
  * @retval 是否收到连发帧，1为收到，0为未收到
  */
unsigned char IR_GetRepeatFlag(void)
{
	if(IR_RepeatFlag)
	{
		IR_RepeatFlag=0;
		return 1;
	}
	return 0;
}
<br><br>/**
  * @brief  红外遥控获取收到的地址数据
  * @param  无
  * @retval 收到的地址数据
  */
unsigned char IR_GetAddress(void)
{
	return IR_Address;
}
<br><br>/**
  * @brief  红外遥控获取收到的命令数据
  * @param  无
  * @retval 收到的命令数据
  */
unsigned char IR_GetCommand(void)
{
	return IR_Command;
}
<br><br>
<br>外部中断触发后
<br>如果红外接收器空闲,重启定时计数器,红外接收器等待
<br>在等待时判断Start信号或Repeat信号

<br>通过中断间隔时间判断
<br>间隔时间从定时器的计数器获得


<br>如果接收到Start信号,进入接收数据状态

<br>同样通过中断间隔判断收到的数据位是0或1
<br>直到接收到了32位数据,验证无误后转存数据,停止定时器,接收器进入空闲状态


<br>如果接收到Repeat信号,停止定时器,接收器进入空闲状态
<br>如果接收到其他信号继续等待
<br>//外部中断0中断函数，下降沿触发执行
void Int0_Routine(void) interrupt 0
{
	if(IR_State==0)				//状态0，空闲状态
	{
		Timer0_SetCounter(0);	//定时计数器清0
		Timer0_Run(1);			//定时器启动
		IR_State=1;				//置状态为1
	}
	else if(IR_State==1)		//状态1，等待Start信号或Repeat信号
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为13.5ms，则接收到了Start信号（判定值在12MHz晶振下为13500，在11.0592MHz晶振下为12442）
		if(IR_Time&gt;12442-500 &amp;&amp; IR_Time&lt;12442+500)
		{
			IR_State=2;			//置状态为2
		}
		//如果计时为11.25ms，则接收到了Repeat信号（判定值在12MHz晶振下为11250，在11.0592MHz晶振下为10368）
		else if(IR_Time&gt;10368-500 &amp;&amp; IR_Time&lt;10368+500)
		{
			IR_RepeatFlag=1;	//置收到连发帧标志位为1
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
		else					//接收出错
		{
			IR_State=1;			//置状态为1
		}
	}
	else if(IR_State==2)		//状态2，接收数据
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为1120us，则接收到了数据0（判定值在12MHz晶振下为1120，在11.0592MHz晶振下为1032）
		if(IR_Time&gt;1032-500 &amp;&amp; IR_Time&lt;1032+500)
		{
			IR_Data[IR_pData/8]&amp;=~(0x01&lt;&lt;(IR_pData%8));	//数据对应位清0
			IR_pData++;			//数据位置指针自增
		}
		//如果计时为2250us，则接收到了数据1（判定值在12MHz晶振下为2250，在11.0592MHz晶振下为2074）
		else if(IR_Time&gt;2074-500 &amp;&amp; IR_Time&lt;2074+500)
		{
			IR_Data[IR_pData/8]|=(0x01&lt;&lt;(IR_pData%8));	//数据对应位置1
			IR_pData++;			//数据位置指针自增
		}
		else					//接收出错
		{
			IR_pData=0;			//数据位置指针清0
			IR_State=1;			//置状态为1
		}
		if(IR_pData&gt;=32)		//如果接收到了32位数据
		{
			IR_pData=0;			//数据位置指针清0
			if((IR_Data[0]==~IR_Data[1]) &amp;&amp; (IR_Data[2]==~IR_Data[3]))	//数据验证
			{
				IR_Address=IR_Data[0];	//转存数据
				IR_Command=IR_Data[2];
				IR_DataFlag=1;	//置收到连发帧标志位为1
			}
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
	}
}

<br><br><br>
<br>红外接收器接收到的Start信号开始就是下降沿,这是会产生中断,直到Start信号结束时会产生一个下降沿,再次产生中断

<br><img alt="IMG-ADFAFC8177B81929111D69E4DAA7FC18-20240919204002458" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ADFAFC8177B81929111D69E4DAA7FC18-20240919204002458.png" referrerpolicy="no-referrer">


<br>]]></description><link>2_Areas\C51单片机\红外遥控.html</link><guid isPermaLink="false">2_Areas/C51单片机/红外遥控.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E3993057A04F4A73B2003D9E7E04FD47-20240919203953295.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E3993057A04F4A73B2003D9E7E04FD47-20240919203953295.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[计算机的组成原理]]></title><description><![CDATA[ 
 <br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/2.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/2.html" target="_blank">www.weixueyuan.net</a> 
<br>可以说计算机是模仿人体的各个器官而被研制出来的。它包括相当于“大脑”的运算、控制、存储设备，相当于“眼睛”和“耳朵”的输入设备，相当于“嘴巴”和“手脚”的输出设备，以及相当于“神经”和“血管”的传输设备。将这些设备组装在一起就构成了计算机。  <br>人所做的所有活动都是由大脑控制的，比如妈妈做很好吃的红烧肉就是这样的。首先妈妈大脑中已经有了如何做红烧肉的食谱，大脑控制妈妈双手按食谱来准备各种食材，然后根据食谱所示步骤一步步地做出好吃的红烧肉来。<br><br>美国科学家约翰·冯·诺依曼（John von Neumann）就是受此启发提出了计算机的工作原理——存储程序和程序控制，并且明确了计算机的 5 个组成部分（见图 1）。<br>
<br>控制器（相当于大脑）
<br>运算器（相当于大脑）
<br>存储器（相当于大脑）
<br>输入设备（相当于眼睛和耳朵）
<br>输出设备（相当于嘴巴和手脚）
<br> <img alt="IMG-682416B5D207458A8F63BEE1DA3B347D-20240919203953305" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-682416B5D207458A8F63BEE1DA3B347D-20240919203953305.png" referrerpolicy="no-referrer"><br>
图 1：计算机由控制器、运算器、存储器、输入设备、输出设备 5 个功能部件组成<br>
如果要让计算机算出 x×(y+z) 的值，事先就要把计算方法（比如先算括号内的加法，再做乘法）转化为计算机可以识别的一条条的指令（程序），并把这些指令保存在计算机的存储器中（即存储程序）。  <br>接下来我们用键盘把 x、y、z 的值输入计算机并且也保存在存储器（内存）中，然后计算机的控制器就会发出已经存储好的指令给运算器，通知它从存储器中取出 x、y、z 的值，并按照事先已经保存在存储器中的指令来完成这个运算，最后把运算结果也保存在存储器（内存）中并且把它用输出设备（显示器）显示出来，告诉我们运算结果。  <br>这里的从键盘接收输入的数据、运算器执行运算以及输出运算结果都是由事先已经存储在存储器中的程序来控制完成的（即程序控制），由此你会发现，计算机实际上就是只会执行输入、运算、输出 3 种操作的机器（见图 2）。  <br><img alt="IMG-041B7AA9EB33C3B970A65740B76F0AAF-20240919203955108" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-041B7AA9EB33C3B970A65740B76F0AAF-20240919203955108.png" referrerpolicy="no-referrer">图 2：计算机是只会执行输入、运算、输出 3 种操作的机器<br><br>在计算机中把负责控制功能的控制器和负责计算功能的运算器合称为中央处理器（Central Processing Unit，CPU）。<br><br>负责存储功能的存储器有两种：内存储器和辅助存储器。<br><br>也称为主存储器，包括随机存储器（RAM）、只读存储器（ROM），以及高速缓存（CACHE）。<br>
<br>我们通常讲的内存指的是随机存储器（RAM），它是计算机中必须有的，而且只有在计算机接通电源开机以后它才能保存内容，计算机关机或断电以后它里面保存的内容也就消失了。
<br>只读存储器（ROM）里面保存的内容是固定的，只能读取，不能再往里面保存新的内容，而且即使计算机关闭或断电它里面保存的内容也不会消失。
<br>高速缓存（CACHE）是为了提高计算机的处理速度而设置的，它相当于是在中央处理器和内存之间架设的一座桥梁，能使得 CPU 更快速地获得需要处理的数据。
<br><br>也称为外存储器（外存）。计算机即使没有辅助存储器也可以运行。  <br>辅助存储器可以长时间甚至永久性地保存内容，而且计算机关机或断电以后，保存在它里面的内容依然存在。硬盘、光盘（CD、VCD、DVD）、USB 存储器（优盘）等都属于辅助存储器。<br><br>输入设备就是计算机的“眼睛”和“耳朵”，它们负责把外部信息输入到计算机。键盘、鼠标、触摸屏、扫描仪、摄像头、录音话筒等都是输入设备。<br><br>输出设备就是计算机的“嘴巴”和“手脚”，它们负责把计算机内部的信息和处理结果表达出来，能让我们看到或听到。显示器、打印机、音箱、耳机等都是输出设备。  <br>除了以上 5 个功能部件外，计算机中还有大量的数据线，被称为数据总线（Bus）。它们把计算机的各个部件连接起来，并在这些部件之间传输各种信号（数据、指令等），类似于人体中的“神经”和“血管”。  <br>如果将计算机比作人，那么在计算机中，负责指令和运算的 CPU 和负责存储的内存就相当于人的大脑。思考、想象、记忆与回忆……像这些人类大脑的“思考”行为，只要有 CPU 和内存，计算机就能够实现。但是无论计算机内部能够得出多么好的“思考”结果（计算结果等），如果不将这些结果表现出来就起不到作用。  <br>人类是通过语言或者手脚的动作（比如用手写等）把自己的想法表达出来的。计算机也一样，为了把 CPU 和内存的处理结果表达出来，就需要输出设备。计算机毕竟只是一种电子工具，是需要人来操作的，想要计算机的 CPU 和内存进行“思考”，我们必须得先把“思考”所用的各种指令和数据事先输入计算机（存储程序），这就需要输入设备。  <br>输入设备有键盘、鼠标、扫描仪等；输出设备有显示器、打印机等；既可以输入数据又可以输出数据的设备有硬盘、USB 存储器（优盘）、网卡等。我们把这些设备统称为外部设备。  <br>外部设备和 CPU 之间是通过输出输入接口来连接并传输数据的（见图 3）。我们通常用的连接打印机的 RS-232C 数据接口、连接优盘和鼠标的 USB 接口、连接摄像机的 IEEE 1394 接口以及连接硬盘的串行 ATA 数据接口等都是输出输入接口。  <br><img alt="IMG-9D5D8C70D5AC53EDF98AA65797C3762F-20240919203955132" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9D5D8C70D5AC53EDF98AA65797C3762F-20240919203955132.png" referrerpolicy="no-referrer">图 3：CPU、内存和外部设备的关系<br>
计算机在运行时，会在计算机各功能部件内部和与计算机连接的设备之间进行指令和数据的传输（交换）。计算机内部传输信息所用的公共通道就是总线。总线分为串行总线和并行总线（见图 4）。串行总线只有一根数据线（电线丝），逐位依次传输，一次只能传输一位数据；并行总线有 2 根以上的数据线，一次能够同时传输多位（如 8 位、16 位、32 位）数据。计算机内部的这些数据线实际上都是电线丝，通过给这些电线丝通电或者不通电来表示和传递信息。<br><img alt="IMG-4E23B23B178E4DC4454FC49F7F5F2376-20240919203957109" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4E23B23B178E4DC4454FC49F7F5F2376-20240919203957109.png" referrerpolicy="no-referrer"><br>
图 4：串行总线和并行总线<br><br>--<br>
<br>计算机由 CPU 进行控制和运算。
<br>输出输入接口是外部设备与 CPU 的连接桥梁。
<br>外部设备是为了与计算机外部交换信息的设备。
<br>我们将在各个功能部件之间传输信息的通道称为总线。
<br>计算机是只会执行输入、运算、输出 3 种操作的机器。
<br>计算机由控制器、运算器、存储器、输入和输出设备 5 个功能部件组成。
<br>计算机的基本工作原理是存储程序和程序控制，它是由世界著名的科学家冯·诺依曼提出的。他因此被称为“计算机之父”。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/3.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/3.html" target="_blank">www.weixueyuan.net</a> 
<br>前面我们说到把 CPU、存储器、输入设备、输出设备以及数据总线组装在一起就构成了计算机，但是这样的一台计算机还不够完整，它还不能做任何事情，原因是它里面还缺一样东西：软件（Software）。  <br>我们把没有软件的计算机称之为裸机。  <br>CPU、存储器、输入设备、输出设备以及数据总线都是我们可以看得见、摸得着的一些电子元器件，比如计算机的显示器、键盘、硬盘等这些东西我们都可以用眼睛看到，用手触摸到它们。我们把这些看得见、摸得着的设备称为计算机的硬件（Hardware）（见图 1），而把那些计算机中看不到、摸不着的东西称为计算机的软件（见图 2）。<br><img alt="IMG-6AA094B8FC43DCA38E5F6089A897AE3C-20240919203957140" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6AA094B8FC43DCA38E5F6089A897AE3C-20240919203957140.png" referrerpolicy="no-referrer"><br>
图 1：计算机的硬件<br>
那么计算机中什么东西看不到、摸不着呢？就是我们前面曾经提到过的指令和数据。<br>
<br>指令是控制计算机进行输入、运算、输出的各种命令；
<br>数据有我们通过键盘等输入设备输入计算机准备让计算机运算处理的，也有计算机通过运算处理以后的结果。
<br> <img alt="IMG-6708214C7D13C1A5B6670DC57DB5755D-20240919203959354" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6708214C7D13C1A5B6670DC57DB5755D-20240919203959354.png" referrerpolicy="no-referrer"><br>
图 2：计算机的软件<br>
我们把这些控制计算机进行输入、运算、输出的命令一条条地列出来连同它们要处理的数据一起称为程序，软件也就是计算机里面的程序及各种文档。<br><br><br>计算机软件总体分为系统软件和应用软件两大类。<br><br>系统软件是各类操作系统，如 Windows、Linux、UNIX 等，是负责管理计算机系统中各种硬件相互协调工作的。系统软件使得我们可以把计算机当作一个整体而无须考虑其内部每个硬件是如何工作的。<br><br>应用软件是为了某种特定的用途而被开发的软件：<br>
<br>它可以是一个特定的程序，比如一个图像浏览器、一个小游戏以及我们常用的 QQ 等；
<br>可以是一组功能联系紧密，可以互相协作的程序的集合，比如微软的 Office 软件；
<br>也可以是一个由众多独立程序组成的庞大的软件系统，比如银行管理系统、学生档案管理系统等。
<br>C语言程序示例：<br>#include &lt;stdio.h&gt;                  //引入标准输入输出头文件

int main()                          //主函数
{
    int a,b,c;                      //定义 a、b、c 三个整数型变量
    a = 10; b = 20;                 //a 赋值 10，b 赋值 20
    c = a + b;                      //计算 a + b 的和，并把它赋值给 c
    printf("%d+%d=%d\n", a, b, c);  //屏幕打印 ”10+20=30”
    return 0;
}
<br><br>--<br>
<br>程序是指令和数据的集合。
<br>完整的计算机是由硬件和软件构成的。
<br>计算机软件分为系统软件和应用软件。
<br>软件是计算机所执行的程序以及各种文档。
<br>CPU、存储器、输入设备、输出设备以及数据总线都是计算机的硬件。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/4.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/4.html" target="_blank">www.weixueyuan.net</a> 
<br>计算机本身只不过是为我们处理特定工作的机器，是要人来操作的。使用计算机的目的就是为了提高手工作业的效率，但是也有一些手工作业的事情是不能直接由计算机来处理的，原因是计算机有计算机处理问题的方式，有时这些处理方式还跟人类的思维习惯是不一样的。  <br>日常生活中，我们用数字、汉字、图像、声音、视频等来传递和存储各种信息，而在计算机内部所有的这些文字、图像、声音、视频等都是用数字来传递和存储的。比如在计算机中用“0,0,255”表示蓝色，用“255,0,0”表示红色，用“255,0,255”表示蓝色和红色混合而成的紫色。  <br>不光是颜色，计算机对文字的处理也是这样的。计算机内部会先把文字转换成相应的数字再做处理，这样的方式我们叫作“字符编码”。例如，“A”的编码是 65，“a”的编码是 97。  <br>表 1 列出了常用的 ASCII（美国信息交换标准代码）标准字符代码。<br>
<img alt="IMG-6004E40E2230A6DF1E22F0C8945FBB5B-20240919203959383" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6004E40E2230A6DF1E22F0C8945FBB5B-20240919203959383.png" referrerpolicy="no-referrer"><br>我们输入计算机的任何内容，不管是文字、图像还是一段录音、视频等，在计算机内部全部都会转换为数字来处理，因而我们常常把计算机称为数字计算机，把通过计算机来阅读的图书称为数字图书，对应的图书馆称为数字图书馆；同样，我们把学生的档案资料输入计算机来处理的这个过程称为档案资料的数字化。  <br>计算机是一种电器，通电后才能运行，它在内部传输数据也是用电线来传输的，前面提到的总线其实就是一种电线，串行总线里面只有一根电线丝，而并行总线里面有多根电线丝并排在一起。  <br>计算机为了利用电，它里面只设置了两种状态，一种“有电”（电流通过），另一种“没电”（电流不通过）。传输数据的时候一根电线丝也只能传输两种状态，要么“有电”要么“没电”。  <br>在计算机中这样的两种状态，通常用“0”表示“没电”，用“1”表示“有电”。计算机内部所有的数字都只有“0”和“1”两种数值符号。只有“0”和“1”两种数值符号构成的数字我们称之为二进制数。<br>
<a data-href="2_Areas/C语言/ASCII 表" href="2_Areas\C语言\ASCII 表.html" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C语言/ASCII 表</a>5
<br><br>
<br>计算机的 CPU 只能认识并处理二进制数。
<br>计算机的处理方式有时与人们的思维习惯不同。
<br>在计算机内部所有的内容都转换为数字来处理。
<br>计算机内部所有的数据都是用二进制数表示的。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/5.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/5.html" target="_blank">www.weixueyuan.net</a> 
我们在小学算术课中进行各种计算时，一个数的各位都是取 0～9 这几个值，当某位的值达到 10 以后就会向高位进一位（逢十进一）。我们将这种计数方法称为十进制计数法。通常我们使用的数值，如 100、1234、9999 等都是十进制数。  
<br>计算机是由一些依靠电来运行的装置构成的，它采用的数据表示方法很简单，并且适合用电来表示。因为电只有两种状态（“有电”和“没电”），所以在计算机内部只存在 0 和 1 两个值（“0”表示“没电”，“1”表示“有电”），计算机内部的所有数据都是由 0 和 1 这两个值构成的。  <br>在计算机内部进行加减等运算时，当某位的值达到 2 以后就会向高位进一位（逢二进一）。我们将这种计数方法称为二进制计数法。计算机内部所有的数据都是用二进制数来表示的。表 1 列出了 0～11 的数值分别用十进制和二进制表示的情况。  <br>  
计算机中表示数据的最小单位是 bit（位），其值可以取 0 或 1 。一个 bit 就是一个电信号，即一根电线丝上“有电”或“没电”的电流状态。“有电”（用 ON 表示）就是 1，“没电”（用 OFF 表示）就是 0 。  
  
当 8bit 的电信号是（ON,ON,OFF,ON,OFF,OFF,ON,OFF）时，用二进制数表示就是 11010010，这个二进制数我们从视觉上就能够感觉出信号状态，所以很容易理解和识别，这就是二进制数的优点。  
  
由此也可以看出二进制计数法是一种非常适合表示计算机内部数据的方法（见图 1），计算机的 CPU 也只能识别和处理二进制数（见图 2）。<br><img alt="IMG-711C109A6A3F8DCB1163C45FC1468362-20240919204001018" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-711C109A6A3F8DCB1163C45FC1468362-20240919204001018.png" referrerpolicy="no-referrer"><br>
图 1：用二进制数能够非常直观地表示计算机内部信号线的状态  <br><img alt="IMG-C7BF617625ABC4BEE054A9C18178C815-20240919204001056" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C7BF617625ABC4BEE054A9C18178C815-20240919204001056.png" referrerpolicy="no-referrer"><br>
图 2：计算机内部只能识别和处理二进制数<br>Tip
在C语言中,输入二进制的值用0b或0B开头,如char a =0b00001010
<br><br>
<br>在二进制计数法中，数的各位上的值只有 0 和 1 两种数字。
<br>计算机中表示数据的最小单位是 bit（位）。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/7.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/7.html" target="_blank">www.weixueyuan.net</a> 
<br>虽然二进制数在表示计算机内部电信号时非常直观。但对我们人来说，当 0 和 1 的二进制数位数增加时，就很容易看错数值。  <br>为了弥补这个缺点，并且使所表示的数值变得更容易让人接受和识别，从而在计算机编程过程中引入了八进制数和十六进制数。  <br>在八进制数中，只用 0～7 这几个数字符号表示数据，每一位上的数只要满8就要向高位进一位（逢八进一），而十六进制数则是每一位上的数满 16 进一位（逢十六进一）。十六进制数中即使一位的值达到 10～15 也不会向高位进位，而此时 10～15 的两位十进制数字是写不进一位的，因此需要用单一符号来表示 10～15 。于是规定用英文字母 A、B、C、D、E 和 F 分别表示 10、11、12、13、14 和 15 六个数字。  <br>不同计数法中组成各位数值的符号如表 1 所示。  <br>  <br>例如，表 2 中的两个二进制数就不容易区分，相比之下，八进制和十六进制的数值位数减少很多，也更加容易读取和区分。  <br><br><br>
<br>在二进制中，各位上的数只要满 2 就要向高位进一位（逢二进一）。
<br>在八进制中，各位上的数只要满 8 就要向高位进一位（逢八进一）。
<br>在十六进制中，各位上的数只要满 16 就要向高位进一位（逢十六进一）。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/8.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/8.html" target="_blank">www.weixueyuan.net</a> 
<br>我们在小学算术中学过，十进制数的个位（从右向左第 1 位）上的 1 表示数值 1，十位（从右向左第 2 位）上的 1 表示数值 10，百位（从右向左第 3 位）上的 1 表示数值 100，千位（从右向左第 4 位）上的 1 表示数值 1000，依此类推，从右向左第 n 位上的 1 表示的数值是 10n-1。我们把一个数从右向左第 n 位上的 1 所表示的数值大小称为该数位上的位权。  <br>表 1 列出了十进制数、二进制数、八进制数和十六进制数各个数位上的位权大小。  <br><br><br>一个十进制数所表示的数值大小就等于各个数位上的位权乘以该数位上的值（0～9）再相加得到的总和。例如：<br>9504=1000×9+100×5+10×0+1×4<br>二进制数也是同样的原理。二进制数从右向左第 1 位上的 1 表示数值 1（20），第 2 位上的 1 表示数值 2（21），第 3 位上的1表示数值 4（22），第 4 位上的 1 表示数值 8（23），依此类推，从右向左第 n 位上的 1 表示的数值是 2n-1。  <br>二进制数各位的位权与各位上的值（0 或 1）的乘积的总和就是这个二进制数所对应的十进制数（见图 1）。例如把二进制数 101011 转换为十进制数就是：<br>25×1+24×0+23×1+22×0+21×1+20×1=32+0+8+0+2+1=43<br><img alt="IMG-36D758677389B1751D4638B9D37BD373-20240919204002690" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-36D758677389B1751D4638B9D37BD373-20240919204002690.png" referrerpolicy="no-referrer"><br>
图 1：二进制数转换为十进制数（位权 2n-1 的利用）<br>
同理，八进制数各位的位权（8n-1）与各位上的值（0～7）的乘积的总和就是这个八进制数所对应的十进制数（见图 2）。例如把八进制数 1753 转换为十进制数就是：<br>83×1+82×7+81×5+80×3=512+448+40+3=1003<br><img alt="IMG-869CF737BE255488E13D7694F01C32FD-20240919204002726" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-869CF737BE255488E13D7694F01C32FD-20240919204002726.png" referrerpolicy="no-referrer"><br>
图 2：八进制数转换为十进制数（位权 8n-1 的利用）<br>
十六进制数各位的位权（16n-1）与各位上的值（0～F）的乘积的总和就是这个十六进制数所对应的十进制数（见图 3）。例如把十六进制数 27DB 转换为十进制数就是：<br>163×2+162×7+161×13+160×11=8192+1792+208+11=10203<br><img alt="IMG-8CF60501883F7295982656C800E2AC28-20240919204004632" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8CF60501883F7295982656C800E2AC28-20240919204004632.png" referrerpolicy="no-referrer"><br>
图 3：十六进制数转换为十进制数（位权 16n-1 的利用）<br><br><br>利用二进制数各位的位权，可以把一个二进制数转换为十进制数，那么如果要知道十进制数所对应的二进制数是多少，该怎么办呢？  <br>我们通常使用辗转相除求余法来得到一个十进制数所对应的二进制数，具体的操作步骤如下：（见图 4）<br>
<br>用 2 去除十进制数，得到商和余数，这个余数就是对应的二进制数从右向左第 1 位的值；
<br>然后把商作为被除数继续用 2 去除，又得到一个商和余数，此时的余数就是对应的二进制数从右向左第 2 位的值；
<br>再次把得到的第二个商作为被除数继续用 2 除，得到第三个商和余数，这时的余数就是对应的二进制数从右向左第 3 位的值；
<br>像这样把每次得到的商作为被除数用 2 除，获取余数，直到商为 0；
<br>最后把得到的所有余数从右向左依次排列就是这个十进制数对应的二进制数。
<br><img alt="IMG-F794A1B57AE5EE57C266F821DDD33558-20240919204004670" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F794A1B57AE5EE57C266F821DDD33558-20240919204004670.png" referrerpolicy="no-referrer">图 4：把十进制数转换为二进制数的步骤  <br>同样的原理，用 8 作为除数对一个十进制数进行辗转相除，把得到的所有余数从右向左依次排列，可以得到这个十进制数对应的八进制数（见图 5）。<br>
<img alt="IMG-2ADE29E39A3DE91743B020352B97B2E5-20240919204006540" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2ADE29E39A3DE91743B020352B97B2E5-20240919204006540.png" referrerpolicy="no-referrer"><br>
图 5：把十进制数转换为八进制数的步骤  <br>用 16 作为除数对一个十进制数进行辗转相除，把得到的所有余数从右向左依次排列，可以得到这个十进制数对应的十六进制数（见图 6）。  <br><img alt="IMG-56226CCD2AA43D47F9F89F3A3F0A4311-20240919204006610" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-56226CCD2AA43D47F9F89F3A3F0A4311-20240919204006610.png" referrerpolicy="no-referrer"><br>
图 6：把十进制数转换为十六进制数的步骤<br><br><br>当把二进制数转换为八进制数或十六进制数时，可以先把二进制数转换为十进制数，然后再把这个十进制数转换为八进制数或十六进制数；反过来，八进制数或十六进制数转换为二进制数时，则先把它转化为十进制数，再把这个十进制数转换为二进制数；八进制数与十六进制数之间的相互转换也是如此。  <br>除此之外，我们也可以利用前面讲过的各个数位上的位权，把二进制数直接转换为八进制数或十六进制数。要进行这种直接转换需要了解二进制数与八进制数、十六进制数之间的特殊关系：  <br>
<br>八进制数的各位可以取 0～7 这几个值，这正好是用 3 位二进制数（000～111）能表示的值（见表 2）:  
<br>  
2) 十六进制数的各位可以取 0～F 这几个值，这正好是用 4 位二进制数（0000～1111）能表示的值（见表 3）:  
  
  
因此我们可以总结出下面的特殊关系：二进制数的 3 位相当于八进制数的 1 位，二进制数的 4 位相当于十六进制数的 1 位。  <br>所以当把二进制数转换为八进制数时，可以从低位起（从右向左）把二进制数划分为每 3 位一个区间，再把每个区间内的 3 位二进制数转换为对应的十进制数，这样最终得到的数就是这个二进制数对应的八进制数。当把二进制数转换为十六进制数时，可以从低位起（从右向左）把二进制数划分为每 4 位一个区间，再把每个区间内的 4 位二进制数转换为对应的十进制数（10～15 用 A～F 表示），这样最终得到的数就是这个二进制数对应的十六进制数（见图 7）。<br><img alt="IMG-217A827E679231180101FFE2E85A60F0-20240919204007303" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-217A827E679231180101FFE2E85A60F0-20240919204007303.png" referrerpolicy="no-referrer"><br>
图 7：把二进制数转换为八进制数、十六进制数的步骤<br>
反过来，把八进制数转换为二进制数时，将八进制数的各位变换为 3 位二进制数，就得到了这个八进制数对应的二进制数；把十六进制数转换为二进制数时，将十六进制数的各位变换为 4 位二进制数，就得到了这个十六进制数对应的二进制数（见图 8）。  <br><img alt="IMG-CAA3DC7F249F492E25639C1B51924294-20240919204007351" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CAA3DC7F249F492E25639C1B51924294-20240919204007351.png" referrerpolicy="no-referrer"><br>
图 8：把八进制数、十六进制数转换为二进制数的步骤<br><br>--<br>
<br>3 位二进制数的值正好能用 1 位八进制数来表示。
<br>4 位二进制数的值正好能用 1 位十六进制数来表示。
<br>各位的位权与各位上的值的乘积的总和就是这个数所对应的十进制数。
<br>在二进制数中，从右向左第 n 位拥有&nbsp;2n-1（2 的 n-1 次方）的“位权”。
<br>在八进制数中，从右向左第 n 位拥有&nbsp;8n-1（8 的 n-1 次方）的“位权”。
<br>用 2 除十进制数时得到的余数就是十进制数所对应的二进制数各位的值。
<br>用 8 除十进制数时得到的余数就是十进制数所对应的八进制数各位的值。
<br>用 16 除十进制数时得到的余数就是十进制数所对应的十六进制数各位的值。
<br>在十六进制数中，从右向左第 n 位拥有&nbsp;16n-1（16 的 n-1 次方）的“位权”。
<br>在 C语言中如果一个数以 0 开头，表示这是一个八进制数。比如 025 表示 25 是一个八进制数。
<br>在 C语言中如果一个数以 0x 开头，表示这是一个十六进制数。比如 0x45 表示 45 是一个十六进制数。
<br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://www.weixueyuan.net/a/9.html" rel="noopener nofollow" class="external-link" href="https://www.weixueyuan.net/a/9.html" target="_blank">www.weixueyuan.net</a> 
<br>我们前面介绍了计算机内部数据的最小单位是位（bit），也就是一根电线丝一次传输的电信号状态，我们用二进制数 0 或 1 来表示。如果把 8 根电线丝并排在一起，并行传输数据，则一次可以同时传输 8 种电信号状态，即 8 位二进制数（0 或 1）。  <br>在计算机中，把 8 位聚在一起的二进制数称为一个字节（byte），即 1 字节（byte）= 8 位（bit）。字节是计算机中表示数据大小的基本单位。通常字节（byte）用大写字母 B 表示，位（bit）用小写字母 b 表示。例如：16 位二进制数就是 2 字节（2B），32 位二进制数就是 4 字节（4B）（见图 1）。 <br><img alt="IMG-235FCA6B58A658FCB3FA388F19315670-20240919204007627" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-235FCA6B58A658FCB3FA388F19315670-20240919204007627.png" referrerpolicy="no-referrer">图 1：位和字节的关系  <br>&nbsp;<br>
我们在购买计算机的时候，都会看到有关计算机性能的表示方法。例如，在表示 CPU 性能时，可以写成 16 位 CPU、32 位 CPU、64 位 CPU 等，这里的 16、32、64 指的就是 CPU 处理数据的能力大小、并行总线一次可以传输的二进制数位多少等，一般这个数值越大，CPU 的性能越好。  <br>另外还有表示计算机内存大小的 512MB、2GB 等，以及表示硬盘存储容量大小的 500GB、2TB 等，我们还会在计算机中看到某个文件大小表示为 320KB 这样的形式。  <br>前面提到的 B、KB、MB、GB、TB 都是计算机中表示数据大小的计量单位，通常我们把 M 读作“兆”，其他几个都按英文字母发音。这里的 K（kilo）、M（mega）、G（giga）、T（tera）类似于十进制数中的计量单位千、百万、十亿、万亿。  <br>十进制数中的十、百、千、万等都是以 10n&nbsp;来计量的，计算机中的数据都是用二进制数表示的。计算机中的 K、M、G、T 都是用 2n&nbsp;来计量的，而且它们依次增大为前一个的 1024 倍，即 210&nbsp;倍（见图 2）。  <br>
<br>1KB=1024B=1024 字节
<br>1MB=1024KB=1024×1024 字节
<br>1GB=1024MB=1024×1024×1024 字节
<br>1TB=1024GB=1024×1024×1024×1024 字节
<br><img alt="IMG-6B17994417FA640D89B57C19B5C65F06-20240919204007677" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6B17994417FA640D89B57C19B5C65F06-20240919204007677.png" referrerpolicy="no-referrer"><br>
图 2：计算机中表示内存大小（存储容量）的单位<br><br>
<br>1 字节（byte）=8 位（bit）。
<br>字节是计算机中表示数据大小的基本单位。
]]></description><link>2_Areas\C51单片机\计算机基础.html</link><guid isPermaLink="false">2_Areas/C51单片机/计算机基础.md</guid><pubDate>Mon, 28 Oct 2024 02:40:02 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-682416B5D207458A8F63BEE1DA3B347D-20240919203953305.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-682416B5D207458A8F63BEE1DA3B347D-20240919203953305.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[晶体管芯片ULN2003]]></title><description><![CDATA[ 
 <br><br><a data-href="ULN2003中文手册.pdf" href="ULN2003中文手册.pdf" class="internal-link" target="_self" rel="noopener nofollow">ULN2003中文手册.pdf</a><br><img alt="IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286.png" referrerpolicy="no-referrer">]]></description><link>2_Areas\C51单片机\晶体管芯片ULN2003.html</link><guid isPermaLink="false">2_Areas/C51单片机/晶体管芯片ULN2003.md</guid><pubDate>Sun, 27 Oct 2024 03:47:06 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[矩阵键盘]]></title><description><![CDATA[ 
 <br><br><br>
<br>我们称为“按键”或“按钮”，这种开关由金属触点和触片组成。

<br><img alt="IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292.png" referrerpolicy="no-referrer">


<br>按键在开关闭合及断开的瞬间会伴随一连串的抖动

<br><img alt="IMG-37A6FD4B88667F41F38903901CCE6B34-20240919203954727" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-37A6FD4B88667F41F38903901CCE6B34-20240919203954727.png" referrerpolicy="no-referrer">
<br>在闭合及断开时需要一个延时操作,消除抖动的影响.


<br>按键排列起来就是矩阵键盘.
<br><br>• 在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式<br>
• 采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态<br><img alt="IMG-F9DCFC18E8527E51BD724FFF5ACC783F-20240919203954752" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F9DCFC18E8527E51BD724FFF5ACC783F-20240919203954752.png" referrerpolicy="no-referrer"><br><img alt="IMG-883C3E462C5635EA2AC9BBD206947F86-20240919203956755" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-883C3E462C5635EA2AC9BBD206947F86-20240919203956755.png" referrerpolicy="no-referrer"><br><br>• 数码管扫描（输出扫描）<br>
原理：显示第1位→显示第2位→显示第3位→......，然后快速循环这个过程，最终实现所有数码管同时显示的效果<br>
• 矩阵键盘扫描（输入扫描）<br>
原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ......，然后快速循环这个过程，最终实现所有按键同时检测的效果<br>
• 以上两种扫描方式的共性：节省I/O口<br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"

/**
  * @brief  矩阵键盘读取按键键码
  * @param  无
  * @retval KeyNumber 按下按键的键码值
			如果按键按下不放，程序会停留在此函数，松手的一瞬间，返回按键键码，没有按键按下时，返回0
  */
unsigned char MatrixKey()
{
	unsigned char KeyNumber=0;
	
	P1=0xFF;
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}
	
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}
	
	P1=0xFF;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}
	
	P1=0xFF;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}
	
	return KeyNumber;
}
<br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"		//包含Delay头文件
#include "LCD1602.h"	//包含LCD1602头文件
#include "MatrixKey.h"	//包含矩阵键盘头文件

unsigned char KeyNum;

void main()
{
	LCD_Init();							//LCD初始化
	LCD_ShowString(1,1,"MatrixKey:");	//LCD显示字符串
	while(1)
	{
		KeyNum=MatrixKey();				//获取矩阵键盘键码
		if(KeyNum)						//如果有按键按下
		{
			LCD_ShowNum(2,1,KeyNum,2);	//LCD显示键码
		}
	}
}

<br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "MatrixKey.h"

unsigned char KeyNum;
unsigned int Password,Count;

void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"Password:");
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum)
		{
			if(KeyNum&lt;=10)	//如果S1~S10按键按下，输入密码
			{
				if(Count&lt;4)	//如果输入次数小于4
				{
					Password*=10;				//密码左移一位
					Password+=KeyNum%10;		//获取一位密码
					Count++;	//计次加一
				}
				LCD_ShowNum(2,1,Password,4);	//更新显示
			}
			if(KeyNum==11)	//如果S11按键按下，确认
			{
				if(Password==2345)	//如果密码等于正确密码
				{
					LCD_ShowString(1,14,"OK ");	//显示OK
					Password=0;		//密码清零
					Count=0;		//计次清零
					LCD_ShowNum(2,1,Password,4);	//更新显示
				}
				else				//否则
				{
					LCD_ShowString(1,14,"ERR");	//显示ERR
					Password=0;		//密码清零
					Count=0;		//计次清零
					LCD_ShowNum(2,1,Password,4);	//更新显示
				}
			}
			if(KeyNum==12)	//如果S12按键按下，取消
			{
				Password=0;		//密码清零
				Count=0;		//计次清零
				LCD_ShowNum(2,1,Password,4);	//更新显示
			}
		}
	}
}

]]></description><link>2_Areas\C51单片机\矩阵键盘.html</link><guid isPermaLink="false">2_Areas/C51单片机/矩阵键盘.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PWM介绍]]></title><description><![CDATA[ 
 <br><br>• PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域<br>• PWM重要参数：<br>
  <br><img alt="IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296.png" referrerpolicy="no-referrer"><br><img alt="IMG-9E287802BE8766213A13F0ABBE124BC6-20240919203954933" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9E287802BE8766213A13F0ABBE124BC6-20240919203954933.png" referrerpolicy="no-referrer"><br><br>• 模型结构<br><img alt="IMG-418987FFAF8003CC33E2A8257E92DB83-20240919203956910" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-418987FFAF8003CC33E2A8257E92DB83-20240919203956910.png" referrerpolicy="no-referrer"><br>• 波形<br>
<img alt="IMG-3DB24AFE9219914B0F2825F314FD88E5-20240919203959204" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3DB24AFE9219914B0F2825F314FD88E5-20240919203959204.png" referrerpolicy="no-referrer"><br><br>
<br>每隔100us中断一次并计数
<br>计数值小于比较值时输出高电平,反之输出低电平
<br>一个PWM波的周期为10ms
<br>void Timer0_Routine() interrupt 1
{
	TL0 = 0x9C;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	Counter++;
	Counter%=100;	//计数值变化范围限制在0~99
	if(Counter&lt;Compare)	//计数值小于比较值
	{
		DA=1;		//输出1
	}
	else				//计数值大于比较值
	{
		DA=0;		//输出0
	}
}

<br><br>设置定时初值,每隔100us中断一次<br><br><br>#include &lt;REGX52.H&gt;

sbit LED=P2^0;

void Delay(unsigned int t)
{
	while(t--);
}

void main()
{
	unsigned char Time,i;
	while(1)
	{
		for(Time=0;Time&lt;100;Time++)		//改变亮灭时间，由暗到亮
		{
			for(i=0;i&lt;20;i++)			//计次延时
			{
				LED=0;					//LED亮
				Delay(Time);			//延时Time
				LED=1;					//LED灭
				Delay(100-Time);		//延时100-Time
			}
		}
		for(Time=100;Time&gt;0;Time--)		//改变亮灭时间，由亮到暗
		{
			for(i=0;i&lt;20;i++)			//计次延时
			{
				LED=0;					//LED亮
				Delay(Time);			//延时Time
				LED=1;					//LED灭
				Delay(100-Time);		//延时100-Time
			}
		}
	}
}
<br>]]></description><link>2_Areas\C51单片机\脉冲宽度调制PWM.html</link><guid isPermaLink="false">2_Areas/C51单片机/脉冲宽度调制PWM.md</guid><pubDate>Sun, 27 Oct 2024 03:47:08 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[AD/DA介绍]]></title><description><![CDATA[ 
 <br><br>
<br>AD（Analog to Digital）：模拟-数字转换，将模拟信号转换为计算机可操作的数字信号
<br>DA（Digital to Analog）：数字-模拟转换，将计算机输出的数字信号转换为模拟信号
<br>AD/DA转换打开了计算机与模拟信号的大门，极大的提高了计算机系统的应用范围，也为模拟信号数字化处理提供了可能.
<br><img alt="IMG-88D7330700C3A59073A3EDBE6E4C6F27-20240919203954632" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88D7330700C3A59073A3EDBE6E4C6F27-20240919203954632.png" referrerpolicy="no-referrer"><br><img alt="IMG-71AFAB6067DAE7C98BD787B6CF94A559-20240919203956624" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-71AFAB6067DAE7C98BD787B6CF94A559-20240919203956624.png" referrerpolicy="no-referrer"><br><img alt="IMG-1510D8A092494A4F7A1F4E40AF5DC365-20240919203956650" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1510D8A092494A4F7A1F4E40AF5DC365-20240919203956650.png" referrerpolicy="no-referrer"><br><img alt="IMG-2477394B199174CE42160459F30CA4F6-20240919203958854" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2477394B199174CE42160459F30CA4F6-20240919203958854.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-6A7BFFA2ED4D4F1120602A60FE2DF742-20240919203958899" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6A7BFFA2ED4D4F1120602A60FE2DF742-20240919203958899.png" referrerpolicy="no-referrer"><br>
<br>AD转换通常有多个输入通道，用多路选择开关连接至AD转换器，以实现AD多路复用的目的，提高硬件利用率
<br>AD/DA与单片机数据传送可使用并口（速度快、原理简单），也可使用串口（接线少、使用方便）
<br>可将AD/DA模块直接集成在单片机内，这样直接写入/读出寄存器就可进行AD/DA转换，单片机的IO口可直接复用为AD/DA的通道
<br><br><img alt="IMG-D637D024A05AE7C171D87BB1A48D7878-20240919204000550" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D637D024A05AE7C171D87BB1A48D7878-20240919204000550.png" referrerpolicy="no-referrer"><br><img alt="IMG-F9979C9CDA0723C17005459442815CEA-20240919204000594" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F9979C9CDA0723C17005459442815CEA-20240919204000594.png" referrerpolicy="no-referrer"><br>
<a data-href="3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" href="3_Resources\Attachments\2_Areas\C51单片机\IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" class="internal-link" target="_self" rel="noopener nofollow">3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf</a>5 ADC模块 <br><img alt="IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007.png" referrerpolicy="no-referrer"><br>
<a data-href="3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" href="3_Resources\Attachments\2_Areas\C51单片机\IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf" class="internal-link" target="_self" rel="noopener nofollow">3_Resources/Attachments/2_Areas/C51单片机/IMG-B199750EA76330F7E932E94AB3330DD7-20240919203953298.pdf</a>5 DAC模块 <br><img alt="IMG-A648204CBE84BED957D6132B2F576285-20240919204002269" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A648204CBE84BED957D6132B2F576285-20240919204002269.png" referrerpolicy="no-referrer"><br>
ADC0809 模数转换芯片<br><img alt="IMG-CCCBD3F41E483A78CEE04F4F2A2B253E-20240919204002311" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CCCBD3F41E483A78CEE04F4F2A2B253E-20240919204002311.png" referrerpolicy="no-referrer"><br>
DAC0832 数模转换芯片<br><br><br><br><br>
<br>利用反向放大器和二进制位权分流进行DA转换
<br>D7~D0是要数字信号控制的开关

<br>开关接0时连接正相输出端

<br>正相输出端接地,不会对放大器产生影响


<br>开关接1时连接反向输出端

<br>连接到该端的电压会被反向放大器放大
<br>通过开关控制电阻阻值便可以控制放大倍数




<br>上面的是分流用的电阻,所有电阻串并联后的阻值为R

<br>两个2R并联阻值为R,与R串联阻值为2R,又与2R并联...


<br>电流直接存在二倍数关系

<br>I1=2 I0, I2=2 I1, ... , I=2 I7
<br>可以很容易判断出I=256 I0,通过开关控制流过的电流,从而控制输出端电势

<br>当D7~D0为 00000001时,  电流为I0, 两端电压为I0与的乘积.
<br>当D7~D0为 10000000 时,  电流为128 I0, 两端电压为128 I0与的乘积.


<br>通过这一方法就可以将数字信号转换成与之对应的模拟信号


<br><img alt="IMG-04FBCD25FC45E8C144F940A574BA9448-20240919204004192" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-04FBCD25FC45E8C144F940A574BA9448-20240919204004192.png" referrerpolicy="no-referrer"><br>
<br>输出电压 
<br>当  时, 
<br><br><img alt="IMG-D62250094B5D2A088AA61A68D4DB8D8C-20240919204004249" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D62250094B5D2A088AA61A68D4DB8D8C-20240919204004249.png" referrerpolicy="no-referrer"><br>
<br><a data-tooltip-position="top" aria-label="滞后校正装置" data-href="滞后校正装置" href="滞后校正装置" class="internal-link" target="_self" rel="noopener nofollow">低通滤波器</a>

<br>过滤交流分量,将PWM信号转换成等效的直流信号


<br>输出电压  
<br><br>将PWM信号根据占空比转换成等效的直流信号<br>
<img alt="IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9BA4CC68A10E525F3C9F51B12DD683D9-20240919203957007.png" referrerpolicy="no-referrer"><br>
<br>运算放大器正相输入端左边的就是一个低通滤波器
<br><br>
<br>分辨率

<br>指AD/DA数字量的精细程度，通常用位数表示。
<br>例如，对于5V电源系统来说，8位的AD可将5V等分为256份，即数字量变化最小一个单位时，模拟量变化5V/256=0.01953125V，
<br>所以，8位AD的电压分辨率为0.01953125V，AD/DA的位数越高，分辨率就越高


<br>转换速度

<br>表示AD/DA的最大采样/建立频率，通常用转换频率或者转换时间来表示，对于采样/输出高速信号，应注意AD/DA的转换速度


<br><br><br><br><img alt="IMG-CC601DEEC1D07FA4B58400D7E51F54EA-20240919204006182" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CC601DEEC1D07FA4B58400D7E51F54EA-20240919204006182.png" referrerpolicy="no-referrer"><br>
<br>ADC利用二分法假设数值并与模拟信号比较,直到假设数值等于模拟信号

<br>SAR假设一个数值,通过数模转换器DAC转化成对应的电压
<br>通过电压比较器与模拟信号比较,比较器根据两者大小输出高低电平

<br>当假设值小于比较值时,将假设在增大
<br>当假设值大于比较值时,将假设在减小


<br>直到比较器输出0v或精度达到极限时,说明假设值逼近模拟信号
<br>将此时的比较值保存


<br>输出数字量  
<br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "LCD1602.h"
#include "XPT2046.h"

unsigned int ADValue;

void main(void)
{
	LCD_Init();
	LCD_ShowString(1,1,"ADJ  NTC  GR");
	while(1){
	
	}
}
<br><br>ADValue=XPT2046_ReadAD(XPT2046_XP);		//读取AIN0，可调电阻
LCD_ShowNum(2,1,ADValue,3);				//显示AIN0
ADValue=XPT2046_ReadAD(XPT2046_YP);		//读取AIN1，热敏电阻
LCD_ShowNum(2,6,ADValue,3);				//显示AIN1
ADValue=XPT2046_ReadAD(XPT2046_VBAT);	//读取AIN2，光敏电阻
LCD_ShowNum(2,11,ADValue,3);			//显示AIN2
Delay(100);
<br><br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "Timer0.h"

sbit DA=P2^1;

unsigned char Counter,Compare;	//计数值和比较值，用于输出PWM
unsigned char i;

void main()
{
	Timer0_Init();
	while(1)
	{

	}
}
<br><br>for(i=0;i&lt;100;i++)
{
    Compare=i;			//设置比较值，改变PWM占空比
    Delay(10);
}
for(i=100;i&gt;0;i--)
{
    Compare=i;			//设置比较值，改变PWM占空比
    Delay(10);
}
<br><br>]]></description><link>2_Areas\C51单片机\模拟-数字转换_AD-DA.html</link><guid isPermaLink="false">2_Areas/C51单片机/模拟-数字转换_AD-DA.md</guid><pubDate>Sun, 27 Oct 2024 03:47:05 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88D7330700C3A59073A3EDBE6E4C6F27-20240919203954632.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88D7330700C3A59073A3EDBE6E4C6F27-20240919203954632.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[轻触开关]]></title><description><![CDATA[ 
 <br><br>我们称为“按键”或“按钮”，这种开关由金属触点和触片组成。轻触开关是一种电子开关，属于电子元器件类。轻触开关常分为两脚开关和四脚开关。<br><br>两个触点平时不和触片接触（常开触点），当按下按键时，触片同时和两个触点接触，使与两个触点相连的线路接通。<br><img alt="IMG-79FA869FE6FC6E58B0D16F24F01BE7CC-20240919203953306" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-79FA869FE6FC6E58B0D16F24F01BE7CC-20240919203953306.png" referrerpolicy="no-referrer" style="width: 450px; max-width: 100%;"><br><br>对四脚按键而言，当按键按下时，1、2脚就和3、4脚导通了。因此在使用时要是无法识别具体的引脚，接斜对角的两个引脚便可。也可用万用表测出那两个脚在不按下的情况下是导通的，然后在选择引脚接入电路。<br> 找不到“20211230153333.png|525”。<br> <img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2BD2A14C3AC6E4E8489DE0E30563855B-20240919203955167.png" referrerpolicy="no-referrer"><br><img alt="IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C3229627136B38E9E65CA27877DFA687-20240919203953292.png" referrerpolicy="no-referrer" style="width: 650px; max-width: 100%;"><br><br>相对湿度:&lt;95%<br>额定电压:12V<br>额定电流:50mA<br>温度:-25~70℃<br><br>• 对于机械开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，所以在开关闭合及断开的瞬间会伴随一连串的抖动<br><img alt="IMG-37A6FD4B88667F41F38903901CCE6B34-20240919203954727" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-37A6FD4B88667F41F38903901CCE6B34-20240919203954727.png" referrerpolicy="no-referrer"><br><br>一般按键的一端会接地(GND)或接低电平,另一端接I/O口 当按键按下时,另一端的I/O口信号为0.<br>
之所以接地(GND)而不接电源(VCC)是因为单片机的准双向口输出配置.<br>
准双向口输出类型可用作输出和输入功能而不需重新配置口线输出状态。这是因为当口线输出为1时驱动能力很弱，允许外部装置将其拉低。当引脚输出为低时，它的驱动能力很强，可吸收相当大的电流。<br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=b50226e9-8f3c-d658-042e-b89a5dea9fc0&amp;page=66&amp;rect=89.193,392.024,193.193,409.353" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=b50226e9-8f3c-d658-042e-b89a5dea9fc0&amp;page=66&amp;rect=89.193,392.024,193.193,409.353" target="_blank">准双向口输出配置</a>
<br><br><br>void Delay(unsigned int xms)
{
	unsigned char i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}
<br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"

/**
  * @brief  获取独立按键键码
  * @param  无
  * @retval 按下按键的键码，范围：0~4，无按键按下时返回值为0
  */
unsigned char Key()
{
	unsigned char KeyNumber=0;
	
	if(P3_1==0){Delay(20);while(P3_1==0);Delay(20);KeyNumber=1;}
	if(P3_0==0){Delay(20);while(P3_0==0);Delay(20);KeyNumber=2;}
	if(P3_2==0){Delay(20);while(P3_2==0);Delay(20);KeyNumber=3;}
	if(P3_3==0){Delay(20);while(P3_3==0);Delay(20);KeyNumber=4;}
	
	return KeyNumber;
}
<br><br>
<br>每隔20ms扫描一次独立按键

<br>获取的按键码赋值给全局变量Key_KeyNumber, Key()函数也可以使用


<br>void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count1;
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	
	T0Count1++;
	if(T0Count1&gt;=20)
	{
		T0Count1=0;
		Key_Loop();	//20ms调用一次按键驱动函数
	}
}

<br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"

unsigned char Key_KeyNumber;

/**
  * @brief  获取按键键码
  * @param  无
  * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  */
unsigned char Key(void)
{
	unsigned char Temp=0;
	Temp=Key_KeyNumber;
	Key_KeyNumber=0;
	return Temp;
}

/**
  * @brief  获取当前按键的状态，无消抖及松手检测
  * @param  无
  * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  */
unsigned char Key_GetState()
{
	unsigned char KeyNumber=0;
	
	if(P3_1==0){KeyNumber=1;}
	if(P3_0==0){KeyNumber=2;}
	if(P3_2==0){KeyNumber=3;}
	if(P3_3==0){KeyNumber=4;}
	
	return KeyNumber;
}

/**
  * @brief  按键驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Key_Loop(void)
{
	static unsigned char NowState,LastState;
	LastState=NowState;				//按键状态更新
	NowState=Key_GetState();		//获取当前按键状态
	//如果上个时间点按键按下，这个时间点未按下，则是松手瞬间，以此避免消抖和松手检测
	if(LastState==1 &amp;&amp; NowState==0)
	{
		Key_KeyNumber=1;
	}
	if(LastState==2 &amp;&amp; NowState==0)
	{
		Key_KeyNumber=2;
	}
	if(LastState==3 &amp;&amp; NowState==0)
	{
		Key_KeyNumber=3;
	}
	if(LastState==4 &amp;&amp; NowState==0)
	{
		Key_KeyNumber=4;
	}
}
<br><br><br><br>#include "stm32f10x.h"                  // Device header
#include "Delay.h"

void Key_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  //上拉输入模式
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 

    //初始化B1和B11
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11; 
	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
}
<br><br><br>uint8_t Key_GetNum(void)
{
	uint8_t KeyNum = 0;
	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
	{
		Delay_ms(20);
		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);
		Delay_ms(20);
		KeyNum = 1;
	}
	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)
	{
		Delay_ms(20);
		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);
		Delay_ms(20);
		KeyNum = 2;
	}
	
	return KeyNum;
}

<br><br><br>]]></description><link>2_Areas\C51单片机\轻触开关.html</link><guid isPermaLink="false">2_Areas/C51单片机/轻触开关.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-79FA869FE6FC6E58B0D16F24F01BE7CC-20240919203953306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-79FA869FE6FC6E58B0D16F24F01BE7CC-20240919203953306.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[驱动电路]]></title><description><![CDATA[ 
 <br><br><br><img alt="IMG-037788572F7B4FAE356FCC4E72DCF7A5-20240919203953308" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-037788572F7B4FAE356FCC4E72DCF7A5-20240919203953308.png" referrerpolicy="no-referrer"><br><img alt="IMG-77E954527FD14005EF69B9A80BFCBF85-20240919203955563" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-77E954527FD14005EF69B9A80BFCBF85-20240919203955563.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-93AD89703DFEED9B969AABAB5A95231D-20240919203955590" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-93AD89703DFEED9B969AABAB5A95231D-20240919203955590.png" referrerpolicy="no-referrer"><br><img alt="IMG-EB955169EBD8081C32D584FD4E011257-20240919203957368" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EB955169EBD8081C32D584FD4E011257-20240919203957368.png" referrerpolicy="no-referrer"><br><br>晶体管芯片ULN2003<br><br><br><br><a data-href="ULN2003中文手册.pdf" href="ULN2003中文手册.pdf" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">ULN2003中文手册.pdf</a><br><img alt="IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BE2954DBD9DFB4A8B9DA3B90287E3EEF-20240919203953286.png" referrerpolicy="no-referrer">2<br><br>
<br>利用三极管放大电路驱动外部负载时,外部负载可能会影响驱动电路输出的电压,导致电路驱动能力下降,这时称该电路没有驱动能力
<br>要解决这一问题,需要使用运算放大器组成驱动电路,提供稳定的电压输出,这样才能驱动外部负载.
]]></description><link>2_Areas\C51单片机\驱动电路.html</link><guid isPermaLink="false">2_Areas/C51单片机/驱动电路.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-037788572F7B4FAE356FCC4E72DCF7A5-20240919203953308.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-037788572F7B4FAE356FCC4E72DCF7A5-20240919203953308.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[三极管]]></title><description><![CDATA[ 
 <br><br>
本文由 <a data-tooltip-position="top" aria-label="http://ksria.com/simpread/" rel="noopener nofollow" class="external-link" href="http://ksria.com/simpread/" target="_blank">简悦 SimpRead</a> 转码， 原文地址 <a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/519072786" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/519072786" target="_blank">zhuanlan.zhihu.com</a>
<br><br><br>三极管全称是“晶体三极管”，也被称作“晶体管”，是一种具有放大功能的半导体器件。通常指本征半导体三极管，即BJT管。<br>典型的三极管由三层半导体材料，有助于连接到外部电路并承载电流的端子组成。施加到晶体管的任何一对端子的电压或电流控制通过另一对端子的电流。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-3148e0e2188dcac94082401c0659fbe4_b.png" referrerpolicy="no-referrer"><br><br>
<br>基极：用于激活晶体管。（名字的来源，最早的点接触晶体管有两个点接触放置在基材上，而这种基材形成了底座连接。）
<br>集电极：三极管的正极。（因为收集电荷载体）
<br>发射极：三极管的负极。（因为发射电荷载流子）
<br><br><br>三极管的应用十分广泛，种类繁多，分类方式也多种多样。<br><br>
<br>NPN型三极管
<br>PNP型三极管
<br><br>
<br>小功率三极管
<br>中功率三极管
<br>大功率三极管
<br><br>
<br>低频三极管
<br>高频三极管
<br><br>
<br>金属封装型
<br>塑料封装型
<br><br>
<br>锗三极管
<br>硅三极管
<br>除此之外，还有一些专用或特殊三极管。<br><br><br>这里主要讲一下PNP和NPN。<br><br>PNP是一种BJT，其中一种n型材料被引入或放置在两种p型材料之间。在这样的配置中，设备将控制电流的流动。PNP晶体管由2个串联的晶体二极管组成。二极管的右侧和左侧分别称为集电极-基极二极管和发射极-基极二极管。<br><br>NPN中有一种 p 型材料存在于两种 n 型材料之间。NPN晶体管基本上用于将弱信号放大为强信号。在 NPN 晶体管中，电子从发射极区移动到集电极区，从而在晶体管中形成电流。这种晶体管在电路中被广泛使用。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-e79335f65b0db0a2233f811a96eb500d_b.jpg" referrerpolicy="no-referrer"><br><br>分别是截止状态、放大状态、饱和状态。接下来分享我在微信公众号（借用一下，原作者看到的话，提醒一下）看到的一种通俗易懂的讲法：<br><br>三极管的截止状态，这应该是比较好理解的，当三极管的发射结反偏，集电结反偏时，三极管就会进入截止状态。<br>这就相当于一个关紧了的水龙头，水龙头里的水是流不出来的。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-e2e686e761ccfd11980c11c9249c7f9a_b.jpg" referrerpolicy="no-referrer"><br>截止状态下，三极管各电极的电流几乎为0，集电极和发射极互不相通。<br><br>当三极管发射结正偏，集电结反偏，三极管就会进入放大状态。<br>在放大状态下，三极管就相当于是一个受控制的水龙头，水龙头流出水流的大小受开关（基极）控制，开关拧大一点，流出的水就会大一点。<br>也就是放大状态下，基极的电流大一点，集电极的电流也会跟着变大！并且ic与ib存在一定比例关系，ic = β ib，β是直流电流放大系数，表示三极管放大能力的大小。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-eef5149338ed27d25a5af1a05a48c3f2_b.jpg" referrerpolicy="no-referrer"><br><br>当三极管发射结正偏，集电结正偏时，三极管工作在饱和状态。<br>在饱和状态下，三极管集电极电流ic的大小已经不受基极电流ib的控制，ic与ib不再成比例关系。<br>饱和状态下的三极管基极电流ib变大时，集电极电流ic也不会变大了，这就相当于水龙头的开关已经开得比较大了，开关再开大时，流出的水流也不会再变大了。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-d661b16600d6f99765ffb1735f0799f3_b.jpg" referrerpolicy="no-referrer"><br><br><br>这里主要有三种类型：共基极 (CB)、共集电极 (CC) 和共发射极 (CE)。<br><br>在共基极 (CB) 配置中，晶体管的基极端子在输入和输出端子之间是公共的。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-0e392b77d6a6504ba3214a9ac396ef49_b.jpg" referrerpolicy="no-referrer"><br><br>在公共集电极 (CC) 配置中，集电极端子在输入和输出端子之间是公共的。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-90a4ae4f4d696f6a1594005e99a03e5b_b.jpg" referrerpolicy="no-referrer"><br><br>在公共发射极 (CE) 配置中，发射极端子在输入和输出端子之间是公共的。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-00c8f08f3ef9a97d77ffd8c2c4e6f0ca_b.jpg" referrerpolicy="no-referrer"><br><br><br><br>三极管是一种电流放大器件，可制成交流或直流信号放大器，由基极输入一个很小的电流从而控制集电极输出很大的电流，如下图所示：<br>"undefined" 未创建，点击以创建。3<br>三极管基极（b）电流最小，且远小于另两个引脚的电流；发射极（e）电流最大（等于集电极电流和基极电流之和）；集电极（c）电流 与基极（b）电流之比即为三极管的放大倍数。<br>三极管具有放大功能的基本条件是保证基极和发射极之间加正向电压（发射结正偏），基极与集电极之间加反向电压（集电结反偏）。基极相对于发射极为正极性电压，基极相对于集电极为负极性电压。<br><br>三极管的集电极电流在一定范围内随基极电流呈线性变化，这就是放大特性。当基极电流高过此范围时，三极管集电极电流会达到饱和值 （导通），基极电流低于此范围时，三极管会进入截止状态（断路）， 这种导通或截止的特性在电路中还可起到开关作用，如下图所示：<br>"undefined" 未创建，点击以创建。3<br><br>
<br>三极管配合其他元件可以构成振荡器
<br>把一只小功率可控硅和一只大功率三极管组合，就可得到一只大功率可控硅，主要作用是扩流
<br>两只三极管串联可直接代换调光台灯中的双向触发二极管，主要是代换功能
<br>用三极管构成的电路可以模拟其它元器件
<br>电阻分压器构成恒压源电路，晶体管用作恒压管
<br>晶体管反相器
]]></description><link>2_Areas\C51单片机\三极管.html</link><guid isPermaLink="false">2_Areas/C51单片机/三极管.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-3148e0e2188dcac94082401c0659fbe4_b.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/v2-3148e0e2188dcac94082401c0659fbe4_b.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[时钟芯片DS1302]]></title><description><![CDATA[ 
 <br><br><a data-href="DS1302中文手册.pdf" href="DS1302中文手册.pdf" class="internal-link" target="_self" rel="noopener nofollow">DS1302中文手册.pdf</a><br>• DS1302是由美国DALLAS公司推出的具有涓细电流充电能力的低功耗实时时钟芯片。它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能<br>
• RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片<br><img alt="IMG-DAA2F70BCAA53634B4D216B6134ED330-20240919203953285" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAA2F70BCAA53634B4D216B6134ED330-20240919203953285.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-76383487B1FE5190E3A2EA14404525B3-20240919203954525" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-76383487B1FE5190E3A2EA14404525B3-20240919203954525.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-3CD40B80224C1788C5C80372FDB15080-20240919203956591" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3CD40B80224C1788C5C80372FDB15080-20240919203956591.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-E090F7D5AF140D822DF809AABA590B30-20240919203958791" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E090F7D5AF140D822DF809AABA590B30-20240919203958791.png" referrerpolicy="no-referrer"><br><img alt="IMG-6F9B9723234526FA25D540A18D1DC19D-20240919204000501" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6F9B9723234526FA25D540A18D1DC19D-20240919204000501.png" referrerpolicy="no-referrer"><br><img alt="IMG-7478B94BD629BAE1D5C9A4E0491F913E-20240919204002217" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-7478B94BD629BAE1D5C9A4E0491F913E-20240919204002217.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-EC5BE83E08C6AE50547B376BCF01C4F7-20240919204003994" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EC5BE83E08C6AE50547B376BCF01C4F7-20240919204003994.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-B8618EE3C8A285BA51D932B2F305CBA4-20240919204004068" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B8618EE3C8A285BA51D932B2F305CBA4-20240919204004068.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-523C6065555837A481EF528AE366E7B6-20240919204006034" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-523C6065555837A481EF528AE366E7B6-20240919204006034.png" referrerpolicy="no-referrer"><br><br>• BCD码（Binary Coded Decimal ），用4位二进制数来表示1位十进制数<br>
• 例：0001 0011表示13，1000 0101表示85，0001 1010不合法<br>
• 在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法<br>
• BCD码转十进制：DEC=BCD/16*10+BCD%16; （2位BCD）<br>
• 十进制转BCD码：BCD=DEC/10*16+DEC%10; （2位BCD）]]></description><link>2_Areas\C51单片机\时钟芯片DS1302.html</link><guid isPermaLink="false">2_Areas/C51单片机/时钟芯片DS1302.md</guid><pubDate>Sun, 27 Oct 2024 03:47:07 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAA2F70BCAA53634B4D216B6134ED330-20240919203953285.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAA2F70BCAA53634B4D216B6134ED330-20240919203953285.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[数码管]]></title><description><![CDATA[ 
 <br>数码管介绍<br>
• LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二 极管封装在一起组成“8”字型的器件<br><img alt="IMG-510A349B1FC1054F9A9D512396A52309-20240919203953283" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-510A349B1FC1054F9A9D512396A52309-20240919203953283.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-3F9F78706A367BDD2205C018D9D0B1F0-20240919203954485" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3F9F78706A367BDD2205C018D9D0B1F0-20240919203954485.png" referrerpolicy="no-referrer"><br>
数码管分为共阳极和共阴极.<br>
<img alt="IMG-A9BD3F2F11356CD3BBB7658A1CA8A20F-20240919203956522" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A9BD3F2F11356CD3BBB7658A1CA8A20F-20240919203956522.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-A2BB54F543F1EA12DEB9F0C4017F5C07-20240919203956549" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A2BB54F543F1EA12DEB9F0C4017F5C07-20240919203956549.png" referrerpolicy="no-referrer"><br><img alt="IMG-056A97B97536CEDDF8A086E3F91A5DAE-20240919203958674" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-056A97B97536CEDDF8A086E3F91A5DAE-20240919203958674.png" referrerpolicy="no-referrer"><br>同一时刻, 数码管只能显示一个相同的数字, 为了使每个位置的数码管显示不同的数字, 可以让它们交替显示, 频率足够快时在人眼看了就是同时显示不同数字. 这种方法称为动态数码管显示<br><br>QX-Mini51的共阳极数码管<br>
<img alt="IMG-72EEAA459C65B619ED89FAB11F58D6C0-20240919203958718" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-72EEAA459C65B619ED89FAB11F58D6C0-20240919203958718.png" referrerpolicy="no-referrer"><br>HC6800-ES V2.0的共阴极数码管<br>
<img alt="IMG-1453556191BE438B7EC65B2BEFADE98E-20240919204000450" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1453556191BE438B7EC65B2BEFADE98E-20240919204000450.png" referrerpolicy="no-referrer"><br><br><br>//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
<br><br>//数码管显示子函数
void Nixie(unsigned char Location,Number)
{
    switch(Location)        //位码输出
    {
        case 1:P2_4=1;P2_3=1;P2_2=1;break;
        case 2:P2_4=1;P2_3=1;P2_2=0;break;
        case 3:P2_4=1;P2_3=0;P2_2=1;break;
        case 4:P2_4=1;P2_3=0;P2_2=0;break;
        case 5:P2_4=0;P2_3=1;P2_2=1;break;
        case 6:P2_4=0;P2_3=1;P2_2=0;break;
        case 7:P2_4=0;P2_3=0;P2_2=1;break;
        case 8:P2_4=0;P2_3=0;P2_2=0;break;
    }
    P0=NixieTable[Number];    //段码输出
    Delay(1);                //显示一段时间
    P0=0x00;                //段码清0，消影
}

<br><br>void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count1,T0Count2,T0Count3;
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值

	T0Count2++;
	if(T0Count2&gt;=2)
	{
		T0Count2=0;
		Nixie_Loop();//2ms调用一次数码管驱动函数
	}
}
<br>#include &lt;REGX52.H&gt;
#include "Delay.h"

//数码管显示缓存区
unsigned char Nixie_Buf[9]={0,10,10,10,10,10,10,10,10};

//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x00,0x40};

/**
  * @brief  设置显示缓存区
  * @param  Location 要设置的位置，范围：1~8
  * @param  Number 要设置的数字，范围：段码表索引范围
  * @retval 无
  */
void Nixie_SetBuf(unsigned char Location,Number)
{
	Nixie_Buf[Location]=Number;
}

/**
  * @brief  数码管扫描显示
  * @param  Location 要显示的位置，范围：1~8
  * @param  Number 要显示的数字，范围：段码表索引范围
  * @retval 无
  */
void Nixie_Scan(unsigned char Location,Number)
{
	P0=0x00;				//段码清0，消影
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
}

/**
  * @brief  数码管驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Nixie_Loop(void)
{
	static unsigned char i=1;
	Nixie_Scan(i,Nixie_Buf[i]);
	i++;
	if(i&gt;=9){i=1;}
}

]]></description><link>2_Areas\C51单片机\数码管.html</link><guid isPermaLink="false">2_Areas/C51单片机/数码管.md</guid><pubDate>Sun, 27 Oct 2024 03:47:12 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-510A349B1FC1054F9A9D512396A52309-20240919203953283.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-510A349B1FC1054F9A9D512396A52309-20240919203953283.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[数字温度传感器DS18B20]]></title><description><![CDATA[ 
 <br><br><br>
<br>DS18B20(DALLAS 18B20)是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点
<br>测温范围：-55°C 到 +125°C
<br>通信接口：1-Wire（单总线）
<br>其它特征：可形成总线结构、内置温度报警功能、可寄生供电
<br><img alt="IMG-1935E027EB046E7BBB509E90E260D4F6-20240919203953281" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1935E027EB046E7BBB509E90E260D4F6-20240919203953281.png" referrerpolicy="no-referrer"><br>
to92封装,和三极管封装一样,注意区分<br><img alt="IMG-ACF8EC9FB45F949C1AB82D4F33C2EE53-20240919203954452" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ACF8EC9FB45F949C1AB82D4F33C2EE53-20240919203954452.png" referrerpolicy="no-referrer"><br><img alt="IMG-57BD611D4045507C47195E501A02300F-20240919203956450" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-57BD611D4045507C47195E501A02300F-20240919203956450.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-B97567EBA9DAA2BE4A7335DACE194869-20240919203956481" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B97567EBA9DAA2BE4A7335DACE194869-20240919203956481.png" referrerpolicy="no-referrer"><br><img alt="IMG-3AAF45D1529ED91653631C6B31F7B996-20240919203958581" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3AAF45D1529ED91653631C6B31F7B996-20240919203958581.png" referrerpolicy="no-referrer"><br>和I2C总线通信一样,有一个4.7K的上拉电阻,不过这里是单总线通信.<br>下面是开发板上的DS18B20模块,没有上拉电阻,只能使用外部供电.<br>
<img alt="IMG-476EB3778FDD32E02DF4FE700F82D369-20240919203958614" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-476EB3778FDD32E02DF4FE700F82D369-20240919203958614.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-189BC8D22E2F72BBB06FE14163B6F616-20240919204000385" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-189BC8D22E2F72BBB06FE14163B6F616-20240919204000385.png" referrerpolicy="no-referrer"><br>
<br>供电结构
<br>64-BIT ROM：作为器件地址，用于总线通信的寻址
<br>SCRATCHPAD（暂存器）：用于总线的数据交互
<br>TEMPERATURE SENSOR 温度传感器
<br>EEPROM：用于保存温度触发阈值和配置参数
<br><br><img alt="IMG-4804FB2664FD195B508A1E1BB1CDC816-20240919204002085" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4804FB2664FD195B508A1E1BB1CDC816-20240919204002085.png" referrerpolicy="no-referrer"><br>
<br>Byte 0-1 这2位构成温度的数值,默认值85
<br><br>
<br>初始化：从机复位，主机判断从机是否响应
<br>ROM操作：ROM指令+本指令需要的读写操作

<br>SKIP ROM 跳过,不论地址是否匹配,直接与从机通信
<br>[CCh]表示指令使用十六进制0xCC


<br>功能操作：功能指令+本指令需要的读写操作

<br>CONVERT 开始温度变换,启动温度传感器,读取温度到暂存器
<br>READ SCRATCHPAD 读取暂存器,如果只想读温度,只需要读两个字节.


<br><img alt="IMG-9A9E8E0A0B7ED862AA39525FD6F1A486-20240919204002116" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9A9E8E0A0B7ED862AA39525FD6F1A486-20240919204002116.png" referrerpolicy="no-referrer"><br><br><br><br><br>
<br>
温度变换：初始化→跳过ROM →开始温度变换<br>
<img alt="IMG-5500251CA1F252D6BE1F8D45F4D3D7F1-20240919204003892" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5500251CA1F252D6BE1F8D45F4D3D7F1-20240919204003892.png" referrerpolicy="no-referrer">

<br>
温度读取：初始化→跳过ROM →读暂存器→连续的读操作<br>
<img alt="IMG-73A194CAE2FEC3FEF2C72E5A8A45FED6-20240919204003932" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-73A194CAE2FEC3FEF2C72E5A8A45FED6-20240919204003932.png" referrerpolicy="no-referrer">

<br><br><img alt="IMG-9BBD1657156BC9B7AFC39A68A5D7189D-20240919204005732" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9BBD1657156BC9B7AFC39A68A5D7189D-20240919204005732.png" referrerpolicy="no-referrer"><br>
<br>LS BYTE: 温度低8位数据
<br>MS BYTE: 温度高8位数据
<br>BIT 11-15 : 5个温度的符号位
<br>BIT  4-10 : 7个温度的整数位
<br>BIT  0-3  : 4个温度的小数位
<br>下表是举例

<br><img alt="IMG-9F11643AABED4A7A6827F2FB2EB5EBD3-20240919204005774" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9F11643AABED4A7A6827F2FB2EB5EBD3-20240919204005774.png" referrerpolicy="no-referrer">


<br><br><br>#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "DS18B20.h"
#include "Delay.h"

float T;

void main()
{
	DS18B20_ConvertT();		//上电先转换一次温度，防止第一次读数据错误
	Delay(1000);			//等待转换完成
	LCD_Init();
	LCD_ShowString(1,1,"Temperature:");
	while(1){
	
	}
}
<br><br>DS18B20_ConvertT();	//转换温度
T=DS18B20_ReadT();	//读取温度
<br><br>
<br>显示正负号
<br>显示整数部分

<br>显示变量T的前三位


<br>显示小数点
<br>显示小数部分

<br>T是一个浮点数, LCD需要整数作为参数
<br>T*10000 将小数点后移4位,(unsigned long) 转化为长整型,%10000 获取整数后4位.如此便取得小数部分.


<br>if(T&lt;0)				//如果温度小于0
{
    LCD_ShowChar(2,1,'-');	//显示负号
    T=-T;			//将温度变为正数
}
else				//如果温度大于等于0
{
    LCD_ShowChar(2,1,'+');	//显示正号
}
LCD_ShowNum(2,2,T,3);		//显示温度整数部分
LCD_ShowChar(2,5,'.');		//显示小数点
LCD_ShowNum(2,6,(unsigned long)(T*10000)%10000,4);//显示温度小数部分
<br><br>#include &lt;REGX52.H&gt;
#include "OneWire.h"

//DS18B20指令
#define DS18B20_SKIP_ROM			0xCC
#define DS18B20_CONVERT_T			0x44
#define DS18B20_READ_SCRATCHPAD 	0xBE

<br><br><br>
<br>单总线初始化,开始通信
<br>发送ROM指令-跳过
<br>发送功能指令-温度变换
<br>/**
  * @brief  DS18B20开始温度变换
  * @param  无
  * @retval 无
  */
void DS18B20_ConvertT(void)
{
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_CONVERT_T);
}
<br><br>
<br>单总线初始化
<br>发送跳过指令
<br>发送读取暂存器指令
<br>利用单总线接收数据
<br>Temp/16.0 相当于小数点向前移动4位,因为16是2^4.

<br>Temp/16 则是舍弃后4位.


<br>/**
  * @brief  DS18B20读取温度
  * @param  无
  * @retval 温度数值
  */
float DS18B20_ReadT(void)
{
	unsigned char TLSB,TMSB;
	int Temp;
	float T;
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_READ_SCRATCHPAD);
	TLSB=OneWire_ReceiveByte();
	TMSB=OneWire_ReceiveByte();
	Temp=(TMSB&lt;&lt;8)|TLSB;
	T=Temp/16.0;
	return T;
}
<br><br><br>
<br>上电先转换一次温度
<br>读取保存在AT24C02中的温度阈值数据,最大值和最小值

<br>如果阈值超出测量范围,设为默认值;最大值小于最小值也设为默认值


<br>#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "DS18B20.h"
#include "Delay.h"
#include "AT24C02.h"
#include "Key.h"
#include "Timer0.h"

float T,TShow;
char TLow,THigh;
unsigned char KeyNum;

void main()
{
	DS18B20_ConvertT();		//上电先转换一次温度，防止第一次读数据错误
	Delay(1000);			//等待转换完成
	
	THigh=AT24C02_ReadByte(0);	//读取温度阈值数据
	TLow=AT24C02_ReadByte(1);
	if(THigh&gt;125 || TLow&lt;-55 || THigh&lt;=TLow)
	{
		THigh=20;			//如果阈值非法，则设为默认值
		TLow=15;
	}
	
	while(1){
	}
}
<br><br><br>
<br>LCD显示温度的最大值和最小值
<br>void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"T:");
	LCD_ShowString(2,1,"TH:");
	LCD_ShowString(2,9,"TL:");
	LCD_ShowSignedNum(2,4,THigh,3);
	LCD_ShowSignedNum(2,12,TLow,3);
	
	Timer0_Init();
}
<br><br><br>
<br>开启温度转换
<br>读取暂存器的温度
<br>在LCD显示温度
<br>
/*温度读取及显示*/
DS18B20_ConvertT();	//转换温度
T=DS18B20_ReadT();	//读取温度
if(T&lt;0)				//如果温度小于0
{
    LCD_ShowChar(1,3,'-');	//显示负号
    TShow=-T;		//将温度变为正数
}
else				//如果温度大于等于0
{
    LCD_ShowChar(1,3,'+');	//显示正号
    TShow=T;
}
LCD_ShowNum(1,4,TShow,3);		//显示温度整数部分
LCD_ShowChar(1,7,'.');		//显示小数点
LCD_ShowNum(1,8,(unsigned long)(TShow*100)%100,2);//显示温度小数部分
<br><br>
<br>获取按键码;

<br>每隔20ms会扫描一次按键,所以可以随时按下
<br>由于按键码赋值给全局变量Key_KeyNumber,所以Key()也可以使用


<br>K1,K2按键控制温度最大值
<br>K3,K4按键控制温度最小值
<br>显示阈值数据
<br>写入到At24C02中
<br>KeyNum=Key();

//设置阈值
if(KeyNum)
{
    if(KeyNum==1)	//K1按键，THigh自增
    {
        THigh++;
        if(THigh&gt;125){THigh=125;}
    }
    if(KeyNum==2)	//K2按键，THigh自减
    {
        THigh--;
        if(THigh&lt;=TLow){THigh++;}
    }
    if(KeyNum==3)	//K3按键，TLow自增
    {
        TLow++;
        if(TLow&gt;=THigh){TLow--;}
    }
    if(KeyNum==4)	//K4按键，TLow自减
    {
        TLow--;
        if(TLow&lt;-55){TLow=-55;}
    }
    LCD_ShowSignedNum(2,4,THigh,3);	//显示阈值数据
    LCD_ShowSignedNum(2,12,TLow,3);
    AT24C02_WriteByte(0,THigh);		//写入到At24C02中保存
    Delay(5);
    AT24C02_WriteByte(1,TLow);
    Delay(5);
}
<br><br>通过定时器中断获取按键码, 再通过Key()函数调用<br><br>LCD显示屏以十进制显示数字<br>/**
  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-32768~32767
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
<br><br>AT24C02的写入操作,在地址0处写入最大值,在地址1处写入最小值<br><br>
<br>当温度大于最大值时,LCD显示字符串OV:H
<br>当温度小于最小值时,LCD显示字符串OV:L
<br>/*阈值判断及显示*/

if(T&gt;THigh)			//越界判断
{
    LCD_ShowString(1,13,"OV:H");
}
else if(T&lt;TLow)
{
    LCD_ShowString(1,13,"OV:L");
}
else
{
    LCD_ShowString(1,13,"    ");
}
<br>]]></description><link>2_Areas\C51单片机\数字温度传感器DS18B20.html</link><guid isPermaLink="false">2_Areas/C51单片机/数字温度传感器DS18B20.md</guid><pubDate>Sun, 27 Oct 2024 03:47:04 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1935E027EB046E7BBB509E90E260D4F6-20240919203953281.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1935E027EB046E7BBB509E90E260D4F6-20240919203953281.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[通信协议]]></title><description><![CDATA[ 
 <br><br>• 通信协议：制定通信的规则，通信双方按照协议规则进行数据收发<br><br>• 通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统<br><br><br>• 全双工：通信双方可以在同一时刻互相传输数据<br>
• 半双工：通信双方可以互相传输数据，但必须分时复用一根数据线<br>
• 单工：通信只能有一方发送到另一方，不能反向传输<br>
• 异步：通信双方各自约定通信速率<br>
• 同步：通信双方靠一根时钟线来约定通信速率<br>
• 总线：连接各个设备的数据传输线路（类似于一条马路，把路边各住户连接起来，使住户可以相互交流）<br><br>51单片机内部自带UART（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现单片机的串口通信。<br><br><br><br>
<br>简单双向串口通信有两根通信线（发送端TXD和接收端RXD）
<br>TXD与RXD要交叉连接
<br>当只需单向的数据传输时，可以直接一根通信线
<br>当电平标准不一致时，需要加电平转换芯片
<br><img alt="IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226.png" referrerpolicy="no-referrer"><br>Tip
TXD: transmit exchange data
3<br><br><br><br><br>
<br>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：
<br>TTL电平：+5V表示1，0V表示0
<br>RS232电平：-3~-15V表示1，+3~+15V表示0
<br>RS485电平：两线压差+2~+6V表示1，-2~-6V表示0（差分信号）
3<br><br><br><br><br>
<br>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线
<br>两根通信线：串行时钟SCL（Serial Clock）、串行数据SDA（Serial Data）
<br>同步、半双工，带数据应答
<br>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度
<br><img alt="IMG-635208D0B5C8384086290A85E66F8216-20240919203953270" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-635208D0B5C8384086290A85E66F8216-20240919203953270.png" referrerpolicy="no-referrer"><br><img alt="IMG-D2757E8CEA0BE0CA5E5916F3ECE44910-20240919203953899" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D2757E8CEA0BE0CA5E5916F3ECE44910-20240919203953899.png" referrerpolicy="no-referrer"><br><img alt="IMG-CB990E5504180C98F363D6CDB0BD5E2D-20240919203953921" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CB990E5504180C98F363D6CDB0BD5E2D-20240919203953921.png" referrerpolicy="no-referrer">2<br><img alt="IMG-0524279143C0DF7B00173282275FE692-20240919203953307" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0524279143C0DF7B00173282275FE692-20240919203953307.png" referrerpolicy="no-referrer"><br><br><br><br><br><br>
<br>单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线
<br>一根通信线：DQ
<br>异步、半双工
<br>单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线
<br><img alt="IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-88E3736AE8137029B84699ACDB05F6CC-20240919203953279.png" referrerpolicy="no-referrer"><br><img alt="IMG-23EB6150CB5847E1A5BBB7EEC4975C58-20240919203954335" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-23EB6150CB5847E1A5BBB7EEC4975C58-20240919203954335.png" referrerpolicy="no-referrer">2<br><img alt="IMG-CC34C36DC688D8293481EC11D4D41151-20240919203955306" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CC34C36DC688D8293481EC11D4D41151-20240919203955306.png" referrerpolicy="no-referrer"><br>]]></description><link>2_Areas\C51单片机\通信协议.html</link><guid isPermaLink="false">2_Areas/C51单片机/通信协议.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-57F14A6E9524EB06B37717DBAD6CD328-20240919203956226.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[移位寄存器74HC595]]></title><description><![CDATA[ 
 <br><br><a data-href="74HC595芯片中文资料.pdf" href="74HC595芯片中文资料.pdf" class="internal-link" target="_self" rel="noopener nofollow">74HC595芯片中文资料.pdf</a><br>
<a data-href="74HC595.pdf" href="74HC595.pdf" class="internal-link" target="_self" rel="noopener nofollow">74HC595.pdf</a><br><img alt="IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292.png" referrerpolicy="no-referrer"><br><img alt="IMG-8BE49BAC86CA6F0F6D75B24F30B5CA87-20240919203954789" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8BE49BAC86CA6F0F6D75B24F30B5CA87-20240919203954789.png" referrerpolicy="no-referrer"><br><img alt="IMG-2AE86EBE95D0A48F21D12EAC9769F13E-20240919203956826" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2AE86EBE95D0A48F21D12EAC9769F13E-20240919203956826.png" referrerpolicy="no-referrer"><br>OE: 输出使能,低电平有效.<br>
RCLK: 寄存器时钟<br>
ARCLR: 串行清零,低电平有效<br>
SRCLK: 串行时钟<br>
SER: 串行数据<br>• 74HC595是串行输入并行输出的移位寄存器，可用3根线输入串行数据，8根线输出并行数据，多片级联后，可输出16位、24位、32位等，常用于IO口扩展。<br>RCLK: 寄存器时钟<br>
SRCLK: 串行时钟<br>
SER: 串行数据<br>
<img alt="IMG-DF0F7279512A08017276413ECFFC4604-20240919203959100" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DF0F7279512A08017276413ECFFC4604-20240919203959100.png" referrerpolicy="no-referrer"><br>Tip
如果不采用74HC595, 无法驱动点阵屏,因为单片机提供的I/O口是弱上拉. 
<br>SER输入一位数据,SRCLK上电,寄存器数据向下移位<br>
如此反复,直到输入一个字节,RCLK上电,数据锁存,即从左边搬到右边输出寄存器.<br><br>#include &lt;REGX52.H&gt;

sbit RCK=P3^5;        //RCLK
sbit SCK=P3^6;        //SRCLK
sbit SER=P3^4;        //SER

#define MATRIX_LED_PORT        P0

/**
  * @brief  74HC595写入一个字节
  * @param  Byte 要写入的字节
  * @retval 无
  */
  
void _74HC595_WriteByte(unsigned char Byte)
{
    unsigned char i;
    for(i=0;i&lt;8;i++)
    {
        SER=Byte&amp;(0x80&gt;&gt;i);  
        SCK=1;
        SCK=0;
    }
    
    RCK=1;
    RCK=0;
}

]]></description><link>2_Areas\C51单片机\移位寄存器74HC595.html</link><guid isPermaLink="false">2_Areas/C51单片机/移位寄存器74HC595.md</guid><pubDate>Sun, 27 Oct 2024 03:47:06 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[译码器74HC138]]></title><description><![CDATA[ 
 <br><br> D74HC138D 是一种三通道输入、八通道输出译码器,主要应用于消费类电子产品。<br>主要特性<br>
<br>采用 CMOS 工艺
<br>低功耗
<br>工作电压：3.0V—5.0V
<br>封装形式：SOP16
<br><img alt="IMG-320BDC549EA2B68B943719DA4A8BE4ED-20240919203953302" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-320BDC549EA2B68B943719DA4A8BE4ED-20240919203953302.png" referrerpolicy="no-referrer"><br>应用领域<br>
<br>适用于数字电路中的 3—8 译码功能
<br>管脚说明<br><img alt="IMG-F002AC77EF2FE58620BC93BEDECDCA13-20240919203955067" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F002AC77EF2FE58620BC93BEDECDCA13-20240919203955067.png" referrerpolicy="no-referrer"><br><br>switch(Location)        //位码输出
{
    case 1:P2_4=1;P2_3=1;P2_2=1;break;
    case 2:P2_4=1;P2_3=1;P2_2=0;break;
    case 3:P2_4=1;P2_3=0;P2_2=1;break;
    case 4:P2_4=1;P2_3=0;P2_2=0;break;
    case 5:P2_4=0;P2_3=1;P2_2=1;break;
    case 6:P2_4=0;P2_3=1;P2_2=0;break;
    case 7:P2_4=0;P2_3=0;P2_2=1;break;
    case 8:P2_4=0;P2_3=0;P2_2=0;break;
}
]]></description><link>2_Areas\C51单片机\译码器74HC138.html</link><guid isPermaLink="false">2_Areas/C51单片机/译码器74HC138.md</guid><pubDate>Sun, 27 Oct 2024 03:47:08 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-320BDC549EA2B68B943719DA4A8BE4ED-20240919203953302.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-320BDC549EA2B68B943719DA4A8BE4ED-20240919203953302.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[运算放大器]]></title><description><![CDATA[ 
 <br><br>
<br>运算放大器（简称“运放”）是具有很高放大倍数的放大电路单元。<br>
内部集成了差分放大器、电压放大器、功率放大器三级放大电路，<br>
是一个性能完备、功能强大的通用放大电路单元，由于其应用十分<br>
广泛，现已作为基本的电路元件出现在电路图中
<br>运算放大器可构成的电路有：电压比较器、反相放大器、同相放大<br>
器、电压跟随器、加法器、积分器、微分器等
<br>运算放大器电路的分析方法：虚短、虚断（负反馈条件下）

<br>虚短: 虚短就是两个输入端电势相同,相当于短路

<br>在负反馈条件下可以通过一个输入端的电势改变另一个输入端的电势.


<br>虚断: 虚断就是输入端不再有电流流入或流出,相当于断路

<br>在负反馈条件下输入电路负载电流会等于反馈电流负载电流.




<br><img alt="IMG-63991779B5981E44EDA43F5088A779CD-20240919203953307" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-63991779B5981E44EDA43F5088A779CD-20240919203953307.png" referrerpolicy="no-referrer"><br><img alt="IMG-2B0CD000856CA3631D939E9803126F34-20240919203955448" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2B0CD000856CA3631D939E9803126F34-20240919203955448.png" referrerpolicy="no-referrer"><br><br><br>
<br>运算放大器会无限放大两个输入端的差值,但由于供电有限,只能放大到极限值.
<br>
<br><img alt="IMG-455B59D543407C8333D8A3FBB14B6340-20240919203955476" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-455B59D543407C8333D8A3FBB14B6340-20240919203955476.png" referrerpolicy="no-referrer"><br><br>
<br>这是一个负反馈电路,可以利用虚短和虚断分析

<br>输入信号后,电路会不断发生变化,负反馈电路会使电路系统最终进入稳态
<br>电路系统进入稳态后,两个输入端电势相等都为0v,虚短,因为同相输入端接的GND.

<br>稳态时输入端电势为什么会相等可以参考比较放大器,只有相等,系统才能稳定


<br>反相输入端与交叉点处虚断,R1和R2有电流,大小相同方向相同,

<br>交叉点处电势也为0v,所以反相输入端没有电流流入或流出
<br>电流的大小等于输入电压与R1之比
<br>反馈电路R2的电流方向与R1相同,输出端电势向相反方向变化

<br>当R1两端电压变大时,R1和R2的电流变大,R2两端电压也变大;因为R1另一端虚短,电势保持为0v,所以 控制R1两端电压
<br> 升高时,输出端电势降低
<br> 降低时,输出端电势升高


<br>输出端电势变化大小为电流大小与R2的乘积.




<br>
<br><img alt="IMG-259C3CC7B086E0F0E55D53D9128F0F45-20240919203957248" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-259C3CC7B086E0F0E55D53D9128F0F45-20240919203957248.png" referrerpolicy="no-referrer"><br><br>
<br>这是一个负反馈电路,可以利用虚短和虚断分析

<br>输入信号后,电路会不断发生变化,负反馈电路会使电路系统最终进入稳态
<br>电路系统进入稳态后,两个输入端电势相等都为,虚短.
<br>反相输入端与交叉点处虚断,R1和R2有电流,大小相同方向相同,

<br>交叉点处电势也为,所以反相输入端没有电流流入或流出
<br>电流的大小等于与R1之比,因为R1另一端接的GND.
<br>负反馈电路R2的电流方向与R1相同,输出端的电势变化方向与方向相同.

<br>当R1两端电压变大时,电流变大,R2两端电压也会变大,而 控制R1两端电压.
<br>当 降低时,输出端电势降低
<br>当 升高时,输出端电势升高


<br>负反馈电路R2两端电压大小为电流大小与R2的乘积
<br>输出端电势为R2两端电势加交叉点的电势.




<br>
<br><img alt="IMG-85C02958775A45E81E96E6AE62BA61EE-20240919203957291" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-85C02958775A45E81E96E6AE62BA61EE-20240919203957291.png" referrerpolicy="no-referrer"><br><br>
<br>这是一个负反馈电路,可以利用虚短和虚断分析

<br>输入信号后,电路会不断发生变化,负反馈电路会使电路系统最终进入稳态
<br>当系统进入稳态后,两个输入端电势相等都为 ,虚短.
<br>由于反相输入端没有接其他输入,输出端电势与输入端电势相同都是,反馈电路没有电流通过,虚断.
<br>所以电路不具有放大作用,但是驱动能力会增强


<br>
<br><img alt="IMG-0A7AB52E74B3684C2074943A2AAD24AB-20240919203959432" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0A7AB52E74B3684C2074943A2AAD24AB-20240919203959432.png" referrerpolicy="no-referrer"><br><br>
<br>运算放大器（简称“运放”）是具有很高放大倍数的电路单元。
<br>在实际电路中，通常结合反馈网络共同组成某种功能模块。
<br>由于早期应用于模拟计算机中用以实现数学运算，因而得名“运算放大器”。
<br><img alt="IMG-F450F7058CBB06377F73F29D34E67259-20240919203959468" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F450F7058CBB06377F73F29D34E67259-20240919203959468.png" referrerpolicy="no-referrer"><br><br>
<br>
放大器的差分输入包括一个非反相输入电压与的反相输入电压；

<br>
理想的运算放大器放大只有两个电压的差，这就是所谓的"差模输入电压"。

<br>
运算放大器的的输出电压由下式给出：

<br>
<br>其中代表运算放大器的开回路差动增益。


<br><br>由於运算放大器的开回路增益非常高，对于集成运算放大器可以达到100,000以上，因此就算输入端的差动訊號很小，仍然會讓输出訊號飽和，導致非線性的失真出現。因此运算放大器很少以开回路組態出現在電路系統中，少數的例外是用运算放大器做比較器進行滿幅输出，输出值通常為逻辑移位|邏輯準位的「0」與「1」。<br>
<img alt="IMG-BF2E1A8ADADB53DE1453AB5C22D60A2A-20240919204001145" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BF2E1A8ADADB53DE1453AB5C22D60A2A-20240919204001145.png" referrerpolicy="no-referrer"><br>
开环组态的运算放大器可作为比较器使用<br><br><br>將运算放大器的反向输入端與输出端連接起來，放大器電路就處在負回授組態的狀況，此時通常可以將電路簡單地稱為閉迴路放大器。閉迴路放大器依據输入訊號進入放大器的端點，又可分為反相（inverting）與非反相（non-inverting）兩種。<br>必須注意的是，所有閉迴路放大器都是运算放大器的負回授組態。<br><br>反相閉迴路放大器<br>
<img alt="IMG-107DCF7D8509011BC98F12B02DADB5A5-20240919204001180" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-107DCF7D8509011BC98F12B02DADB5A5-20240919204001180.png" referrerpolicy="no-referrer"><br>
右圖是一個反相閉迴路放大器的電路。假設這個閉迴路放大器使用理想的运算放大器，則因為其开回路增益為無限大，所以运算放大器的兩输入端為虛接地（virtual ground）。又因為输入阻抗無限大，自到之電流，等於到之電流，所以:<br>
:<br>'''输入电阻'''等于，<br>'''电压'''关系：<br>
:<br><br>Image:Operational amplifier noninverting.svg|thumb|非反相閉迴路放大器<br>
<img alt="IMG-F325D796335578128BC48EB6151CC9FE-20240919204002786" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F325D796335578128BC48EB6151CC9FE-20240919204002786.png" referrerpolicy="no-referrer"><br>右圖是一個非反相閉迴路放大器的電路。负反馈通过分压电阻 ,  决定了''闭环增益'' 。当  刚好足以“接近并改变与  相同的反相输入”时将建立平衡。因此整个电路的电压增益是 。作为一个简单的例子，当  = 1 V且 时， 就会是 2 V，恰好能够让  保持在需要的 1 V。由于反馈是由 ,  网络提供的，这就是一个''闭环''电路。<br>分析这个电路的增益的另一种方法是通过以下假设（通常是有效的）：Jacob Millman, ''Microelectronics: Digital and Analog Circuits and Systems'', McGraw-Hill, 1979, ISBN 978-0-07-042327-5, pp. 523-527<br>
<br>当运算放大器工作于線性泛函|线性（即非饱和）模式，非反相 (+) 端子和反相 (−) 端子是小到可以忽略的。
<br>(+) 和 (−) 端子之间的输入阻抗比电路中任何其他电阻都大很多。
<br>输入信号  既出现在 (+) 也出现在 (−) 端子，导致流过  的电流 ''i'' 等于 .<br>
: <br><br>會使用正回授的情況有：<br>
<br>作為有遲滯的比較器，形成施密特觸發器|施密特電路
<br>產生振盪
]]></description><link>2_Areas\C51单片机\运算放大器.html</link><guid isPermaLink="false">2_Areas/C51单片机/运算放大器.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-63991779B5981E44EDA43F5088A779CD-20240919203953307.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-63991779B5981E44EDA43F5088A779CD-20240919203953307.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[直流电机介绍]]></title><description><![CDATA[ 
 <br><br>
<br>直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，当电极正接时，电机正转，当电极反接时，电机反转
<br>直流电机主要由永磁体（定子）、线圈（转子）和换向器组成
<br>除直流电机外，常见的电机还有步进电机、舵机、无刷电机、空心杯电机等
<br><img alt="IMG-44628B8FFFCB44D9F634A16FB8055ED7-20240919203953290" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-44628B8FFFCB44D9F634A16FB8055ED7-20240919203953290.png" referrerpolicy="no-referrer"><br><img alt="IMG-548246B0BFD03962C1EA5246A168E1B3-20240919203954667" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-548246B0BFD03962C1EA5246A168E1B3-20240919203954667.png" referrerpolicy="no-referrer"><br><img alt="IMG-ED5A4C414410B659060BE11579B03945-20240919203954691" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-ED5A4C414410B659060BE11579B03945-20240919203954691.png" referrerpolicy="no-referrer"><br><br><br>
<br>大功率器件直接驱动

<br>ULN2003D芯片
<br>IN : 输入
<br>Q1 PNP : PNP型三极管,低电平时导通
<br>D1 : 续流二极管,用于保护电路,因为电机是"感性"负载元件,可能会产生高于电源的电压导致三极管损坏.

<br>当电路导通时,电机正常运作
<br>当电路断开时,电机会感应出电流,二极管的存在使电机正负极形成回路,在回路释放了这一感应电流.


<br><img alt="IMG-705F9009848F29630FA3F6362A598F8F-20240919203956686" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-705F9009848F29630FA3F6362A598F8F-20240919203956686.png" referrerpolicy="no-referrer">


<br><br>
<br>H桥驱动

<br>可以改变电机的电流方向
<br>Q1和Q4导通时,电机电流向右
<br>Q2和Q3导通时,电机电流向左
<br><img alt="IMG-A0DDDA4B4C9137ACEBE6ED1912CBDCD5-20240919203956717" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A0DDDA4B4C9137ACEBE6ED1912CBDCD5-20240919203956717.png" referrerpolicy="no-referrer">


<br><br>
<br>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向
<br><img alt="IMG-63E65C63A29B1A24F32B405232BE17AE-20240919203958973" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-63E65C63A29B1A24F32B405232BE17AE-20240919203958973.png" referrerpolicy="no-referrer"><br><img alt="IMG-9048245CF40FF0612AC85ACF70E6F04C-20240919203959017" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-9048245CF40FF0612AC85ACF70E6F04C-20240919203959017.png" referrerpolicy="no-referrer"><br><img alt="IMG-DAE1387C0798F643DD13D48AF53ECFB6-20240919204000669" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DAE1387C0798F643DD13D48AF53ECFB6-20240919204000669.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-73793DA5F47A5333D9D47B02ADBE2F9E-20240919204002402" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-73793DA5F47A5333D9D47B02ADBE2F9E-20240919204002402.png" referrerpolicy="no-referrer"><br><img alt="IMG-B874E695A13F1B8A47C747D6B5D781C0-20240919204004317" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B874E695A13F1B8A47C747D6B5D781C0-20240919204004317.png" referrerpolicy="no-referrer"><br><br>
<br>DRV8833电机驱动模块可直接替换TB6612驱动模块，管脚基本完全兼容。
<br>尺寸：18* 21mm
<br>输入电压：&nbsp;2.7 V – 10.8 V
<br>单H桥输出电流：1.5A，可驱动2个直流减速电机。
<br>内置过流保护，短路保护，欠压闭锁和过热保护。带低功耗睡眠模式。
<br>用途：可驱动1.5A以下的直流电机和4线步进电机。<br>
<img alt="IMG-E038D3376F62F164E6E034726515768C-20240919204004357" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E038D3376F62F164E6E034726515768C-20240919204004357.png" referrerpolicy="no-referrer" style="width: 300px; max-width: 100%;">
<br><img alt="IMG-81295A8F8B8AC9FC92860F56A719B877-20240919204006279" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-81295A8F8B8AC9FC92860F56A719B877-20240919204006279.png" referrerpolicy="no-referrer" style="width: 300px; max-width: 100%;"><br><br>
<br>管脚说明：  
<br>ANI1：AO1的逻辑输入控制端口，电平0-5V。  
<br>AIN2：AO2的逻辑输入控制端口，电平0-5V。  
<br>BNI1：BO1的逻辑输入控制端口，电平0-5V。  
<br>BIN2：BO2的逻辑输入控制端口，电平0-5V。  
<br>AO1、AO2为1路H桥输出端口，接一个直流电机的两个脚。  
<br>BO1、BO2为2路H桥输出端口，接另一个外直接电机的两个脚。  
<br>GND：接地。
<br>VM：芯片和电机供电脚，电压范围2.7 V – 10.8 V。
<br>STBY：接地或悬空芯片不工作，无输出，接5V工作；电平0-5V。
<br>NC：空脚
<br><img alt="IMG-74939A2F4627978DD2DBC9BC48D19707-20240919204007183" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-74939A2F4627978DD2DBC9BC48D19707-20240919204007183.png" referrerpolicy="no-referrer"><br><br>
<br>用PWM对电机调速,通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量.
<br>不能用电位器调速.<br>
- 使用电位器串联调速时,电位器需要调到小电阻时,才能驱动电机,但电机旋转时电路会有较大的电流,这会烧毁电位器.<br>
<img alt="IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-177004F791CDABD68DBBE5442B727B76-20240919203953296.png" referrerpolicy="no-referrer">
<br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Timer0.h"

sbit Motor=P1^0;

unsigned char Counter,Compare;  //计数值和比较值，用于输出PWM
unsigned char KeyNum,Speed;

void main()
{
	Timer0_Init();
	while(1){
	
	}
}
<br><br>
<br>通过按键设置比较值，改变PWM占空比
<br>KeyNum=Key();
if(KeyNum==1)
{
    Speed++;
    Speed%=4;  //档位变化范围在0~3之间
    if(Speed==0){Compare=0;}	//设置比较值，改变PWM占空比
    if(Speed==1){Compare=50;}
    if(Speed==2){Compare=75;}
    if(Speed==3){Compare=100;}
}
Nixie(1,Speed);  //在数码管显示档位
<br>]]></description><link>2_Areas\C51单片机\直流电机.html</link><guid isPermaLink="false">2_Areas/C51单片机/直流电机.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-44628B8FFFCB44D9F634A16FB8055ED7-20240919203953290.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-44628B8FFFCB44D9F634A16FB8055ED7-20240919203953290.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[中断系统]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=1f350eab-5ce9-1510-f0ab-5898c1c19ae3&amp;page=156&amp;rect=110.693,565.578,182.693,589.572" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=1f350eab-5ce9-1510-f0ab-5898c1c19ae3&amp;page=156&amp;rect=110.693,565.578,182.693,589.572" target="_blank">中断系统</a><br>中断系统是为使CPU具有对外界紧急事件的实时处理能力而设置的。<br>当中央处理机CPU正在处理某件事的时候外界发生了紧急事件请求，要求CPU暂停当前的工作，转而去处理这个紧急事件，处理完以后，再回到原来被中断的地方，继续原来的工作，这样的过程称为中断。实现这种功能的部件称为中断系统，请示CPU中断的请求源称为中断源。<br>微型机的中断系统一般允许多个中断源，当几个中断源同时向CPU请求中断，要求为它服务的时候，这就存在CPU优先响应哪一个中断源请求的问题。通常根据中断源的轻重缓急排队，优先处理最紧急事件的中断请求源，即规定每一个中断源有一个优先级别。CPU总是先响应优先级别最高的中断请求。<br>当CPU正在处理一个中断源请求的时候（执行相应的中断服务程序），发生了另外一个优先级比它还高的中断源请求。<br>如果CPU能够暂停对原来中断源的服务程序，转而去处理优先级更高的中断请求源，处理完以后，再回到原低级中断服务程序，这样的过程称为中断嵌套。这样的中断系统称为多级中断系统，没有中断嵌套功能的中断系统称为单级中断系统<br><br><img alt="IMG-955D36FD86C972BE08CDBCEE9556C6BA-20240919203953274" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-955D36FD86C972BE08CDBCEE9556C6BA-20240919203953274.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-D0EA8CE46A88F78D54F76B4FC554647B-20240919203954091" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D0EA8CE46A88F78D54F76B4FC554647B-20240919203954091.png" referrerpolicy="no-referrer"><br><img alt="IMG-53812066AA993D33CB0F85A3A5B7C402-20240919203954118" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-53812066AA993D33CB0F85A3A5B7C402-20240919203954118.png" referrerpolicy="no-referrer"><br>Info
中断处理程序运行时间不能太长,如<a data-href="2_Areas/C51单片机/定时器#实例-定时器时钟" href="2_Areas\C51单片机\定时器.html#实例-定时器时钟" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C51单片机/定时器 &gt; 实例-定时器时钟</a>中LCD显示函数运行时间太长,不适合放在中断处理程序中.
<br><br>• 中断源个数：8个（外部中断0 INT0、定时器0中断 Timer 0、外部中断1 INT1、定时器1中断 Timer1、串口中断 UART、定时器2中断 Timer2、外部中断2 INT2、外部中断3 INT3）<br>
• 中断优先级个数：4个<br>
• 中断号：<img alt="IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093.png" referrerpolicy="no-referrer"><br>
• 注意：中断的资源和单片机的型号是关联在一起的，不同的型号可能会有不同的中断资源，例如中断源个数不同、中断优先级个数不同等等<br><br><img alt="IMG-700CFCA8AC732B12C35E68A68D667EDA-20240919203957901" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-700CFCA8AC732B12C35E68A68D667EDA-20240919203957901.png" referrerpolicy="no-referrer"><br>
自然优先级<br>
<img alt="IMG-FAF9F1CC3C5959C3132C3996247A6206-20240919203957957" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FAF9F1CC3C5959C3132C3996247A6206-20240919203957957.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=989d3aa1-f461-0b9e-d53e-d631b1c6d12f&amp;page=166&amp;rect=82.943,574.095,157.943,594.090" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=989d3aa1-f461-0b9e-d53e-d631b1c6d12f&amp;page=166&amp;rect=82.943,574.095,157.943,594.090" target="_blank">中断优先级</a>
<br><br><img alt="IMG-A1E365FE7201D2352551968E0F4C733B-20240919203954419" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A1E365FE7201D2352551968E0F4C733B-20240919203954419.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-A2C9A03D6942612CF2DA13A47962DF5D-20240919203959798" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A2C9A03D6942612CF2DA13A47962DF5D-20240919203959798.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-2A7ABEA6C6812D44BD132228B7D5FB36-20240919204001526" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2A7ABEA6C6812D44BD132228B7D5FB36-20240919204001526.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-3D32B0D797F7907C5E5D95436F504615-20240919204003273" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3D32B0D797F7907C5E5D95436F504615-20240919204003273.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-677200CE9CD14441DA3E990645B983D6-20240919204005272" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-677200CE9CD14441DA3E990645B983D6-20240919204005272.png" referrerpolicy="no-referrer"><br>
<img alt="IMG-4204A583A68772D15FC88343BEA3DDC1-20240919204006795" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4204A583A68772D15FC88343BEA3DDC1-20240919204006795.png" referrerpolicy="no-referrer"><br><br><br><a data-href="2_Areas/C51单片机/定时器" href="2_Areas\C51单片机\定时器.html" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C51单片机/定时器</a>5是一种中断源<br>
<img alt="IMG-01FD2CB989FA616C3B73D40DD48B548A-20240919204007416" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-01FD2CB989FA616C3B73D40DD48B548A-20240919204007416.png" referrerpolicy="no-referrer"><br>为了方便讲解，这里使用的中断系统图是传统51单片机的图，STC89C52的中断系统图可参考手册<br><br><br>• STC89C52有4个外部中断<br>
• STC89C52的外部中断有两种触发方式：下降沿触发和低电平触发<br>
• 中断号：<img alt="IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6112AE33970CD6FF342368AA806A8F59-20240919203956093.png" referrerpolicy="no-referrer"><br><img alt="IMG-F62A48EBCD6A8F1C5F226ECE9A868D57-20240919204007460" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-F62A48EBCD6A8F1C5F226ECE9A868D57-20240919204007460.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-CEEADFC4ACFC41EED8D44055F971E8FD-20240919204007759" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CEEADFC4ACFC41EED8D44055F971E8FD-20240919204007759.png" referrerpolicy="no-referrer"><br><img alt="IMG-A89C5B56C583FF8D31768ABDDE3365F4-20240919204007798" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A89C5B56C583FF8D31768ABDDE3365F4-20240919204007798.png" referrerpolicy="no-referrer"><br>
<br>当外部中断服务程序被响应后，中断请求标志位IE0、IE1、IE2和IE3会自动被清0。
<br>TCON寄存器中的IT0/TCON.0、IT1/TCON.2、IT2/XICON.0和IT3/XICON.4决定了外部中断0、1、2和3是低电平触发方式还是下降沿触发方式。

<br>如果ITx = 0(x = 0,1,2,3)，那么系统在INTx(x = 0,1,2,3)脚探测到低电平后可产生外部中断。
<br>如果ITx = 1(x = 0,1,2,3)，那么系统在INTx( x= 0,1,2,3)脚探测下降沿后可产生外部中断。


<br>外部中断0(INT0)、外部中断1(INT1)、外部中断2(INT2)和外部中断3(INT3)还可以用于将单片机从掉电模式唤醒。
<br>
<br>由于系统每个时钟对外部中断引脚采样1次，所以为了确保被检测到，输入信号应该至少维持2个系统时钟。

<br>如果外部中断是仅下降沿触发，要求必须在相应的引脚维持高电平至少1个系统时钟，而且低电平也要持续至少1个系统时钟，才能确保该下降沿被CPU检测到。
<br>如果外部中断是低电平可触发，则要求必须在相应的引脚维持低电平至少2个系统时钟，这样才能确保CPU能够检测到该低电平信号。


<br><br><br>#include &lt;REGX52.H&gt;

/**
  * @brief  外部中断0初始化
  * @param  无
  * @retval 无
  */
void Int0_Init(void)
{
	IT0=1;  //探测下降沿后可产生外部中断
	IE0=0;  //连通中断入口
	EX0=1;
	EA=1;
	PX0=1;  //高级中断入口
}
<br><br>/*外部中断0中断函数模板
void Int0_Routine(void) interrupt 0
{
	
}
*/
<br><br><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Motor.h"
#include "IR.h"

unsigned char Command,Speed;

void main()
{
	Motor_Init();
	IR_Init();
	while(1)
	{

	}
}
<br><br>if(IR_GetDataFlag())	//如果收到数据帧
{
    Command=IR_GetCommand();		//获取遥控器命令码
}
<br><br>if(IR_GetDataFlag()){
    if(Command==IR_0){Speed=0;}		//根据遥控器命令码设置速度
    if(Command==IR_1){Speed=1;}
    if(Command==IR_2){Speed=2;}
    if(Command==IR_3){Speed=3;}
}
Nixie(1,Speed);						//数码管显示速度
<br><br>if(IR_GetDataFlag())	//如果收到数据帧
{
    if(Speed==0){Motor_SetSpeed(0);}	//速度输出
    if(Speed==1){Motor_SetSpeed(50);}
    if(Speed==2){Motor_SetSpeed(75);}
    if(Speed==3){Motor_SetSpeed(100);}
}
<br><br><br><br>]]></description><link>2_Areas\C51单片机\中断系统.html</link><guid isPermaLink="false">2_Areas/C51单片机/中断系统.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-955D36FD86C972BE08CDBCEE9556C6BA-20240919203953274.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-955D36FD86C972BE08CDBCEE9556C6BA-20240919203953274.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[C51单片机]]></title><description><![CDATA[ 
 <br>QX-Mini51<br><br>HC6800-ES V2.0<br><br>普中A2<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<a data-href="2_Areas/C语言/C程序结构" href="2_Areas\C语言\C程序结构.html" class="internal-link" target="_self" rel="noopener nofollow">2_Areas/C语言/C程序结构</a>4
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>]]></description><link>2_Areas\C51单片机\C51单片机.html</link><guid isPermaLink="false">2_Areas/C51单片机/C51单片机.md</guid><pubDate>Wed, 20 Nov 2024 08:19:38 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8F9F067232494A01DB02CBE7E5917BBC-20240919203953446.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8F9F067232494A01DB02CBE7E5917BBC-20240919203953446.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43C TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.053em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D436 TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span>总线介绍]]></title><description><![CDATA[ 
 <br><br>
<br>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线
<br>两根通信线：串行时钟SCL（Serial Clock）、串行数据SDA（Serial Data）
<br>同步、半双工，带数据应答
<br>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度
<br><img alt="IMG-635208D0B5C8384086290A85E66F8216-20240919203953270" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-635208D0B5C8384086290A85E66F8216-20240919203953270.png" referrerpolicy="no-referrer"><br><img alt="IMG-D2757E8CEA0BE0CA5E5916F3ECE44910-20240919203953899" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D2757E8CEA0BE0CA5E5916F3ECE44910-20240919203953899.png" referrerpolicy="no-referrer"><br><img alt="IMG-CB990E5504180C98F363D6CDB0BD5E2D-20240919203953921" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-CB990E5504180C98F363D6CDB0BD5E2D-20240919203953921.png" referrerpolicy="no-referrer"><br><br>
<br>所有I2C设备的SCL连在一起，SDA连在一起
<br>设备的SCL和SDA均要配置成开漏输出模式
<br>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右
<br>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题

<br>开漏输出是指设备的SCL,SDA的端口没有上拉电阻,当输出开关闭合时端口接地,当输出开关断开时,端口置空,即开漏.
<br>设备的SCL和SDA配置成开漏输出模式时, 引脚没有驱动能力,相当于设备断开.没有配置成开漏输出的设备可以借助总线连接的上拉电阻获得驱动能力,与主机通信.


<br><img alt="IMG-0524279143C0DF7B00173282275FE692-20240919203953307" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0524279143C0DF7B00173282275FE692-20240919203953307.png" referrerpolicy="no-referrer"><br><img alt="IMG-FD6D697C7F0D2BA180226DA5ECBF5D71-20240919203955890" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FD6D697C7F0D2BA180226DA5ECBF5D71-20240919203955890.png" referrerpolicy="no-referrer"><br><br><br>
<br>起始条件：SCL高电平期间，SDA从高电平切换到低电平
<br>终止条件：SCL高电平期间，SDA从低电平切换到高电平
<br><img alt="IMG-A2908AE6FF2D84A7C0A834258ABD177B-20240919203955926" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A2908AE6FF2D84A7C0A834258ABD177B-20240919203955926.png" referrerpolicy="no-referrer"><br>
<br>
起始之后, 需要将SCL降到低电平,保证后面的数据可以衔接上,这样不会产生多余的信号.

<br>
在SCL高电平期间,SDA电平发生变化表示起止条件;

<br>
在SCL高电平期间,SDA电平不变表示发送的字节

<br><br>
<br>发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上（高位在前），然后拉高SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节
<br><img alt="IMG-8011F88E4D6760B0F47F93F333516DD8-20240919203957610" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8011F88E4D6760B0F47F93F333516DD8-20240919203957610.png" referrerpolicy="no-referrer"><br><br>
<br>接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上（高位在前），然后拉高SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）
<br><img alt="IMG-B92A722C1A64E01C0AC7D2F4C396E876-20240919203957651" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-B92A722C1A64E01C0AC7D2F4C396E876-20240919203957651.png" referrerpolicy="no-referrer"><br><br>
<br>发送应答：在接收完一个字节之后，主机在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答
<br>接收应答：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）
<br><img alt="IMG-1122FBF34116C7750D6F8100F6DF28A2-20240919203959566" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-1122FBF34116C7750D6F8100F6DF28A2-20240919203959566.png" referrerpolicy="no-referrer"><br>
<br>应答相当于第9个字节,

<br>1表示非应答是因为总线默认是高电平状态,开漏输出的设备无法控制总线降到低电平.
<br>只有在通信的设备可以应答,即数据0.


<br><br><br>
<br>发送一帧数据<br>
<img alt="IMG-488E8343BCE38EE8AFA12C08987E802C-20240919203959602" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-488E8343BCE38EE8AFA12C08987E802C-20240919203959602.png" referrerpolicy="no-referrer">
<br>完成任务：向谁发什么 

<br>主机发出开始通信信号
<br>之后发送一个字节,内容是需要通信的从机地址加上W(写),表示该数据是向谁发送.

<br>地址一般是7位,加上读写位第一个字节共8位.  表示0是W(写),1是R(读). 


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后发送后面的数据
<br>循环下列操作直到全部发送完成

<br>主机发送一个字节的数据
<br>从机接收后应答


<br>数据全部发送后主机发出停止通信信号


<br><br>
<br>接收一帧数据<br>
<img alt="IMG-2FD3C8335862C508E1EACED6899437ED-20240919204001234" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2FD3C8335862C508E1EACED6899437ED-20240919204001234.png" referrerpolicy="no-referrer">
<br>完成任务：向谁收什么 

<br>主机发出开始通信信号
<br>主机发送第一个字节,从机地址加上R(读),表示要接收谁的数据.

<br>地址一般是7位,加上读写位第一个字节共8位.  表示0是W(写),1是R(读).


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后接收后面的数据
<br>循环下列操作直到全部接收

<br>主机接收一个字节的数据
<br>主机接收后发送应答


<br>若不在接收数据,主机发送非应答

<br>非应答就是在下一个时序不操作,会自动发送非应答


<br>停止通信


<br><br>
<br>先发送再接收数据帧（复合格式）<br>
<img alt="IMG-4CB23F3390D71F8D84EACD640B1E74AE-20240919204001283" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-4CB23F3390D71F8D84EACD640B1E74AE-20240919204001283.png" referrerpolicy="no-referrer">
<br>完成任务：向谁收指定的什么
<br><br><br><br><br>
<br>
AT24C02的固定地址为1010，可配置地址本开发板上为000所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1

<br>
字节写：在WORD ADDRESS处写入数据DATA

<br><img alt="IMG-D21C88508D34FFAF1C8E5DE5859E3A24-20240919204001625" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D21C88508D34FFAF1C8E5DE5859E3A24-20240919204001625.png" referrerpolicy="no-referrer">


<br>
随机读：读出在WORD ADDRESS处的数据DATA

<br><img alt="IMG-6D11089DEF81077148400BB21706DE55-20240919204003334" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6D11089DEF81077148400BB21706DE55-20240919204003334.png" referrerpolicy="no-referrer">


<br>
字节写：在“字地址”处写入“数据”

<br><img alt="IMG-8D013A1CCC3A21ED3A6474FD4D2CFAC1-20240919204003409" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8D013A1CCC3A21ED3A6474FD4D2CFAC1-20240919204003409.png" referrerpolicy="no-referrer">


<br>
随机读：读出在“字地址”处的“数据”

<br><img alt="IMG-45C8FE526CC071350D743126B9BEC088-20240919204005333" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-45C8FE526CC071350D743126B9BEC088-20240919204005333.png" referrerpolicy="no-referrer">


<br><br>
<br>读取AT24C02数据

<br>主机发出开始通信信号
<br>之后发送一个字节,内容是需要通信的从机地址加上W(写),表示该数据是向谁发送.

<br>地址一般是7位,加上读写位第一个字节共8位.  表示0是W(写),1是R(读).


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后发送后面的数据地址
<br>主机发送数据地址,从机接收后应答
<br>主机接收到应答后重新开始接收数据

<br>主机发出开始通信信号
<br>主机发送第一个字节,从机地址加上R(读),表示要接收谁的数据.

<br>地址一般是7位,加上读写位第一个字节共8位.&nbsp;W―&nbsp;表示0是W(写),1是R(读).


<br>与地址不符的从机开漏输出,与地址相符的从机应答,主机接收到应答后接收后面的数据
<br>循环下列操作直到全部接收

<br>主机接收一个字节的数据
<br>主机接收后发送应答


<br>若不在接收数据,主机发送非应答

<br>非应答就是在下一个时序不操作,如果没有接收到数据,会自动发送非应答
<br>如果只想接收1字节数据,主机也可以主动发送非应答


<br>停止通信




2<br><br><br>#include &lt;REGX52.H&gt;

sbit I2C_SCL=P2^1;
sbit I2C_SDA=P2^0;
<br><br>/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void I2C_Start(void)
{
	I2C_SDA=1;
	I2C_SCL=1;
	I2C_SDA=0;
	I2C_SCL=0;
}
<br><br>/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void I2C_Stop(void)
{
	I2C_SDA=0;
	I2C_SCL=1;
	I2C_SDA=1;
}
<br><br>/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void I2C_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i&lt;8;i++)
	{
		I2C_SDA=Byte&amp;(0x80&gt;&gt;i);
		I2C_SCL=1;
		I2C_SCL=0;
	}
}
<br><br>/**
  * @brief  I2C接收一个字节
  * @param  无
  * @retval 接收到的一个字节数据
  */
unsigned char I2C_ReceiveByte(void)
{
	unsigned char i,Byte=0x00;
	I2C_SDA=1;
	for(i=0;i&lt;8;i++)
	{
		I2C_SCL=1;
		if(I2C_SDA){Byte|=(0x80&gt;&gt;i);}
		I2C_SCL=0;
	}
	return Byte;
}
<br><br>/**
  * @brief  I2C发送应答
  * @param  AckBit 应答位，0为应答，1为非应答
  * @retval 无
  */
void I2C_SendAck(unsigned char AckBit)
{
	I2C_SDA=AckBit;
	I2C_SCL=1;
	I2C_SCL=0;
}
<br><br>/**
  * @brief  I2C接收应答位
  * @param  无
  * @retval 接收到的应答位，0为应答，1为非应答
  */
unsigned char I2C_ReceiveAck(void)
{
	unsigned char AckBit;
	I2C_SDA=1;
	I2C_SCL=1;
	AckBit=I2C_SDA;
	I2C_SCL=0;
	return AckBit;
}
<br><br>写一个程序 演示I2C总线<br>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
 
 // I2C protocol definitions 
 #define I2C_START 0x08    // Start condition sent from master to initiate data transfer 
 #define I2C_DATA 0x10     // Data byte sent from master to slave 
 #define I2C_ACK 0x18      // Acknowledge sent by slave to master after receiving a data byte 
 #define I2C_STOP 0x20     // Stop condition sent from master to end data transfer 

 // Function prototypes 
 void i2c_start(void);  
 void i2c_stop(void);  
 bool i2c_sendData(uint8_t data);  

 int main(void) {  

     printf("I2C Demo\n");  

     while (1) {  

         // Initiate a start condition on the bus  
         i2c_start();   

         /* Send some data */  

         if (i2c_sendData(0xAA)) {    // Send 0xAA as data byte. The return value is true if slave ACKs the byte, false otherwise.            

             printf("Data sent successfully\n");            

         } else {             

             printf("Error sending data\n");             

         }     

         // End the communication by sending a stop condition on the bus       
         i2c_stop();   

     }      

     return 0; 
 }  

 void i2c_start(void) {       
     /* Code to issue start condition on the bus */   												  }   

 void i2c_stop(void) {        /* Code to issue stop condition on the bus */    }     

 bool i2c_sendData(uint8_t data) {        /* Code to send a data byte over I 2 C and check for ACK */    }

]]></description><link>2_Areas\C51单片机\I2C总线.html</link><guid isPermaLink="false">2_Areas/C51单片机/I2C总线.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-635208D0B5C8384086290A85E66F8216-20240919203953270.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-635208D0B5C8384086290A85E66F8216-20240919203953270.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LCD1602]]></title><description><![CDATA[ 
 <br><br><a data-href="1602液晶说明.pdf" href="1602液晶说明.pdf" class="internal-link" target="_self" rel="noopener nofollow">1602液晶说明.pdf</a><br>//QX-Mini51开发板LCD1602引脚配置：
sbit LCD_RS=P0^7; //^为异或运算符,相同为0,不同为1,
sbit LCD_RW=P0^6;
sbit LCD_EN=P0^5;
#define LCD_DataPort P2
<br>//HC6800-ES V2.0开发板LCD1602引脚配置：
sbit LCD_RS=P2^6;
sbit LCD_RW=P2^5;
sbit LCD_EN=P2^7;
#define LCD_DataPort P0
<br><br>
<br>LCD1602（Liquid Crystal Display）液晶显示屏是一种字符型液晶显示模块，可以显示ASCII码的标准字符和其它的一些内置特殊字符，还可以有8个自定义字符
<br>显示容量：16×2个字符，每个字符为5*7点阵
<br><img alt="IMG-C36CDA7345ABA2AFBE633FEF645B7696-20240919203953271" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C36CDA7345ABA2AFBE633FEF645B7696-20240919203953271.png" referrerpolicy="no-referrer"><br><img alt="IMG-254046FBA877D035592630A5E7BE46BF-20240919203953960" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-254046FBA877D035592630A5E7BE46BF-20240919203953960.png" referrerpolicy="no-referrer"><br><img alt="IMG-A9BF711F7954707AF73C9A72C6FB20CC-20240919203955964" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-A9BF711F7954707AF73C9A72C6FB20CC-20240919203955964.png" referrerpolicy="no-referrer"><br><img alt="IMG-5711E2C6B842A76580A97BF6424CE5A6-20240919203955986" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5711E2C6B842A76580A97BF6424CE5A6-20240919203955986.png" referrerpolicy="no-referrer"><br><img alt="IMG-E37A9642CB9EDD45722526E45FCC3641-20240919203957723" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E37A9642CB9EDD45722526E45FCC3641-20240919203957723.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-3AEBE341BCC710F475991785EEA4FDFA-20240919203957764" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3AEBE341BCC710F475991785EEA4FDFA-20240919203957764.png" referrerpolicy="no-referrer"><br><img alt="IMG-3EA784F7D8D763EB3C6C56E3973A2C03-20240919203959660" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-3EA784F7D8D763EB3C6C56E3973A2C03-20240919203959660.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-D950420D13082404F400873E927A1352-20240919203959689" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D950420D13082404F400873E927A1352-20240919203959689.png" referrerpolicy="no-referrer"><br><br>
<br>
DDRAM（数据显示区）<br>
<img alt="IMG-48C8062C1F42D398E50C00ED5CC2F27C-20240919204001359" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-48C8062C1F42D398E50C00ED5CC2F27C-20240919204001359.png" referrerpolicy="no-referrer">

<br>
CGRAM+CGROM（字模库）

<br>列码为高4位,行码为低4位
<br>如字符A的字符码为01000001


<br><img alt="IMG-E575D5E16B5B4D8426296F94E158C966-20240919204001403" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E575D5E16B5B4D8426296F94E158C966-20240919204001403.png" referrerpolicy="no-referrer"><br><br>ASCII 表中的字符在LCD显示时不需要使用字符码,输入时直接使用'' 括起来就行<br><img alt="IMG-5D5D4530D13B858672526DABCB4BB268-20240919204002958" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5D5D4530D13B858672526DABCB4BB268-20240919204002958.png" referrerpolicy="no-referrer"><br><br>
<br>写数据/指令<br>
<img alt="IMG-68F0CC5D4E995EC06330E2270E437752-20240919204003025" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-68F0CC5D4E995EC06330E2270E437752-20240919204003025.png" referrerpolicy="no-referrer">
<br><br><img alt="IMG-547958EFC1262B2532652811C7EA094D-20240919204004757" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-547958EFC1262B2532652811C7EA094D-20240919204004757.png" referrerpolicy="no-referrer"><br><br>
<br>初始化：
<br>发送指令0x38 //八位数据接口，两行显示，5*7点阵
发送指令0x0C //显示开，光标关，闪烁关
发送指令0x06 //数据读写操作后，光标自动加一，画面不动
发送指令0x01 //清屏
<br>
<br>显示字符：
<br>发送指令0x80|AC //设置光标位置
发送数据 //发送要显示的字符数据
发送数据 //发送要显示的字符数据
……
<br><br>
<br>
字符：根据一定规则建立的数字到字符的映射（ASCII码表）<br>
例如：0x21=’!’，0x41=’A’，0x00=’\0’<br>
定义方法：char x=‘A’;（等效于char x=0x41;）

<br>
字符数组：存储字符变量的一个数组<br>
定义方法：char y[]={’A’, ’B’, ’C’};<br>
（等效于char y[]={0x41,0x42,0x43}; ）

<br>
字符串：在字符数组后加一个字符串结束标志，本质上是字符数组<br>
定义方法：char z[]=”ABC”;<br>
（等效于char z[]={’A’, ’B’, ’C’, ’\0’};）

<br><br>sbit led1 = P1^0 含义：是将发光二极管 led1 接 P1口 0 位端，用以控制 led1 的亮灭。<br>sbit是定义特殊功能寄存器的位变量。bit和sbit都是C51扩展的变量类型。<br>
典型应用是：sbit P0_0=P0^0;//即定义P0_0为P0口的第1位，以便进行位操作。<br>
bit和int char之类的差不多，只不过char=8位, bit=1位而已。都是变量，编译器在编译过程中分配地址。<br>扩展资料<br>在C语言里，如果直接写P1.0，C编译器并不能识别，而且P1.0也不是一个合法的C语言变量名，所以得给它另起一个名字，这里起的名为P1_0，sbit的用法有三种：<br>第一种方法：sbit 位变量名=地址值<br>第二种方法：sbit 位变量名=SFR名称^变量位地址值<br>第三种方法：sbit 位变量名=SFR地址值^变量位地址值<br>如定义PSW中的OV可以用以下三种方法：<br>sbit OV=0xd2 （1）说明：0xd2是OV的位地址值<br>sbit OV=PSW^2 （2）说明：其中PSW必须先用sfr定义好<br>sbit OV=0xD0^2 （3）说明：0xD0就是PSW的地址值<br>因此这里用sbit P1_0=P1^0;就是定义用符号P1_0来表示P1.0引脚，如果你愿意也可以起P10一类的名字，只要下面程序中也随之更改就行了<br><br>#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "Delay.h"

void main()
{
	LCD_Init();						//LCD初始化
	LCD_ShowChar(1,1,'A');			//在1行1列显示字符A
	LCD_ShowString(1,3,"Hello");	//在1行3列显示字符串Hello
	LCD_ShowNum(1,9,66,2);			//在1行9列显示数字66，长度为2
	LCD_ShowSignedNum(1,12,-88,2);	//在1行12列显示有符号数字-88，长度为2
	LCD_ShowHexNum(2,1,0xA5,2);		//在2行1列显示十六进制数字0xA5，长度为2
	LCD_ShowBinNum(2,4,0xA5,8);		//在2行4列显示二进制数字0xA5，长度为8
	LCD_ShowChar(2,13,0xDF);		//在2行13列显示编码为0xDF的字符
	LCD_ShowChar(2,14,'C');			//在2行14列显示字符C
	while(1)
	{
	}
}
<br><br><br>#include &lt;REGX52.H&gt;

//引脚配置：
sbit LCD_RS=P2^6;
sbit LCD_RW=P2^5;
sbit LCD_EN=P2^7;
#define LCD_DataPort P0
<br><br>//函数定义：
/**
  * @brief  LCD1602延时函数，12MHz调用可延时1ms
  * @param  无
  * @retval 无
  */
void LCD_Delay()
{
    unsigned char i, j;

    i = 2;
    j = 239;
    do
    {
        while (--j);
    } while (--i);
}
<br><br>/**
  * @brief  LCD1602写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void LCD_WriteCommand(unsigned char Command)
{
    LCD_RS=0;
    LCD_RW=0;
    LCD_DataPort=Command;
    LCD_EN=1;
    LCD_Delay();
    LCD_EN=0;
    LCD_Delay();
}

<br><br>/**
  * @brief  LCD1602写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void LCD_WriteData(unsigned char Data)
{
    LCD_RS=1;
    LCD_RW=0;
    LCD_DataPort=Data;
    LCD_EN=1;
    LCD_Delay();
    LCD_EN=0;
    LCD_Delay();
}
<br><br>/**
  * @brief  LCD1602设置光标位置
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @retval 无
  */
void LCD_SetCursor(unsigned char Line,unsigned char Column)
{
    if(Line==1)
    {
        LCD_WriteCommand(0x80|(Column-1));
    }
    else if(Line==2)
    {
        LCD_WriteCommand(0x80|(Column-1+0x40));
    }
}
<br><br>/**
  * @brief  LCD1602初始化函数
  * @param  无
  * @retval 无
  */
void LCD_Init()
{
    LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵
    LCD_WriteCommand(0x0c);//显示开，光标关，闪烁关
    LCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动
    LCD_WriteCommand(0x01);//光标复位，清屏
}
<br><br>/**
  * @brief  在LCD1602指定位置上显示一个字符
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @param  Char 要显示的字符
  * @retval 无
  */
void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)
{
    LCD_SetCursor(Line,Column);
    LCD_WriteData(Char);
}
<br><br>/**
  * @brief  在LCD1602指定位置开始显示所给字符串
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  String 要显示的字符串
  * @retval 无
  */
void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)
{
    unsigned char i;
    LCD_SetCursor(Line,Column);
    for(i=0;String[i]!='\0';i++)
    {
        LCD_WriteData(String[i]);
    }
}
<br><br>/**
  * @brief  返回值=X的Y次方
  */
int LCD_Pow(int X,int Y)
{
    unsigned char i;
    int Result=1;
    for(i=0;i&lt;Y;i++)
    {
        Result*=X;
    }
    return Result;
}
<br><br>/**
  * @brief  在LCD1602指定位置开始显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~65535
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
    unsigned char i;
    LCD_SetCursor(Line,Column);
    for(i=Length;i&gt;0;i--)
    {
        LCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');
    }
}
<br><br>/**
  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-32768~32767
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
{
    unsigned char i;
    unsigned int Number1;
    LCD_SetCursor(Line,Column);
    if(Number&gt;=0)
    {
        LCD_WriteData('+');
        Number1=Number;
    }
    else
    {
        LCD_WriteData('-');
        Number1=-Number;
    }
    for(i=Length;i&gt;0;i--)
    {
        LCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');
    }
}
<br><br>/**
  * @brief  在LCD1602指定位置开始以十六进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~0xFFFF
  * @param  Length 要显示数字的长度，范围：1~4
  * @retval 无
  */
void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
    unsigned char i,SingleNumber;
    LCD_SetCursor(Line,Column);
    for(i=Length;i&gt;0;i--)
    {
        SingleNumber=Number/LCD_Pow(16,i-1)%16;
        if(SingleNumber&lt;10)
        {
            LCD_WriteData(SingleNumber+'0');
        }
        else
        {
            LCD_WriteData(SingleNumber-10+'A');
        }
    }
}
<br><br>/**
  * @brief  在LCD1602指定位置开始以二进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  * @param  Length 要显示数字的长度，范围：1~16
  * @retval 无
  */
void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
    unsigned char i;
    LCD_SetCursor(Line,Column);
    for(i=Length;i&gt;0;i--)
    {
        LCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');
    }
}
]]></description><link>2_Areas\C51单片机\LCD液晶屏.html</link><guid isPermaLink="false">2_Areas/C51单片机/LCD液晶屏.md</guid><pubDate>Sun, 27 Oct 2024 03:47:10 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C36CDA7345ABA2AFBE633FEF645B7696-20240919203953271.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C36CDA7345ABA2AFBE633FEF645B7696-20240919203953271.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[led灯]]></title><description><![CDATA[ 
 <br><br>led灯：发光二极管（Light Emitting Diode），简称LED<br>发光二极管在电路中用文字符号VD表示，其图形符号如图所示。<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/20211230153444.png" referrerpolicy="no-referrer"><br>发光二极管的图形符号<br><img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/20211230153454.png" referrerpolicy="no-referrer"><br>实物分析图<br>
<img alt="IMG-0660C8F4F26AF377BB8A192B224B9EC2-20240919203953272" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0660C8F4F26AF377BB8A192B224B9EC2-20240919203953272.png" referrerpolicy="no-referrer"><br>
【注】灯泡长脚为正，短脚为负，负极要接地（gnd）
<br>普通发光二极管的工作电压一般为2~2.5V，在电路中使用时一般串联一个<br>
220Ω~1k的电阻。<br><br><br>#include "stm32f10x.h"                  // Device header

void LED_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;
	
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);
}
<br><br>void LED1_ON(void)
{
	GPIO_ResetBits(GPIOA, GPIO_Pin_1);
}

void LED1_OFF(void)
{
	GPIO_SetBits(GPIOA, GPIO_Pin_1);
}

void LED1_Turn(void)
{
	if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)
	{
		GPIO_SetBits(GPIOA, GPIO_Pin_1);
	}
	else
	{
		GPIO_ResetBits(GPIOA, GPIO_Pin_1);
	}
}
<br><br>#include &lt;REGX52.H&gt;
#include &lt;INTRINS.H&gt;

void Delay500ms()		//@12.000MHz
{
	unsigned char i, j, k;

	_nop_();
	i = 4;
	j = 205;
	k = 187;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	while(1)
	{
		P2=0xFE;//1111 1110
		Delay500ms();
		P2=0xFD;//1111 1101
		Delay500ms();
		P2=0xFB;//1111 1011
		Delay500ms();
		P2=0xF7;//1111 0111
		Delay500ms();
		P2=0xEF;//1110 1111
		Delay500ms();
		P2=0xDF;//1101 1111
		Delay500ms();
		P2=0xBF;//1011 1111
		Delay500ms();
		P2=0x7F;//0111 1111
		Delay500ms();
	}
}

]]></description><link>2_Areas\C51单片机\led灯.html</link><guid isPermaLink="false">2_Areas/C51单片机/led灯.md</guid><pubDate>Sun, 27 Oct 2024 03:47:11 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/20211230153444.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/20211230153444.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LED点阵屏]]></title><description><![CDATA[ 
 <br><br>• LED点阵屏由若干个独立的LED组成，LED以矩阵的形式排列，以灯珠亮灭来显示文字、图片、视频等。LED点阵屏广泛应用于各种公共场合，如汽车报站器、广告屏以及公告牌等<br>
• LED点阵屏分类<br>
按颜色：单色、双色、全彩按像素：88、1616等（大规模的LED点阵通常由很多个小点阵拼接而成）<br><img alt="IMG-EF011F8E63FF72D9D2C02E3C40AE0DC0-20240919203953272" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EF011F8E63FF72D9D2C02E3C40AE0DC0-20240919203953272.png" referrerpolicy="no-referrer"><br><img alt="IMG-FF61F946FCDBAF1985533BEE8B376EA6-20240919203954058" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-FF61F946FCDBAF1985533BEE8B376EA6-20240919203954058.png" referrerpolicy="no-referrer"><br><img alt="IMG-881EC15A00BD76B3AC342ABAE955786A-20240919203956024" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-881EC15A00BD76B3AC342ABAE955786A-20240919203956024.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-5A88A566368BC40E9287C12652D04A59-20240919203956052" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5A88A566368BC40E9287C12652D04A59-20240919203956052.png" referrerpolicy="no-referrer"><br><img alt="IMG-85443495C207F8EFB632E98CD75FBE91-20240919203957850" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-85443495C207F8EFB632E98CD75FBE91-20240919203957850.png" referrerpolicy="no-referrer"><br>• LED点阵屏的结构类似于数码管，只不过是数码管把每一列的像素以“8”字型排列而已<br>
• LED点阵屏与数码管一样，有共阴和共阳两种接法，不同的接法对应的电路结构不同<br>
• LED点阵屏需要进行逐行或逐列扫描，才能使所有LED同时显示<br>管脚的定义：<br>有的点阵后面标有第一脚，但是有的没有标，现在大家默认跟IC的管脚顺序一样，读法是第1脚一般在侧面有字的那一面，字是正向时左边第一脚为1，然后按逆时针排序至16脚，如图示：<br><img alt="IMG-474BE2828508CD0BB8AA1B3E86242226-20240919203959752" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-474BE2828508CD0BB8AA1B3E86242226-20240919203959752.png" referrerpolicy="no-referrer"><br><br><br><br><br><a data-href="74HC595芯片中文资料.pdf" href="74HC595芯片中文资料.pdf" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">74HC595芯片中文资料.pdf</a><br>
<a data-href="74HC595.pdf" href="74HC595.pdf" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">74HC595.pdf</a><br><img alt="IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-5037ED20FC7D044B992CD166F0D91DBB-20240919203953292.png" referrerpolicy="no-referrer"><br><img alt="IMG-8BE49BAC86CA6F0F6D75B24F30B5CA87-20240919203954789" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-8BE49BAC86CA6F0F6D75B24F30B5CA87-20240919203954789.png" referrerpolicy="no-referrer"><br><img alt="IMG-2AE86EBE95D0A48F21D12EAC9769F13E-20240919203956826" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-2AE86EBE95D0A48F21D12EAC9769F13E-20240919203956826.png" referrerpolicy="no-referrer"><br>OE: 输出使能,低电平有效.<br>
RCLK: 寄存器时钟<br>
ARCLR: 串行清零,低电平有效<br>
SRCLK: 串行时钟<br>
SER: 串行数据<br>• 74HC595是串行输入并行输出的移位寄存器，可用3根线输入串行数据，8根线输出并行数据，多片级联后，可输出16位、24位、32位等，常用于IO口扩展。<br>RCLK: 寄存器时钟<br>
SRCLK: 串行时钟<br>
SER: 串行数据<br>
<img alt="IMG-DF0F7279512A08017276413ECFFC4604-20240919203959100" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-DF0F7279512A08017276413ECFFC4604-20240919203959100.png" referrerpolicy="no-referrer"><br>Tip
如果不采用74HC595, 无法驱动点阵屏,因为单片机提供的I/O口是弱上拉. 
<br>SER输入一位数据,SRCLK上电,寄存器数据向下移位<br>
如此反复,直到输入一个字节,RCLK上电,数据锁存,即从左边搬到右边输出寄存器.<br><br><img alt="IMG-E76992EBEDDF3146546959568AA8F201-20240919204001479" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-E76992EBEDDF3146546959568AA8F201-20240919204001479.png" referrerpolicy="no-referrer"><br><img alt="IMG-6317250B8938C837F133B4B20CF44224-20240919204003110" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-6317250B8938C837F133B4B20CF44224-20240919204003110.png" referrerpolicy="no-referrer"><br><br><img alt="IMG-0177A5111C6DE9F511A7B09517AB2628-20240919204003159" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-0177A5111C6DE9F511A7B09517AB2628-20240919204003159.jpg" referrerpolicy="no-referrer"><br><img alt="IMG-BBF56432E2E0F00DE2037DAF478C972C-20240919204004966" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-BBF56432E2E0F00DE2037DAF478C972C-20240919204004966.png" referrerpolicy="no-referrer"><br><br>• sfr（special function register）：特殊功能寄存器声明<br>
例：sfr P0 = 0x80;<br>
声明P0口寄存器，物理地址为0x80<br>
• sbit（special bit）：特殊位声明<br>
例：sbit P0_1 = 0x81; 或 sbit P0_1 = P0^1;<br>
声明P0寄存器的第1位<br>
• 可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有8位，所以位的数量是寄存器数量的8倍，单片机无法对所有位进行编码，故每8个寄存器中，只有一个是可以位寻址的。对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&amp;=”、“|=”、“^=”的方法进行位操作<br>&amp;=用于位清零<br>
|=用于位赋1<br>
^=用于位取反<br><img alt="IMG-D4CF8C96DBB9EE8B5A90DA3DE89FE929-20240919204005027" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-D4CF8C96DBB9EE8B5A90DA3DE89FE929-20240919204005027.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="obsidian://booknote?type=annotation&amp;book=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%A6%E5%BA%93%5CSTC89C52.pdf&amp;id=0c0950e8-3ff4-e81d-f4cb-5fd35ff17b1e&amp;page=61&amp;rect=82.943,572.536,232.103,592.531" rel="noopener nofollow" class="external-link" href="obsidian:\\booknote?type=annotation&amp;book=嵌入式书库\STC89C52.pdf&amp;id=0c0950e8-3ff4-e81d-f4cb-5fd35ff17b1e&amp;page=61&amp;rect=82.943,572.536,232.103,592.531" target="_blank">特殊功能寄存器(SFRs)</a><br><br>#include &lt;REGX52.H&gt;
#include "Delay.h"

sbit RCK=P3^5;        //RCLK
sbit SCK=P3^6;        //SRCLK
sbit SER=P3^4;        //SER

#define MATRIX_LED_PORT        P0

/**
  * @brief  74HC595写入一个字节
  * @param  Byte 要写入的字节
  * @retval 无
  */
  
  
void _74HC595_WriteByte(unsigned char Byte)
{
    unsigned char i;
    for(i=0;i&lt;8;i++)
    {
        SER=Byte&amp;(0x80&gt;&gt;i);
        SCK=1;
        SCK=0;
    }
    RCK=1;
    RCK=0;
}

/**
  * @brief  LED点阵屏显示一列数据
  * @param  Column 要选择的列，范围：0~7，0在最左边
  * @param  Data 选择列显示的数据，高位在上，1为亮，0为灭
  * @retval 无
  */
void MatrixLED_ShowColumn(unsigned char Column,Data)
{
    _74HC595_WriteByte(Data);
    MATRIX_LED_PORT=~(0x80&gt;&gt;Column);
    Delay(1);
    MATRIX_LED_PORT=0xFF;
}


void main()
{
    SCK=0;
    RCK=0;
    while(1)
    {   //显示一个笑脸
        MatrixLED_ShowColumn(0,0x3C);
        MatrixLED_ShowColumn(1,0x42);
        MatrixLED_ShowColumn(2,0xA9);
        MatrixLED_ShowColumn(3,0x85);
        MatrixLED_ShowColumn(4,0x85);
        MatrixLED_ShowColumn(5,0xA9);
        MatrixLED_ShowColumn(6,0x42);
        MatrixLED_ShowColumn(7,0x3C);
    }
}
<br>效果<br>
<img alt="IMG-C5A929E3356E9FA40045C588E96830C9-20240919204006710" src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-C5A929E3356E9FA40045C588E96830C9-20240919204006710.png" referrerpolicy="no-referrer"><br><br>
#include &lt;REGX52.H&gt;
#include "Delay.h"

sbit RCK=P3^5;        //RCLK
sbit SCK=P3^6;        //SRCLK
sbit SER=P3^4;        //SER

#define MATRIX_LED_PORT        P0

/**
  * @brief  74HC595写入一个字节
  * @param  Byte 要写入的字节
  * @retval 无
  */
void _74HC595_WriteByte(unsigned char Byte)
{
    unsigned char i;
    for(i=0;i&lt;8;i++)
    {
        SER=Byte&amp;(0x80&gt;&gt;i);
        SCK=1;
        SCK=0;
    }
    RCK=1;
    RCK=0;
}

/**
  * @brief  点阵屏初始化
  * @param  无
  * @retval 无
  */
void MatrixLED_Init()
{
    SCK=0;
    RCK=0;
}

/**
  * @brief  LED点阵屏显示一列数据
  * @param  Column 要选择的列，范围：0~7，0在最左边
  * @param  Data 选择列显示的数据，高位在上，1为亮，0为灭
  * @retval 无
  */
void MatrixLED_ShowColumn(unsigned char Column,Data)
{
    _74HC595_WriteByte(Data);
    MATRIX_LED_PORT=~(0x80&gt;&gt;Column);
    Delay(1);
    MATRIX_LED_PORT=0xFF;
}

<br>#include &lt;REGX52.H&gt;
#include "Delay.h"
#include "MatrixLED.h"

//动画数据
unsigned char code Animation[]={
    0x3C,0x42,0xA9,0x85,0x85,0xA9,0x42,0x3C,
    0x3C,0x42,0xA1,0x85,0x85,0xA1,0x42,0x3C,
    0x3C,0x42,0xA5,0x89,0x89,0xA5,0x42,0x3C,
};

void main()
{
    unsigned char i,Offset=0,Count=0;
    MatrixLED_Init();
    while(1)
    {
        for(i=0;i&lt;8;i++)    //循环8次，显示8列数据
        {
            MatrixLED_ShowColumn(i,Animation[i+Offset]);
        }
        Count++;            //计次延时
        if(Count&gt;15)
        {
            Count=0;
            Offset+=8;        //偏移+8，切换下一帧画面
            if(Offset&gt;16)
            {
                Offset=0;
            }
        }
    }
}

]]></description><link>2_Areas\C51单片机\LED点阵屏.html</link><guid isPermaLink="false">2_Areas/C51单片机/LED点阵屏.md</guid><pubDate>Sun, 27 Oct 2024 03:47:10 GMT</pubDate><enclosure url="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EF011F8E63FF72D9D2C02E3C40AE0DC0-20240919203953272.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://obsidian12389.oss-cn-shenzhen.aliyuncs.com/image/IMG-EF011F8E63FF72D9D2C02E3C40AE0DC0-20240919203953272.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br>我的知识库]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 03 Dec 2024 06:43:19 GMT</pubDate></item></channel></rss>